<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Alpaca文档翻译</title>
    <url>/2022/06/13/Alpaca-docs/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>Alpaca
Finance是一个借贷协议，但它和Compound，Aave等单纯等待别人从池子里借款从而分红利息的项目不一样，在这里你不仅可以加上杠杆，还可以主动选择一些心仪的流动性挖矿项目并质押进去，吃到多次利润。</p>
<p>Alpaca Leverage Farming 主要有四个组成部分 1.Vault 2.Worker
3.Strategy 4.Fairlaunch(此模块另行介绍)</p>
<h2 id="architecture">Architecture</h2>
<ul>
<li>前端(Frontend) - Alpaca 前端接口</li>
<li>清算机器人(Liquidator) -
观察仓位状态，一旦出现资不抵债就进行清算的机器人</li>
<li>复投机器人(Reinvestor) - 自动收获利润又复投的机器人</li>
</ul>
<p><img
src="https://alpaca-doc.s3.ap-southeast-1.amazonaws.com/lyf/Export-3aa4ff3c-20f2-4868-95ee-96a4da364889/Contract%20Documentation%204c48a0c0db7442c6aa0268dd110e6b80/Screen_Shot_2564-09-29_at_12.03.52.png" /></p>
<h2 id="vault">Vault</h2>
<p>顾名思义，这个合约用处是存放借款者的抵押物。作为在此时贡献资金池使用率的回报，借款者还可以向Vault申请资金。一个底层资产对应一个Vault合约。</p>
<h2 id="worker">Worker</h2>
<p>worker是一个管理仓位使用方法的合约，使用方法包括但不限于
在一个DEX里开启一个流动性挖矿的仓位 平掉这个仓位 调节这个仓位
每一个worker都对应特定的一些代币和一个特定的DEX，不同的ERC20代币/DEX会使用不同的worker。</p>
<h2 id="strategy">Strategy</h2>
<p>strategy合约是具体操作DEX的合约，每次只处理一个特定场景。可以对动态指定的不同的token做出童谣的DEX操作。</p>
<h2 id="fairlaunch">FairLaunch</h2>
<p>这是Alpaca的激励组件，可以接收ERC20然后给各个token池生成Alpaca代币，每个池子的发放量存在差异</p>
<h2 id="contract-document">Contract Document</h2>
<p><a href="#Vault%20Contract">Vault Contract</a> <a
href="#Worker%20Contract">Worker Contract</a> <a
href="#Strategy%20Contract">Strategy Contract</a></p>
<h2 id="dex-integration">DEX Integration</h2>
<p>尽管Alpaca集成了不少不同的DEX，他们之间也在细节上有差别，但是大部分DEX都是基于uniswapV2的机制，在这版文档里我们只讨论与PancakeSwap对接的Worker和Strategy。即以下具体实现：</p>
<h3 id="worker-1">Worker</h3>
<p>PancakeSwap Worker</p>
<h3 id="strategy-1">Strategy</h3>
<p>PancakeswapV2RestrictedStrategyAddBaseTokenOnly Strategy
PancakeswapV2RestrictedStrategyAddTwoSidesOptimal Strategy
PancakeswapV2RestrictedStrategyLiquidate Strategy
PancakeswapV2RestrictedStrategyPartialCloseLiquidateStrategy
PancakeswapV2RestrictedStrategyPartialCloseMinimizeTrading Strategy
PancakeswapV2RestrictedStrategyWithdrawMinimizeTrading Strategy</p>
<h1 id="vault-contract">Vault Contract</h1>
<p><a name="Vault Contract"></a></p>
<p><a
href="https://github.com/alpaca-finance/bsc-alpaca-contract/blob/main/contracts/6/protocol/Vault.sol">合约源码</a></p>
<h2 id="background">Background</h2>
<p>Alpaca
Finance里最重要的一个操作是通过vaults达成的，注意是vaults而非vault，vault被设计成连接存款者和借款者的中间体，存款者把资产储存进vault，借款者可以借出来一些用于流动性挖矿。
存储token的同时，vault会给用户ibToken，用户可以用这个在Alpaca
Finance中进行更多操作，比如获得FairLaunch里的Alpaca激励，获得合作Token激励，以后还有更多。
借出token的同时，用户也可以获得debtToken，这也可以自动获得FairLuanch给的激励。</p>
<h2 id="abstract">Abstract</h2>
<ul>
<li>Vault会给用户分配ibToken，用来标记用户在此vault里所占的份额(share)。随着时间推移，利息会进入份额，1份份额(share)的实际价值会增加。</li>
<li>当用户开仓时，他们先需要在vault里放质押物。这使得vault的债务价值(debt
value)根据借款量增加。</li>
<li>一旦vault收获借款人的利息，vault的债务价值(debt
value)会随着利息增加。这意味着随着时间推移，取出资产需要用到的量要比存款时更大。</li>
<li>当用户平仓时，初始抵押品债务会从总债务中去除，流动性挖矿的利息会完整地还给lender。</li>
<li>部分利息会被项目组留下，放在保留金池子里。</li>
<li>由于用户是在不同的时间存款的，我们要用债务份额价值(debt share
value)保持记录用户从哪里进入vault。</li>
<li>债务份额(debt share)也被表示成vault铸造的生息token。</li>
<li>债务份额的计算方法：<span
class="math inline">\(\frac{DebtValue}{TotalDebtValue} \times
ExistingDebtShare\)</span></li>
</ul>
<h2 id="structs">Structs</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Position &#123;</span><br><span class="line">    address worker;</span><br><span class="line">    address owner;</span><br><span class="line">    uint256 debtShare;</span><br><span class="line">  &#125;</span><br><span class="line">mapping(uint256 =&gt; Position) public positions;</span><br></pre></td></tr></table></figure>
<h2 id="main-function">Main Function</h2>
<p>Vault 主要业务逻辑有： 1.质押token获得ibToken (deposit)
2.赎回token燃烧ibToken (withdraw)
3.执行借贷+DEX流动性挖矿操作，调用worker.work，根据Position里worker的不同具体执行逻辑也不一样
(work)
4.清算，调用worker.liquidate，根据Position里worker的不同具体执行逻辑也不一样
(kill)</p>
<h1 id="worker-contract">Worker Contract</h1>
<p><a name="Worker Contract"></a></p>
<p><a
href="https://github.com/alpaca-finance/bsc-alpaca-contract/blob/main/contracts/6/protocol/interfaces/IWorker02.sol">源码地址</a></p>
<h2 id="background-1">BackGround</h2>
<p>borrowers从vault申请款项唯一的办法就是从vault借出钱来做一些操作，特别是加杠杆的流动性挖矿。
每一个worker根据配置比如其连接的DEX和LP token pair
来进行不一样的操作，但是所有的Worker共用一个接口。
然而worker并不一定要做流动性挖矿，也可能就只是做一些简单的操作，比如Syrup
Pool。 这部分我们只讲一下所有worker共通的Interface。</p>
<h2 id="abstract-1">Abstract</h2>
<ul>
<li>在整个系统里有多个worker</li>
<li>一个worker可以根据实际情况使用不同的strategy</li>
<li>worker会把特定的token对当成整体处理，即使他们在不同的仓里</li>
<li>worker和底层资产服务强关联，比如Pancake的BNB-BUSD
worker处理不了Wault的BNB-BUSD</li>
<li>Base
token是ERC20标准，是worker的主要资产，通常与借款，本金挂钩。</li>
<li>Farm token是ERC20标准，与base token结对可以给DEX提供流动性</li>
<li>worker把Fram token和Base token成对处理，如果我们需要将现在的farm
token作为base
token就需要另一个worker，反之亦然。因为在DEX中，Pancake的BNB-BUSD 也与
Pancake的BUSD- BNB不一样。</li>
<li>Worker Config作为一个分离出来的合约，存放着worker们的配置信息</li>
</ul>
<p>worker可以被两种角色调用： 1.Operator: 大多数情况是一个Vault合约
2.Reinvestor: 白名单EOA，取出LP收益再复投</p>
<h2 id="main-function-1">Main Function</h2>
<p>1.利息复投(_reinvest) 2.调用Strategy的excute方法，并将返回的LP
token质押，根据Strategy种类不同具体实现不一样 (work)
3.计算某个position换算成baseToken的价值，用来做清算判断 (health)</p>
<h1 id="strategy-contract">Strategy Contract</h1>
<p><a name="Strategy Contract"></a></p>
<p><a
href="https://github.com/alpaca-finance/bsc-alpaca-contract/blob/main/contracts/6/protocol/interfaces/IStrategy.sol">合约源码</a></p>
<h2 id="background-2">Background</h2>
<p>顾名思义，这类合约只做一件事，那就是制定交易策略，根据DEX，token和需求不同分配不同的Strategy。这一节我们详细介绍策略逻辑和公式。值得注意的是，这个合约是一个耦合度极低的合约，只负责把传给该合约的资产在DEX中操作，再转账，几乎没有存储任何信息，也就是不参与借贷相关的任何逻辑。借贷/还账的逻辑应该在它的上层实现。</p>
<h2 id="abstract-2">Abstract</h2>
<p>根据用户的操作，前端会提供一个strategy，比如一个用户想借BUSD在Pancake开一个BUSD-
USDT的仓，前端会用PancakeswapV2RestrictedStrategyAddBaseTokenOnly(一种Strategy合约)调用Vault.work，这样Vault将会调用USDT-
BUSD PancakeSwap
的worker。worker随后调用PancakeswapV2RestrictedStrategyAddBaseTokenOnly.</p>
<h2 id="main-function-2">Main Function</h2>
<p>有六种Strategy都只有一个主要方法,excute：</p>
<h3 id="addbasetokenonly">AddBaseTokenOnly:</h3>
<p>提供base token，根据最佳方案兑换farming
token，再提供流动性拿LP，推导过程：
balance为托管处理的baseToken总量，aIn为swap为farming token的base
token，rIn，rOut是池子里的量</p>
<p><span class="math inline">\(\begin{cases} rIn\times rOut = (rIn +
aIn)\times(rOut - aOut)\\ \frac{rIn}{rOut} = \frac{balance - aIn}{ aOut
}\\ \end{cases}\)</span></p>
<p>得出<span class="math inline">\(aIn^{2} + 2rIn\times aIn - rIn\times
balance = 0\)</span>，即<span
class="math inline">\(aIn=\frac{\sqrt{rIn\times (4balance +
4rIn)}-2rIn}{2}\)</span> 与代码吻合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 aIn = AlpacaMath.sqrt(rIn.mul(balance.mul(399000000).add(rIn.mul(399000625)))).sub(rIn.mul(19975)) / 19950;</span><br></pre></td></tr></table></figure>
<h3 id="addtwosideoptimal">AddTwoSideOptimal</h3>
<p>同时提供base token和farming
token，合约转换成正好的比例提供流动性，推导过程:
bIn,bOut是用户提供的两种token量，aIn是打算换成另一种的多余Token量，aOut是换出的token量，
<span class="math inline">\(\begin{cases} rIn\times rOut = (rIn +
aIn)\times(rOut - aOut)\\ \frac{rIn + bIn }{rOut - bOut} =
\frac{bIn-aIn}{bOut+aOut}\\ \end{cases}\)</span></p>
<p>得出<span class="math inline">\(aIn^{2} + 2rIn\times aIn + \frac
{rIn\times bOut - rOut \times bIn}{rOut+bOut} \times rIn = 0\)</span>
即<span class="math inline">\(aIn = \frac{\sqrt{4rIn^{2}-4\times (\frac
{rIn\times bOut - rOut \times bIn}{rOut+bOut} \times
rIn)}-2rIn}{2}\)</span> 与代码吻合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// @dev Compute optimal deposit amount helper</span><br><span class="line">  /// @param amtA amount of token A desired to deposit</span><br><span class="line">  /// @param amtB amonut of token B desired to deposit</span><br><span class="line">  /// @param resA amount of token A in reserve</span><br><span class="line">  /// @param resB amount of token B in reserve</span><br><span class="line">  function _optimalDepositA(</span><br><span class="line">    uint256 amtA,</span><br><span class="line">    uint256 amtB,</span><br><span class="line">    uint256 resA,</span><br><span class="line">    uint256 resB</span><br><span class="line">  ) internal pure returns (uint256) &#123;</span><br><span class="line">    require(amtA.mul(resB) &gt;= amtB.mul(resA), &quot;Reversed&quot;);</span><br><span class="line"></span><br><span class="line">    uint256 a = 9975;</span><br><span class="line">    uint256 b = uint256(19975).mul(resA);</span><br><span class="line">    uint256 _c = (amtA.mul(resB)).sub(amtB.mul(resA));</span><br><span class="line">    uint256 c = _c.mul(10000).div(amtB.add(resB)).mul(resA);</span><br><span class="line"></span><br><span class="line">    uint256 d = a.mul(c).mul(4);</span><br><span class="line">    uint256 e = AlpacaMath.sqrt(b.mul(b).add(d));</span><br><span class="line"></span><br><span class="line">    uint256 numerator = e.sub(b);</span><br><span class="line">    uint256 denominator = a.mul(2);</span><br><span class="line"></span><br><span class="line">    return numerator.div(denominator);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="liquidate">Liquidate</h3>
<p>提供LPToken，取消所有流动性，之后所有farming token 兑换成base token
返还给用户。</p>
<h3 id="partialcloseliquidate">PartialCloseLiquidate</h3>
<p>前面和Liquidate一样，也是把一定量的LP取消流动性，再全兑成base
token提出来，最后留下一部分baseToken(数目是入参，一般做平账用，由合约传入)，剩下的返还给用户。</p>
<h3 id="partialcloseminimizetrading">PartialCloseMinimizeTrading</h3>
<p>提供一定量LPToken，取消流动性，返还base token和farming
token，如果base
token不够lessDebt值(数目是入参，一般做平账用，由合约传入)，用farming
token兑换至足额，并将base token和剩余的farming token返还。</p>
<h3 id="withdrawminimizetrading">WithdrawMinimizeTrading</h3>
<p>把所有的LPToken取消流动性,返还base token和farming token，如果base
token不够lessDebt值(数目是入参，一般做平账用，由合约传入)，用farming
token兑换至足额，并将base token和剩余的farming token返还。</p>
<h1 id="后记">后记</h1>
<p>Alpaca小弟也是最近刚刚接触，如果有前辈研究过这个项目还请指路一下更多的资料，谢谢大家了。</p>
]]></content>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解EVM - Part1 - 初识opcode</title>
    <url>/2022/06/17/Digging-Deep-EVM-Part1/</url>
    <content><![CDATA[<p>原文链接：https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?s=r
译者博客: <a href="alvan.coffee">Alvan的Blog</a></p>
<h3
id="digging-deep-into-the-evm-mechanics-during-contract-function-calls">Digging
deep into the EVM mechanics during contract function calls</h3>
<p>第一性原理我们经常听说，就是着重于理解事物的基本概念从而更好地理解构建与其之上的组件。</p>
<p>在智能合约的世界里，EVM和它的算法与数据结构就是第一性原理，我们写的智能合约就是建立在其之上的组件。要想成为一个优秀的solidity开发，必须要对EVM有深刻了解。</p>
<p>这系列文章的第一要义就是深入理解EVM，构建成为“shadowy super
coder”的基础知识。</p>
<h2 id="the-basics-solidity-bytecode-opcode">The Basics: Solidity →
Bytecode → Opcode</h2>
<p>开始之前，本文嘉定读者是掌握了solidity的基本用法以及怎么部署到以太坊的，后边只会简单提到，如果你想复习一下这部分知识的话请看<a
href="https://medium.com/@eiki1212/explaining-ethereum-contract-abi-evm-bytecode-6afa6e917c3b">这篇文章</a>。</p>
<p>solidity在部署到以太坊网络之前是需要被编译成字节码的，这些字节码又和一系列opcode匹配，这些opcode可以被EVM解释。</p>
<p>这一个系列会着眼于编译后字节码的特定部分并阐释他们的工作机制。在每一篇文章的结尾，你都可以对这些函数更清晰的认知。一路下来，你会学到有关EVM的许多概念。</p>
<p>今天我们就看一个基础的solidity合约，从它的字节码/opcode片段里解释一下EVM是怎么选择函数的。</p>
<p>solidity创造的运行时字节码对应着一整个合约，合约部署之后，其中可能存在多个可以被调用的函数。这里边一个基础问题是EVM怎么根据合约调用的函数知道执行哪些字节码。</p>
<h3 id="storage.sol-breakdown">1_Storage.sol Breakdown</h3>
<p>在demo里我们使用了一个Storage.sol的合约，这是remix生成的默认合约之一。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3400bba6-f870-4b68-8ba8-118562b08aef_489x538.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在这个合约里有两个函数，store(uint256) 和 retrieve()
，当函数调用的时候EVM就必须进行区分，下边就是此合约编译出的字节码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">608060405234801561001057600080fd5b50600436106100365760003560e01c80632e64cec11461003b5780636057361d14610059575b600080fd5b610043610075565b60405161005091906100d9565b60405180910390f35b610073600480360381019061006e919061009d565b61007e565b005b60008054905090565b8060008190555050565b60008135905061009781610103565b92915050565b6000602082840312156100b3576100b26100fe565b5b60006100c184828501610088565b91505092915050565b6100d3816100f4565b82525050565b60006020820190506100ee60008301846100ca565b92915050565b6000819050919050565b600080fd5b61010c816100f4565b811461011757600080fd5b5056fea2646970667358221220404e37f487a89a932dca5e77faaf6ca2de3b991f93d230604b1b8daaef64766264736f6c63430008070033 </span><br></pre></td></tr></table></figure>
<p>我们看一下下面的片段，这个片段就是函数选择器的逻辑，可以用ctrl + f
验证一下它是否在上述字节码中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60003560e01c80632e64cec11461003b5780636057361d1461005957</span><br></pre></td></tr></table></figure>
<p>这段字节码对应一系列的opcode与其输入值，你可以在<a
href="https://www.ethervm.io/">这里</a>查看EVM的opcode列表。opcode的长度为1个字节也就是最多支持256种opcode，现在EVM已使用140种。</p>
<p>下边展示了字节码所对应的opcode，它们会在EVM的调用战(call
stack)中逐条执行。比如你可以从上边的链接里找到字节码 60 代表着opcode
PUSH1等等。在这篇文章的结尾，你会对它们有一个全面的认知。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60 00                       =   PUSH1 0x00 </span><br><span class="line">35                          =   CALLDATALOAD</span><br><span class="line">60 e0                       =   PUSH1 0xe0</span><br><span class="line">1c                          =   SHR</span><br><span class="line">80                          =   DUP1  </span><br><span class="line">63 2e64cec1                 =   PUSH4 0x2e64cec1</span><br><span class="line">14                          =   EQ</span><br><span class="line">61 003b                     =   PUSH2 0x003b</span><br><span class="line">57                          =   JUMPI</span><br><span class="line">80                          =   DUP1 </span><br><span class="line">63 6057361d                 =   PUSH4 0x6057361d     </span><br><span class="line">14                          =   EQ</span><br><span class="line">61 0059                     =   PUSH2 0x0059</span><br><span class="line">57                          =   JUMPI  </span><br></pre></td></tr></table></figure>
<h3 id="smart-contract-function-calls-calldata">Smart Contract Function
Calls &amp; Calldata</h3>
<p>在深挖opcode之前需要快速过一遍我们究竟是怎么调用函数的。当我们调用一个合约函数时，需要包含有函数签名和所需参数的calldata。可以在solidity里完成:</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fa9957ce1-945b-4afa-a395-c9d2563d2094_1614x670.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>这里我们调用了合约的store函数，参数为10。我们使用abi.encodeWithSignature()获得calldata，emit会记录用于测试的calldata。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x6057361d000000000000000000000000000000000000000000000000000000000000000a</span><br></pre></td></tr></table></figure>
<p>上边就是abi.encodeWithSignature("store(uint256)", 10)
返回的字节码</p>
<p>之前提到了函数签名，现在我们再明确一下：</p>
<blockquote>
<p>函数签名就是函数规范化表示的Keccak Hash的前四个字节。</p>
</blockquote>
<p>函数标准化表示其实就是函数名+参数类型，就像 “store(uint256)” 和
“retrieve()”。你可以在<a
href="https://emn178.github.io/online-tools/keccak_256.html">这里</a>验证一下store(uint256)的hash。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keccak256(“store(uint256)”) →  first 4 bytes = 6057361d</span><br><span class="line"></span><br><span class="line">keccak256(“retrieve()”) → first 4 bytes = 2e64cec1</span><br></pre></td></tr></table></figure>
<p>我们可以看到calldata有36个字节)，前四字节对应着我们刚刚计算出来的
store(uint256)
函数签名，剩下的32个字节对应着传入的uint256参数，一个16进制的a，也就是10进制的10.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6057361d = function signature (4 bytes)</span><br><span class="line"></span><br><span class="line">000000000000000000000000000000000000000000000000000000000000000a = uint256 input (32 bytes)</span><br></pre></td></tr></table></figure>
<p>我们获得了函数选择器 6057361d，你可以ctrf +
f去opcode那一段确认一下。</p>
<h3 id="opcodes-the-call-stack">Opcodes &amp; The Call Stack</h3>
<p>现在关于EVM的函数选择器的前置知识已经学完了，现在正式开始。首先要过一遍每一个opcode和它们对调用栈的操作。如果你不熟悉栈的话可以看一下这个<a
href="https://www.youtube.com/watch?v=FNZ5o9S9prU">视频</a>。</p>
<p>PUSH1代表着把下一个字节(0x00也就是十进制0)的数据压入调用栈中，下一个opcode我们可以知道这么做的理由。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F52e45eff-44b3-4028-a075-9f5591fd2e7e_900x151.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>接下来用CALLDATALOAD弹出栈顶元素stack(0)作为该命令的输入值。</p>
<p>这个opcode要把calldata载入调用栈，而输入值(也就是上边弹出的值)是偏移量(offset)，我们设为i。栈元素是32字节，而calldata是36字节，要压入的数据就是msg.data[i:i+32]
(译者注:msg.data就是完整的calldata)，这既保证了只有32字节压栈，又允许我们访问calldata的任何一部分。</p>
<p>在这种情况下，我们并没有偏移量，因为offset =
0x00，所以我们把calldata前32字节压栈。之前我们记录过整个的call
data为“0x6057361d000000000000000000000000000000000000000000000000000000000000000a”。这意味着我们丢失了后边四个字节(“0000000a”)，如果我们想访问这个uint256变量则需要使用4字节的偏移量，忽视前四字节的函数签名，而得到完整的变量。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe6f79343-c4c4-4ee6-a29f-f1923fea5b9e_901x150.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>这次又有一个PUSH1，它想压一个0xe0，也就是十进制224。224是这么来的:
函数签名有4字节或者说32位，载入的calldata有32字节256位，256 - 32 =
224。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F161dea9b-d35b-4eb1-aac5-7adecb6cc17d_901x149.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>下一步，SHR操作意味着右移一位，而栈顶弹出的224则是移位次数，栈的下一个元素0x6057361d0…0a便是执行移位操作的主题。现在我们可以在调用栈里看到4字节的函数选择器了。如果你不了解移位操作的话请看这个<a
href="https://youtu.be/fDKUq38H2jk?t=176">视频</a>。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F8db5bd19-2271-44b3-99ed-0eec2731be5c_893x144.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>下一个是DUP1，一个复制栈顶元素的简单操作。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F40b72e9d-6e80-4232-9099-8718604542a8_896x146.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>PUSH4压入了
retrieve()的4字节函数签名(2e64cec1)，你可能疑惑evm是怎么知道这个值的，请记住字节码由solidity编译而来，它有函数名和参数类型等所有信息。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F23dc9994-e360-4205-bf5d-af92aaba42e5_899x189.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>EQ 操作会弹出两个元素去判断是否相等，在这里0x2e64cec1 != 0x6057361d
，如果他们相等则压1，不相等则压0。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F7cfc3f88-d5eb-4b03-b4c3-eb605bdeb283_895x144.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>PUSH2压入两字节的 0x003b 也就是十进制59。</p>
<p>调用栈有一个称为程序计数器的东西，它会确认字节码下一个要执行的指令在哪里，现在我们设置59是因为这是
retrieve() 函数的起始位置是59。(看下边EVM Playground
部分可以清楚这里具体是怎么实现的)。你可以看到程序字节码定位方式类似solidity代码行数，如果这个函数在59行声明，你可以使用行数来告诉机器怎么找到这个函数。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F67596d4e-054d-4cd7-b516-64b4789ee01f_900x190.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>JUMPI 表示 “jump if”
，它会弹出两个值作为参数，59表示跳转地址而第二个元素作为布尔值代表是否跳转。</p>
<p>如果真值为true，程序计数器将更新然后执行跳转到指定位置，而在我们这个例子里真值为false，程序计数器并没有改变，程序继续顺序执行。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1357763b-4150-4e14-8a8c-583ee74572aa_896x146.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>再次DUP1</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F40b72e9d-6e80-4232-9099-8718604542a8_896x146.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>PUSH4把store(uint256) (0x6057361d)压栈</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff937657d-dbb3-4133-95bb-1b3f5b8117cd_897x188.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>EQ判断，此次为真</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9c0617f7-2181-427e-9dca-917be7847f0a_898x145.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>PUSH2把 store(uint256) 的定位0x0059也就是89压栈</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F44dea0e0-9e0c-4459-bd1e-4af814c89203_898x186.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>JUMPI，这次执行跳转了，程序计数器更新为89然后到字节码的其他部分运行去了。在目的地会有一个JUMPDEST，如果目的地没有这个opcode，跳转将会失败。(
译者注: 我们可以在两个函数跳转的目的地可以找到JUMPDEST的字节码 5b )</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f3a7f3c-a5f6-4e29-888f-60708e8863dc_896x146.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>我们可以到store(uint156)的字节码处依照此法继续执行了。虽然这个合约只有2个函数，但是原理和20+函数的合约是一样的。你现在知道EVM如何基于函数调用找到函数的字节码了，这其实就是对合约里所有函数的位址进行if-else判断实现的。</p>
<h3 id="evm-playground">EVM Playground</h3>
<p>我强烈建议大家看看<a
href="https://www.evm.codes/playground%5D">这个</a>,这是一个EVM运行环境，你可以设置字节码然后在上边执行。在这里可以看到调用栈的变化，我也添加了JUMPDEST，所以你也可以看到JUMPI后发生了什么</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F86591a6b-ee71-4590-8462-4ebb38f5cb80_1503x887.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>这个EVM运行环境也可以帮你理解程序计数器，在这份代码里，可以看到每个命令的注释，其偏移量代表程序计数器标记的位置。</p>
<p>你也可以看到Run按钮左边的calldata输入，去试试把它改成retrieve()
0x2e64cec1看看有什么变化吧！只需要点击Run然后step
into按钮(就是那个弯箭头)，一步一步运行opcode。</p>
<p>本系列下一节我们会研究一下内存 <a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?s=r">EVM
Deep Dives - Part 2</a>。</p>
]]></content>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解EVM - Part1 - 存储区</title>
    <url>/2022/06/22/Digging-Deep-EVM-Part3/</url>
    <content><![CDATA[<p>原文链接：https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?s=
译者：<a href="alvan.coffe">Alvan's Blog</a></p>
<p>这是“深入理解EVM”系列的第三篇文章，需要<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&amp;s=r">第一篇</a>
和<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?s=r">第二篇</a>的前置知识，因此如果您没读过的话建议先读一下。在这一篇里，我们会仔细研究合约存储区是怎么工作的，提供一些有助于理解插槽包装(slot
packing)的思维方式，如果对装填插槽很陌生也不必担心，插槽包装的知识对EVM的骇客们至关重要，你也可以在本文结束时深刻了解它。</p>
<p>如果你玩过<a href="https://ethernaut.openzeppelin.com/">Ethernaut
Solidity Wargame Series</a>
或者其他Solidity的CTF赛事，就会知道装填插槽的知识经常是解决难题的关键。(译者注:
CTF全称Capture The
Flag，中文名夺旗赛，一般指网络安全领域的技术竞赛)。</p>
<h2 id="基础知识">基础知识</h2>
<p>在<a
href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/">“Program
the Blockchain”</a>
里对合约存储基础知识有一个相当完整的概述，我将回顾一下这篇文章里的关键知识点，当然也很推荐看一下这个全文。</p>
<h3 id="数据结构">数据结构</h3>
<p>我们先从合约存储的数据结构说起，这是我们理解其他知识的坚实基础。</p>
<p>合约存储就是一个简单的 k-v
map结构。32字节的key，32字节的value。key有32字节让我们可以拿到0到(2^256)-1的key值。</p>
<p>所有的value都会初始化为0，0不会显式写入。还挺有道理的，可观测宇宙里也是有
2^256 个原子。没有计算机能存储这个多的数据。存储区 value 置 0
返还gas，因为节点不用存储这些数据了。</p>
<p>你可以把存储区视为一个宇宙级的大数组，二进制 0 对应的 key
代表数组的第 0 个元素，二进制1对应的 key
代表数组的第一个元素，以此类推。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F13728261-0af4-4581-b03f-04057bdbb5dc_744x370.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F13728261-0af4-4581-b03f-04057bdbb5dc_744x370.png"
alt="img" /></a></p>
<h2 id="定长变量">定长变量</h2>
<p>声明为存储(storage)的的合约变量分为两种，定长变量和不定长变量。我们着重研究一下前者，看看EVM是怎么把定长便利那个装进32字节的插槽里的。关于不定长变量可以看一下<a
href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/">“Program
the Blockchain”</a> 这篇文章。</p>
<p>现在我们知道存储区是一个map，那么下一个问题就是怎么给key分配value。假设我们有以下代码。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F211a6f5d-9a81-41b9-9643-e31c141d0827_335x298.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F211a6f5d-9a81-41b9-9643-e31c141d0827_335x298.png"
alt="img" /></a></p>
<p>给定的变量都是定长的，EVM可以从 0 开始挨个装填，装完 0 装 1，装完 1
装
2，以此类推。排列顺序基于合约里变量声明的顺序，第一个被声明的变量会在0插槽。在这个例子里插槽0存储
value1，value2 是一个长度为 2 的数组，所以存在插槽1 和插槽2，value3
存储在插槽3，如下图所示：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F46352903-1395-49d0-a3a8-36b1bf5a3000_744x288.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F46352903-1395-49d0-a3a8-36b1bf5a3000_744x288.png"
alt="img" /></a></p>
<p>现在我们看一个类似的合约，猜下是怎么存的。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F48a5cb06-c390-4b92-8a20-39053f40d54c_335x316.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F48a5cb06-c390-4b92-8a20-39053f40d54c_335x316.png"
alt="img" /></a>注意变量类型不是 uint256</p>
<p>根据上一个例子你可能猜测我们会占用 0 到 3
插槽，因为有4个变量。但其实这个例子只占用了插槽0。这是变量类型不同造成的，之前我们用的都是
uint256 类型也就是32字节，在这里我们用的是 uint32，uint64 和
uint128，分别代表4字节，8字节和16字节的数据。</p>
<p>这就是插槽包装一词的由来。Solidity编译器知道一个插槽能装
32字节的数据， uint32 value1
装填在插槽0里只占用了4字节，等读到下一个可以装填的变量时，就会装进这个插槽。</p>
<p>(译者注：不知道你记不记得上一篇文章里有一个无法写入的0值插槽，它和插槽0是两个不同的东西，前者英文写作
zero slot，后者是 slot[0]，具体可见官方文档)</p>
<p>根据上边的例子我们开始从插槽0开始装填：</p>
<ul>
<li>value1 装进插槽0，占用4字节</li>
<li>插槽0剩余28字节</li>
<li>value2长4字节，小于等于28，装进插槽0</li>
<li>插槽0剩余24字节</li>
<li>value3长8字节，小于等于24，装进插槽0</li>
<li>插槽0剩余16字节</li>
<li>value4长16字节，小于等于16，装进插槽0</li>
<li>插槽0剩余0字节</li>
</ul>
<blockquote>
<p><em>注意uint8是solidity的最小类型，因此包装不能小于1字节(8位)</em></p>
</blockquote>
<p>下图展示了插槽0里存放的共32字节的4个变量。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdeb707da-60db-465d-a7c2-e45befefe3ff_744x434.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdeb707da-60db-465d-a7c2-e45befefe3ff_744x434.png"
alt="img" /></a></p>
<h2 id="evm-storage-opcodes">EVM Storage Opcodes</h2>
<p>了解了存储区数据结构和插槽包装的原理只有我们看两个相关的opcode，SSTORE
和 SLOAD。</p>
<h3 id="sstore">SSTORE</h3>
<p>SSTORE 从调用栈取两个值，一个是32字节的 key，一个是32字节的
value。然后把 value 存在 key 值对应的插槽上，可以在<a
href="https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code=&#39;z1uFFv1%200w~z2uy8965w&#39;~\nz%2F%2F%20Example%20yv2%20w~SSTORE~v~PUSHuy0xFFuvwyz~_">这里</a>看到他是怎么工作的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Example 1</span><br><span class="line">PUSH2 0xFFFF</span><br><span class="line">PUSH1 0</span><br><span class="line">SSTORE</span><br><span class="line"></span><br><span class="line">//Example 2</span><br><span class="line">PUSH2 0xFF</span><br><span class="line">PUSH2 8965</span><br><span class="line">SSTORE</span><br></pre></td></tr></table></figure>
<h3 id="sload">SLOAD</h3>
<p>SLOAD 从调用栈拿32字节的 key 值，然后把 key 值插槽的 value
拿出来压到调用栈上，可以在<a
href="https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code=&#39;wSet%20up%20thrstatez46z0~SSTOREy1z0vy2z1v~&#39;~\nz~PUSH1%20y~~wExamplrw%2F%2F%20v~SLOADre%20rvwyz~_">这里</a>看到他是怎么工作的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Set up the state</span><br><span class="line">PUSH1 46</span><br><span class="line">PUSH1 0</span><br><span class="line">SSTORE</span><br><span class="line"></span><br><span class="line">// Example 1</span><br><span class="line">PUSH1 0</span><br><span class="line">SLOAD</span><br><span class="line"></span><br><span class="line">//Example 2</span><br><span class="line">PUSH1 1</span><br><span class="line">SLOAD</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这时候你就要问了，如果 SSTORE 和 SLOAD
都是处理32字节的数据，那不足32字节被包装进插槽的怎么办呢？那上边的例子来说，我们
SLOAD 插槽0之后，拿到32字节数据，里边有 value1 到 value4
四个变量，EVM怎么知道要返回什么呢？SSTORE
也有同样的问题，如果我们每次都写32字节，那怎么确保 value2 不会覆盖
value1 呢，怎么确保 value3 不会覆盖 value2
呢？接下来我们将找出答案：</p>
<h2 id="存取被包装slot-packing的变量">存取被包装(slot
packing)的变量</h2>
<p>下边是一个仿照上个例子的合约，加上了一个方法，功能是存储然后读一个值去做算术操作。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F53bfa82f-b889-40c8-a407-3157f2e31385_457x452.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F53bfa82f-b889-40c8-a407-3157f2e31385_457x452.png"
alt="img" /></a></p>
<p>这个store()函数将会执行上边那些我们有疑问的操作：在不覆盖原有数据的情况下，将多个变量写进同一插槽，以及从插槽的32字节数据中取出我们想要的那个变量。</p>
<p>让我们看一看执行结束后，插槽0的最终状态，牢记十六进制数被机器识别为二进制码，它会在slot
packing中作为位运算的操作数。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3ce409fd-b942-42d7-b7ea-02c18c4a8993_782x338.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3ce409fd-b942-42d7-b7ea-02c18c4a8993_782x338.png"
alt="img" /></a></p>
<p>记下 0x115c 为十进制 444，0x14d 为十进制 333，0x16 为十进制
22，0x01为十进制 1，与代码里的赋值相符，一个插槽持有 4 个变量。</p>
<h3 id="位运算">位运算</h3>
<p>Slot packing使用 AND，OR 和 NOT 三个位运算，对应 EVM 的 opcode
与之同名。让我们快速过一遍。</p>
<h4 id="and">AND</h4>
<p>下看下边的两个 8 位二进制数，AND
操作第一个数的第一位和第二个数的第一位，如果都是 1 的话结果的第一位就是
1 。否则为 0。之后算两个操作数的第二位，以此类推。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F50496d7f-3e74-404c-b71c-472cf2440c2c_466x302.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F50496d7f-3e74-404c-b71c-472cf2440c2c_466x302.png"
alt="img" /></a></p>
<h4 id="or">OR</h4>
<p>OR就是两个操作数中，每位只要有一个 1 值，结果的对应位就是 1，否则为
0。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F42a806e1-3da7-4a11-901d-47d40a85ba3f_466x302.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F42a806e1-3da7-4a11-901d-47d40a85ba3f_466x302.png"
alt="img" /></a></p>
<h4 id="not">NOT</h4>
<p>NOT 有些不一样，因为他只有一个操作数，效果就是对着每一位取反。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fed511be0-14bd-4f0e-adf5-e464e8cd7b4d_466x276.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fed511be0-14bd-4f0e-adf5-e464e8cd7b4d_466x276.png"
alt="img" /></a></p>
<p>现在看看他们是怎么应用于上边solidity例子里的。</p>
<h3 id="插槽操作存储包装变量sstore">插槽操作：存储包装变量SSTORE</h3>
<p>看一下solidity代码第18行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value2 = 22;</span><br></pre></td></tr></table></figure>
<p>在这时 value1
已经存进插槽0了，现在我们需要pack一些额外数据放进这个插槽。value3 和
value4
存储的时候也是一样的逻辑。我们来看一下理论上是怎么做的，也会提供一个EVM
playground强化理解。</p>
<p>我们从以下变量开始讲起</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F4fdcbc53-b6a6-4d10-892e-ff2d3b159f53_778x244.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F4fdcbc53-b6a6-4d10-892e-ff2d3b159f53_778x244.png"
alt="img" /></a></p>
<p>注意0xffffffff 是二进制 11111111111111111111111111111111。</p>
<p>EVM干的第一件事就是用 EXP
，输入一个基数一个指数返回计算结果。我们现在使用 0x100
作为基数，代表一个字节的偏移量，之后指数为 0x04，代表 value2
的起始位置。下图展示了这个返回值的作用：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff33571de-7414-4e29-9681-d2f9f5693550_1058x284.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff33571de-7414-4e29-9681-d2f9f5693550_1058x284.png"
alt="img" /></a></p>
<p>我们得到了EXP函数的返回值，现在可以把0x16写在正确的位置上，即4字节的位置。
(译者注：0x100 的 0x04 次幂，算出来是2 ^
8，也就是0x100000000，插槽从右往左装填，相当于从右到左偏移八位)</p>
<p>我们现在还不能写进去，因为已经存储的 value1
会被覆盖，这时候掩码就发挥作用了。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F71f004c0-6d1d-40b9-a83c-3355832e3138_1058x706.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F71f004c0-6d1d-40b9-a83c-3355832e3138_1058x706.png"
alt="img" /></a></p>
<p>上图展示了掩码是怎么发挥作用的，怎么拿数据可以把待写入那个区域单独无视，其他部分正常提取。在这个情况下
value2 想占用的区域已经都置零了，如果没置零，我们将看到数据被清除。</p>
<p>(译者注：掩码的原理很简单，就是用AND命令制造一个某区域为0，其它区域数值不变的方法，比如给定一个数
0x1010，我想把从左到右第三位隐藏，那么我可以制造一个数
0x1101，即待隐藏位置为 0 其它为 1，那么由于 0 和任何数and都是0，1
和任何数and结果都与该数一致，用0x1101 AND
0x1010，我们得到了一个0x1000，第三位被抹去了，其它位数不变。用在这里就是为了抹去对应位的原值)</p>
<p>这有另一个例子是我们把4个变量全部存进去的情况下把 value2 值从 22 改成
99。看到0x016 值被清除了。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F5c1522f7-9467-4116-9c3a-a076d0bc0fcd_1058x414.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F5c1522f7-9467-4116-9c3a-a076d0bc0fcd_1058x414.png"
alt="img" /></a></p>
<p>你可能正在想 OR 是怎么用上的，这张图会展示下一个步骤：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fb9ff9609-0488-4684-848b-5d4245b0d966_1058x880.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fb9ff9609-0488-4684-848b-5d4245b0d966_1058x880.png"
alt="img" /></a></p>
<p>(译者注：就是把第一步计算的“只有
value2”的32字节数据与第二步计算的“隐藏了value2位置的32位数据”做OR操作，即可得到最终结果)</p>
<p>我们现在可以把包含 value1 和 value2 的
32字节数据写入插槽0了，他们都在正确的位置。</p>
<h3
id="插槽操作取出被包装的变量sload">插槽操作：取出被包装的变量SLOAD</h3>
<p>关于提取我们看一下solidity带么的22行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint96 value5 = value3 + uint32(666)</span><br></pre></td></tr></table></figure>
<p>我们只关心 value3
是怎么拿出来的，对它的算术计算不感兴趣。下面就是取出 value3
需要的数据，跟上边的不太一样。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fc8dffd1d-bcd2-461d-90c7-97287d7f0d2e_1148x204.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fc8dffd1d-bcd2-461d-90c7-97287d7f0d2e_1148x204.png"
alt="img" /></a></p>
<p>经过了一些修改，他们将会用于检索。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff55711ab-e05f-46a3-9291-c472409a7276_1058x672.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff55711ab-e05f-46a3-9291-c472409a7276_1058x672.png"
alt="img" /></a></p>
<p>我们现在从插槽0 里提取出了 value3，0x14d也就是十进制
333，跟solidity里看到的一样。
(译者注：就是和存储反过来了，先取出slot，再根据除法把待取一直右移到插槽最低位，最后用掩码把其它数据匿藏)</p>
<p>再次使用掩码和位操作和以帮助我们从32字节的插槽里准确提取数据，现在它放在栈上，可以执行
“value3 + uint32(666)” 了。</p>
<h2 id="evm-playground">EVM Playground</h2>
<p>这是store()的所有opcode了，你可以把它放在 <a
href="https://www.evm.codes/playground">EVM
playground</a>里跑一跑交互一下，会有一个直观的感受，可以看到调用栈和合约存储在你一步一步执行的时候是怎么变化的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// --------------------------------</span><br><span class="line">// Solidity Line 17 - &quot;value1 = 1;&quot;</span><br><span class="line">// --------------------------------</span><br><span class="line"></span><br><span class="line">PUSH1 0x01</span><br><span class="line">PUSH1 0x00</span><br><span class="line">DUP1</span><br><span class="line">PUSH2 0x0100</span><br><span class="line">EXP</span><br><span class="line">DUP2</span><br><span class="line">SLOAD</span><br><span class="line">DUP2</span><br><span class="line">PUSH4 0xffffffff</span><br><span class="line">MUL</span><br><span class="line">NOT</span><br><span class="line">AND</span><br><span class="line">SWAP1</span><br><span class="line">DUP4</span><br><span class="line">PUSH4 0xffffffff</span><br><span class="line">AND</span><br><span class="line">MUL</span><br><span class="line">OR</span><br><span class="line">SWAP1</span><br><span class="line">SSTORE</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// ---------------------------------</span><br><span class="line">// Solidity Line 18 - &quot;value2 = 22;&quot;</span><br><span class="line">// ---------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUSH1 0x16 // value2 = 22 decimal = 0x16 in hex</span><br><span class="line"></span><br><span class="line">PUSH1 0x00 // slot 0 - storage location for &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">PUSH1 0x04 // 4 bytes in - start position for &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">PUSH2 0x0100 // 0x100 in hex = 256 in decimal, 256 bits in 1 byte </span><br><span class="line"></span><br><span class="line">EXP // exponent of 0x0100 &amp; 0x04 = 0x100000000       </span><br><span class="line">    </span><br><span class="line">DUP2 // duplicate 0x00 to top of stack</span><br><span class="line"></span><br><span class="line">SLOAD // load data at slot 0</span><br><span class="line"></span><br><span class="line">DUP2 // duplicate exponent of 0x0100 &amp; 0x04 = 0x100000000</span><br><span class="line"></span><br><span class="line">PUSH4 0xffffffff // bitmask 4 bytes length      </span><br><span class="line"></span><br><span class="line">MUL // multiply to get bitmask for the 8 bytes assigned to &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">NOT // NOT operation to get bitmask for all bytes except the 8 bytes assigned to &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">AND // AND of bitmask and slot 0 value to zero out values in the 8 bytes assigned to &quot;value2&quot; and retain all other values</span><br><span class="line"></span><br><span class="line">SWAP1 // bring 0x100000000 to top of the stack</span><br><span class="line"></span><br><span class="line">DUP4 // duplicate value2 value = 22 = 0x16</span><br><span class="line"></span><br><span class="line">PUSH4 0xffffffff // bitmask 4 bytes length </span><br><span class="line"></span><br><span class="line">AND // AND to ensure the value is no more than 4 bytes in length</span><br><span class="line"></span><br><span class="line">MUL // returns value2 at the correct position - 4 bytes in</span><br><span class="line"></span><br><span class="line">OR // OR with previous value and the value AND yielded on line 38 gives us the 32 bytes that need to be stored</span><br><span class="line"></span><br><span class="line">SWAP1 // slot 0 to top of the stack</span><br><span class="line"></span><br><span class="line">SSTORE // store the 32 byte value at slot 0</span><br><span class="line"></span><br><span class="line">POP // pop 0x16 off the stack</span><br><span class="line"></span><br><span class="line">// ----------------------------------</span><br><span class="line">// Solidity Line 19 - &quot;value3 = 333;&quot;</span><br><span class="line">// ----------------------------------</span><br><span class="line"></span><br><span class="line">PUSH2 0x014d</span><br><span class="line">PUSH1 0x00</span><br><span class="line">PUSH1 0x08</span><br><span class="line">PUSH2 0x0100</span><br><span class="line">EXP</span><br><span class="line">DUP2</span><br><span class="line">SLOAD</span><br><span class="line">DUP2</span><br><span class="line">PUSH8 0xffffffffffffffff</span><br><span class="line">MUL</span><br><span class="line">NOT</span><br><span class="line">AND</span><br><span class="line">SWAP1</span><br><span class="line">DUP4</span><br><span class="line">PUSH8 0xffffffffffffffff</span><br><span class="line">AND</span><br><span class="line">MUL</span><br><span class="line">OR</span><br><span class="line">SWAP1</span><br><span class="line">SSTORE</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// -----------------------------------</span><br><span class="line">// Solidity Line 20 - &quot;value4 = 4444;&quot;</span><br><span class="line">// -----------------------------------</span><br><span class="line"></span><br><span class="line">PUSH2 0x115c</span><br><span class="line">PUSH1 0x00</span><br><span class="line">PUSH1 0x10</span><br><span class="line">PUSH2 0x0100</span><br><span class="line">EXP</span><br><span class="line">DUP2</span><br><span class="line">SLOAD</span><br><span class="line">DUP2</span><br><span class="line">PUSH16 0xffffffffffffffffffffffffffffffff</span><br><span class="line">MUL</span><br><span class="line">NOT</span><br><span class="line">AND</span><br><span class="line">SWAP1</span><br><span class="line">DUP4</span><br><span class="line">PUSH16 0xffffffffffffffffffffffffffffffff</span><br><span class="line">AND</span><br><span class="line">MUL</span><br><span class="line">OR</span><br><span class="line">SWAP1</span><br><span class="line">SSTORE</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// ----------------------------------------------------------</span><br><span class="line">// Solidity Line 22 - &quot;uint64 value5 = value3 + uint32(666);&quot;</span><br><span class="line">// ----------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUSH1 0x00</span><br><span class="line"></span><br><span class="line">PUSH2 0x029a // uint32(666)</span><br><span class="line"></span><br><span class="line">PUSH4 0xffffffff // bitmask 4 bytes length</span><br><span class="line"></span><br><span class="line">AND // ensure uint32(666) does not exceed 8 bytes, trim if it does </span><br><span class="line"></span><br><span class="line">PUSH1 0x00 // slot 0 - location of value3</span><br><span class="line"></span><br><span class="line">PUSH1 0x08 // 8 bytes in - start position for &quot;value3&quot;</span><br><span class="line"></span><br><span class="line">SWAP1 // bring 0x00 to top of stack for SLOAD of slot 0</span><br><span class="line"></span><br><span class="line">SLOAD // load data at slot 0</span><br><span class="line"></span><br><span class="line">SWAP1 // bring 0x08 to top of stack for EXP</span><br><span class="line"></span><br><span class="line">PUSH2 0x0100 // 256 bits in 1 byte </span><br><span class="line"></span><br><span class="line">EXP // exponent of 0x0100 &amp; 0x08 = 0x10000000000000000</span><br><span class="line"></span><br><span class="line">SWAP1 // get slot 0 value to top of stack</span><br><span class="line"></span><br><span class="line">DIV // DIV of slot 0 value with 0x10000000000000000 remove bottom 8 bytes  </span><br><span class="line"></span><br><span class="line">PUSH8 0xffffffffffffffff // bitmask 8 bytes length </span><br><span class="line"></span><br><span class="line">AND // Zero out bytes outside of the 8 byte mask to return variable &quot;value3&quot;</span><br><span class="line"></span><br><span class="line">// To see the rest of the opcodes for this calculation recreate the contract in remix and enter debugging mode</span><br></pre></td></tr></table></figure>
<p>在我们文章里提到的两个部分(solidity18行和22行)写了注释，强烈建议把这份代码拍一遍加深理解。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F2f0f0e5d-fd10-41d6-ad63-aa2b719f98d5_1497x847.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F2f0f0e5d-fd10-41d6-ad63-aa2b719f98d5_1497x847.png"
alt="img" /></a></p>
<p>你现在应该对存储插槽的工作原理和EVM存取插槽内特定位置数据有一定了解了，尽管SLOAD
和 SSTORE
两个opcode只能操作32字节数据，但是我们可以使用掩码和位运算存取想要的数据。</p>
<p>在这个系列的<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-5a5?s=r">第四篇</a>，我们会学习Geth是怎么实现
SSTORE 和 SLOAD 操作码的。</p>
<p>希望对您有帮助！</p>
]]></content>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>入门Defi第一步，初识DEX,AMM与LP token</title>
    <url>/2022/06/13/Intro-DEX-AMM-LP-Token/</url>
    <content><![CDATA[<h2 id="dex是什么">DEX是什么？</h2>
<p>​ DEX(Decentralized
Exchange)，即去中心化交易所，不依赖券商、银行等金融机构提供金融工具，而是利用区块链上的智能合约就可以提供交易服务的交易所。例如Uniswap，Curve，Pancake等等。</p>
<h2 id="dex与传统交易所">DEX与传统交易所</h2>
<p>​
DEX和传统交易所的区别并不只在于数据存储的方式和所有权不同，在交易方式和原理上也有着本质的区别。我们以最常见的DEX框架即AMM模型与传统交易所挂单模型对比：</p>
<h3 id="两种交易所订单簿模型的区别">两种交易所订单簿模型的区别：</h3>
<p>中心化交易所：<img src="https://fintechruminations.com/wp-content/uploads/2021/07/Screenshot-2021-07-09-at-17.12.18-1024x887.png" alt="img" style="zoom:30%;" />DEX：<img src="https://fintechruminations.com/wp-content/uploads/2021/07/Screenshot-2021-07-09-at-17.12.24-1024x500.png" alt="img" style="zoom:33%;" />
中心化交易所的卖方在交易所挂单，买方通过交易所自动撮合下单购买。
DEX的不存在买方和卖方的差异，其本质也不是购兑换对方的资产，而是直接从流动性资产池中换取需要的资产。
<small>流动性资金池(liquidity
pools)：用户交易使用的资产池，其中的资金由用户提供，提供资金的行为被称为提供流动性(add
liquidity)。为了保证交易稳定、流动性充足，提供流动性的用户(liquidity
provider)可以从每笔交易的手续费里提取分成作为奖励。</small></p>
<h3 id="两种方案的优劣比较">两种方案的优劣比较：</h3>
<table>
<thead>
<tr class="header">
<th>中心化交易所</th>
<th>DEX</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>审查身份</td>
<td>不审查身份</td>
</tr>
<tr class="even">
<td>手续费只存在于执行交易时</td>
<td>每一步操作都需要手续费</td>
</tr>
<tr class="odd">
<td>数据中心化，放在服务器</td>
<td>数据去中心化，放在区块链</td>
</tr>
<tr class="even">
<td>交易迅速</td>
<td>交易缓慢</td>
</tr>
<tr class="odd">
<td>巨鲸操盘，交易所黑幕</td>
<td>套利机器人日夜巡逻</td>
</tr>
</tbody>
</table>
<p>​
<small>存在DEX像0x协议这样使用零知识证明原理，实现“链上+链下”结合的方式实现挂单模型，在下文中DEX特指使用AMM的去中心化交易所</small></p>
<h2 id="amm和lp-token是什么">AMM和LP token是什么？</h2>
<h3 id="amm">AMM:</h3>
<p>​ AMM即Automated Market
Maker，自动化做市商。AMM应用在DEX中，使得买方和卖方之间不需要任何信任关系以及第三方就可以安全完成交易。AMM用户的买/卖本质上是在对相应资产的流动性资金池做兑换，而非买卖双方的动作。所以AMM天生适合去中心化交易所使用，只要资金池和定价模式完全依托去中心化平台，就没有任何单独实体可以操纵这个系统，同时每个人都可以在这个基础上建立新的应用。</p>
<h3 id="lp-token">LP token:</h3>
<p>​ LP token即(Liquidity Provider Token)，对于AMM来说，x -
y两种资产的兑换需要一个x - y
的资金池，而x，y两种资产由用户提供。用户把x和y资产质押进流动性以获取流动性挖矿(yield
farming )奖励，而质押的凭证就是AMM给流动性提供者签发的一种新代币，称为LP
token。 ​ 在DeFi飞速发展的过程中，DeFi的术语也在不断。很多情况下LP
token具体叫什么是随着项目变化的。比如在Balancer中，通常被称为BPT或者pools
tokens；在Uniswap里被称为liquidity tokens或者pool
tokens，在Curve中被称为LP token。</p>
<h2 id="amm的原理">AMM的原理</h2>
<p>​
AMM发展至今已经落地在不少应用中，虽然具体实现方法和应用场景略有差别，但很多以简单模型为基础改进，本节将以其代表项目UniswapV2为例讲解。各种改进算法将不做讨论
AMM实现功能靠以下两个核心功能：</p>
<h3 id="swaps">Swaps:</h3>
<p>​ AMM的token交换基于流动性资金池和恒定乘积公式算法：<span
class="math inline">\(x \times y = k\)</span>，即交易发生在 （卖出资产-
买入资产）交易对的流动性资金池中，交易价格由恒定乘积公式决定。
x，y为资金池中两种资产的量：
<img src="https://lh3.googleusercontent.com/DlgPwa6IlYeRgPkAPdwHPY7P0UCGMSiiESzvhCpUUSFuJ0HhFWG3rV1FSxEb_RFyV1JfdBQ1MUjVkzO8yDmJQXf-O0Ym0UWj-CM5xla9hARaA0kY6D6tSDhsYVhVkhbDrOj2-WHv" alt="img" style="zoom:50%;" /></p>
<p>​ 例如在一个<span class="math inline">\(x = 200\)</span>, <span
class="math inline">\(y =
300\)</span>的资金池内想用100个y来兑换x，那么有<span
class="math inline">\((y+100)\times (x- \delta x) = x \times
y\)</span>，可解兑换出50个x资产。一个池子内，x越少，就可以用x换取更多的y，反之亦然，套利者会自发将两者价格与全链同步，这就是swap的基本原理。
​
那么K值是否能够改变呢？答案是肯定的，因为手续费和流动性的原因，几乎每一笔交易成功实际发生后，k都会改变。所谓的固定乘积，是交易发生前计算价格的方法。</p>
<h3 id="liquidity-pools">Liquidity Pools:</h3>
<p>​ AMM的用户不直接与另一个用户发生交易，他们的交易要通过liquidity
pools实现，而且因为在AMM的恒定乘积公式算法中，当流动性池内资金量少时，很容易出现x，y有一个非常小导致价格离谱的情况。
​流动性资金池由用户质押资产提供，用户质押资产进入liquidity
pools，然后获得质押凭证LP
token，而提供流动性的用户也会获得手续费收益，即LP
token分红和对应交易所的治理代币。用户也可以使用LP
token赎回其质押的资产，被称为移除流动性(remove liquidity)。</p>
<h2 id="流动性挖矿与lp-tokens">流动性挖矿与LP Tokens</h2>
<p>​ LP Tokens的一个很引人注目的应用领域就是流动性挖矿(Yield
Farming)，将他们两个结合起来，是一种向多个不同合约组合操作以达到收益最大化的挖矿方式，下面举一个Curve中的例子：</p>
<ol type="1">
<li>向Curve 的liquidity pool质押DAI</li>
<li>获得LP tokens</li>
<li>将LP tokens质押进Curve的质押池</li>
<li>获得Curve利息</li>
</ol>
<h2 id="引用">引用：</h2>
<p><a
href="https://fintechruminations.com/2021/07/09/uniswap-and-the-amm-model/">UNISWAP
AND THE AMM MODEL</a> <a
href="https://www.gemini.com/cryptopedia/liquidity-provider-amm-tokens">How
Liquidity Provider (LP) Tokens Work</a></p>
]]></content>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello</title>
    <url>/2022/06/09/hello-world/</url>
    <content><![CDATA[<p>你好呀，我是张钰Alvan，主业是区块链/智能合约开发，了解一些defi项目，喜欢芥川龙之介和卡夫卡，希望能和更多的人交朋友！qq1541115709</p>
]]></content>
  </entry>
  <entry>
    <title>defi-compound经济模型</title>
    <url>/2022/06/09/test-blog/</url>
    <content><![CDATA[<p><u>注：本篇文章适合初步了解区块链以及去中心化知识的Defi初学者/合约开发者，仅供学习参考，作者不推荐中国大陆居民购买任何加密货币与其理财产品</u></p>
<h2 id="前言">前言</h2>
<p>作者在fork一份compound的项目之后，觉得其中有不少值得一说的思想，比如激励comp的分配模式，利率模型等等。这篇文章会主要从业务逻辑和合约代码来讲解其经济模型，其治理模式，预言机与其他组件不做讲解，争取做到Defi初学者看完可以理解模型，开发者看完可以直接复现(不是，compound的代码本身也出现过一些漏洞，copy需谨慎)。</p>
<h2 id="项目简介">项目简介</h2>
<h3 id="背景介绍">背景介绍</h3>
<p>compound是一个借贷合约，想想通常情况下在中心化的机构例如银行里进行质押
- 借贷的程序是：</p>
<p>小张 存入 100元 到 某银行的资金池</p>
<p>小李 抵押 价值150元的资产 从 某银行的资金池 借出 100元</p>
<p>一个月后</p>
<p>小李 还账 100元本金+1元(借款利息) 给 某银行</p>
<p>小张 取钱时 某银行按照利率 返还 100元本金和0.02元(存款利息)</p>
<p>如果小李资不抵债，银行清算小李的抵押资产，小张的借款利息不变</p>
<p>看到什么问题了吗，借款利息和存款利息受银行调控，放贷的利息远比存款利息要高。随之出现的就是P2P借贷，P2P借贷的模式繁杂，大致是以下程序：</p>
<p>小李 发布 100元借款的需求(自定义利率) 到 P2P平台</p>
<p>P2P平台 对 小李 资质审查 判断风险与是否上架</p>
<p>小张 选择 小李的借款单子 出借 100元 给 小李</p>
<p>小李 按照单子约定 还款 100元(本金) + 10元(借款利息)</p>
<p>P2P平台 中间收取 一定比例的手续费与管理费1元</p>
<p>小张 拿走其余9元利息和100元本金</p>
<p>如果小李逾期未还，看P2P平台的心情平账</p>
<p>P2P的问题依然明显，用户为了取得更高的收益承担了更多的风险，P2P平台的诚信和公正也无法保证。去中心化想要解决的就是大平台的高抽成和垄断问题和小平台的信任问题，把分账，风险评估，清算全部交给不可更改的程序，这就是co
mpound与其他Defi项目所做的事情。</p>
<h3 id="基本结构">基本结构</h3>
<p>compound提供了借款，还款，存款，取款，清算等功能，它的质押资产和借出资产都是虚拟货币。</p>
<p>其中每一种虚拟货币的资金池称为一个market，所有质押A货币的用户共同构成一个A
market。同理，所有借出A货币的用户都从这个market借款，还款。他们共同使用A
market的借款利率和抵押利率。这让风险和收益平分到了每个使用者的身上，一个人不用因为借出某个坏人而坏账，因为他们共用这个market。</p>
<p>-------这就是CToken合约做的事情</p>
<p>我们这样做的前提是可以判断质押物和借出的价值和数量。例如小李想要借走1个eth，那么他的质押物总值应该大于等于value(1
eth) / factor
，此处的factor为质押率，我们需要一个中间系统来整合每个market的情况和用户在每个market里的存款和借款。我们把CToken和用户信息登记到这个comptroller合约内，这样可以整合每个用户的资/债情况，
再由comptroller合约来对接预言机，获得虚拟货币的单价。这样通过使用每个虚拟货币的单价和用户在每个market里的质押/借出值，算出用户目前的财务状态，帮助CToken判断是否同意用户的借款/取款操作</p>
<p>-------这就是comptroller合约做的事情</p>
<p>我们在上边两个合约里解决了信任问题，使用固定利率明显不符合大开大合的加密货币市场，我们要添加一个市场调节的利率模型和利息计算模式，这也是compound的核心经济模型。我将在下一节
业务逻辑 详细介绍。</p>
<p>-------这就是InterestModel合约做的事情</p>
<p>作为一个Defi项目自然要自己发行一个新币啦，它会给每个market的用户的几乎每次财产操作发放激励，它也作为compound项目的治理代币，可以参与修改预言机或者市场的利率模型等，其激励机制我也会在下一节
业务逻辑 详细介绍。</p>
<p>-------这就是Comp合约做的事情</p>
<h2 id="业务逻辑">业务逻辑</h2>
<h3 id="业务流程">业务流程</h3>
<p>首先，我们需要一个标记用户质押资产和借款的方法，而质押资产的价值和借款的数目与价值会随着利息改变，这时引入一个概念
cToken。cToken是CToken合约发行的货币，在用户存入底层资产时，发给用户作为资产凭证。</p>
<p>比如小张存入100A币，则A market对应的CToken合约会给用户发放
100/exchangeRate 个
cA币。exchange的初始值由管理员设定，之后的公式为：</p>
<p><span class="math inline">\(exchangeRate =
\frac{totalCash+totalBorrow-totalReserves}{totalSupply}\)</span></p>
<p>其中totalSupply为发行的所有cA
币总量，totalCash为存入该market且没被借走的A币总值，totalBorrow为从market里借走的A币总量，totalReserves为CToken自己收取的中介费。</p>
<p>小李想借出一些A币，那么他向market发起借款申请：借100个A币。comptroller查询了他在所有market里的资/债情况，也就是借款记录和cB,cC,cD.......等等的持有量，判断该次操作是否会造成资不抵债，如果不会，则给小李的账户发送100A币，并在A
market里更新小李的A 借款额。</p>
<p>在小李借走100A的时间里，每一个用户的每次资产操作都会 “刷新利息/利率”
，会更新一些系数，控制exchangeRate和每个人的借款额。</p>
<p>如果小李借走100A的期间里，A币价格暴跌，套利机器人将把小李的其他资产贱卖进行平账。</p>
<p>因为一个用户的资产凭证只有cA，相同的cA在不同的时间可以兑换不同数量的A币，这就是该项目产生收益和亏损的直接原因。</p>
<h3 id="利率模型">利率模型</h3>
<h4 id="利息的产生">利息的产生</h4>
<p>每一个资产操作前都要进行的刷新利率/利息，合约内的数据变动是这样的：</p>
<p>$interestAccmulated = totalBorrow borrowRate deltaBlock $</p>
<p><span class="math inline">\(totalBorrowNew = totalBorrow +
interestAccmulated\)</span></p>
<p>$totalReservesNew = totalReserves + reservesFactor interestAccmulated
$</p>
<p><span class="math inline">\(borrowIndexNew = borrowIndex +
borrowIndex \times borrowRate \times deltaBlock\)</span></p>
<p>borrowRate是借款利率(后面细说来源)，reservesFactor是market设置的中介费系数，通常比较低。</p>
<p>borrowIndex是用来调节借款者利息的标记位，初始值为1。</p>
<p>我们可以看到如果不动任何资产，</p>
<p>对于cA持有者，也就是A的存款者来说，每一次刷新之后totalBorrow -
totalReserves 就会变大，exchangeRate就会变大，那么每一个A兑换的cA
变少了，持有cA 的人在取款时可以收到比存取时更加多的A币。</p>
<p>对于A的借款者来说，他的利息通过borrowIndex控制，每次还款和借款都会更新，具体如下：</p>
<p><span class="math inline">\(borrowAmount = \frac {principal \times
borrowIndexA} {borrowIndexB}\)</span></p>
<p>其中，principal为该账户借款的目前更新前记账数值数值，borowIndexA为整个A
market现在的borrowIndex，borrowIndexB是上一次借款时的borrowIndexA，他的借款额也就更新到账户上了。需要还掉的借款变多了。</p>
<h4 id="利率的计算">利率的计算</h4>
<p>compound的利率模型其实就是一个核心观念：市场使用率(utilizationRate)</p>
<p><span class="math inline">\(utilizationRate =
\frac{borrows}{cash+borrows-reserves}\)</span></p>
<p>使用率越高，我们的意愿是引入更多的存款者，限制更多的借款者，也就是利息越高，这时我们看借款利率：</p>
<p><span class="math inline">\(borrowRatePerBlock = baseRatePerBlock +
utilizationRate \times multiplierPerBlock\)</span></p>
<p>baseRatePerBlock和multiplierPerBlock，都由模型自己指定，作为配合市场利用率的参数。</p>
<p>实际上compound并不需要一个计算存款利率的函数，只是通过记录exchangeRate来获利，但是我们依然可以算出来</p>
<p><span class="math inline">\(supplyRatePerBlock = borrowRatePerBlock
\times utilizationRate \times (1 - reserversFactor)\)</span></p>
<h3 id="激励模型">激励模型</h3>
<p>compound的激励代币称为Comp，激励发生在每次资产交易中，分为两种，一种发放给存款人，一种发放给借款人，量的大小由该用户的持有量/借款和总量的比例决定，每一个market在一个区块里发放的激励comp是固定的，存款激励和借款激励的比例也是固定的，分别称为supplySpeed和borrowSpeed，先从这两个式子讲起</p>
<p><span class="math inline">\(SupplyIndexNew = SupplyIndex +
\frac{deltaBlocks \times SupplySpeed} {totalSupply}\)</span></p>
<p><span class="math inline">\(BorrowIndexNew = BorrowIndex +
\frac{deltablock \times
BorrowSpeed}{\frac{totalBorrows}{borrowIndex}}\)</span></p>
<p><small>在此模块里，BorrowIndex和BorrowIndex指在激励系统中标记借款激励的参数，而borrowIndex是指前文提到的利息参数。</small></p>
<p>这是每个market共用的激励记录公式，每一次激励都会刷新的两个参数，分别是SupplyIndex和BorrowIndex，每一组绑定一个market，表示该market的整体激励状态。看起来有点抽象是吧，我们再看下边两个给用户分配激励的公式：</p>
<p><span class="math inline">\(SupplierAccruedNew = SupplierAccrued +
cToken.balanceOf(user) \times (SupplyIndex - SupplierIndex)\)</span></p>
<p><span class="math inline">\(BorrowerAccruedNew = BorrowerAccruced +
\frac{cToken.borrowBalance(user) } {borrowIndex} \times (BorrowIndex -
BorrowerIndex)\)</span></p>
<p>SupplierIndex和BorrowerIndex是上次user做出对应交易时，该market的SupplyIndex和BorrowIndex。</p>
<p>SupplyIndex -
SupplierIndex则代表着这次操作中，每持有一个cToken，获得的激励量。</p>
<p>举个例子在某区块totalSuppy =
10000，小张操作资产得到激励，此时距离上次刷新的x区块又产生了100个区块，speed
= v，小张持有量为100，现在开始刷新SupplyIndex，</p>
<p><span class="math inline">\(SupplyIndex1 = SupplyIndex +
\frac{100v}{10000}\)</span></p>
<p>又过了100个区块，小张操作资产再次获得激励，其余均不变，这时的</p>
<p><span class="math inline">\(SupplyIndex2 = SupplyIndex1 +
\frac{100v}{10000}\)</span></p>
<p><span class="math inline">\(SupplierIndex = SupplyIndex1\)</span></p>
<p><span class="math inline">\(SupplierAccruedNew = SupplierAccrued +
100 \times \frac{100v}{10000}\)</span></p>
<p>这次获得的新激励是<span
class="math inline">\(\frac{balance}{totalSupply} \times speed \times
deltaBlock\)</span>，确实和我们预想的一样。</p>
<p>就是这样，完成了激励的分配，不多不少，刚好分完。</p>
<h2 id="结语">结语</h2>
<p>compound的经济模型大概就是这样了，新人初稿，大家海涵，如有错漏请多指教小弟。下一篇可能是compound源码解析或者是AMM模型，最后祝大家财运昌隆！</p>
]]></content>
  </entry>
  <entry>
    <title>深入理解EVM - Part2 - 内存</title>
    <url>/2022/06/21/Digging-Deep-EVM-Part2/</url>
    <content><![CDATA[<p>原文链接：https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?s=r
译者博客: <a href="alvan.coffee">Alvan的Blog</a></p>
<p>本系列的第二篇文章，我们会继续学习基础知识，以期成为“shadowy super
coder”。如果没看过本系列的<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&amp;s=r">第一篇</a>的话，建议看一下，有些前置的知识。在<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&amp;s=r">第一篇</a>里，我们知道了EVM如何根据字节码找到调用的函数，对调用栈，calldata，函数签名和opcode有了一定了解。在第二篇我们学习一下合约的内存(memory)是怎么在EVM里工作的。</p>
<h2 id="a-trip-down-memory-lane">A Trip Down Memory Lane</h2>
<p><a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&amp;s=r">第一篇</a>出现的1_Storage.sol
contract又来营业了。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3400bba6-f870-4b68-8ba8-118562b08aef_489x538.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>还是像上次一样，生成字节码然后把相关的截出来，在这篇里我们着重看一下前五字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6080604052</span><br><span class="line">60 80                       =   PUSH1 0x80</span><br><span class="line">60 40                       =   PUSH1 0x40</span><br><span class="line">52                          =   MSTORE </span><br></pre></td></tr></table></figure>
<p>这五个字节表示初始化“空闲内存指针”(free memory
pointer)。要想完全理解它的含义，我们必须先对管理合约内存的数据结构有一定了解。</p>
<h2 id="内存的数据结构">内存的数据结构</h2>
<p>合约的内存是一个很简单的字节数组，可以储存32字节或者1字节的数据块，也可以读取32字节的数据块。如下图所示：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F33d7994b-a4b5-4268-8d53-85f214944599_717x437.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F33d7994b-a4b5-4268-8d53-85f214944599_717x437.png"
alt="img" /></a> 来源:
https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf</p>
<p>这个功能是3个管理内存的opcode决定的</p>
<ul>
<li>MSTORE (x, y) - 以“x”处为起点，写入32字节的数据“y”</li>
<li>MLOAD (x) - 从“x”处取出32字节的数据加载到调用栈。</li>
<li>MSTORE8 (x, y) -
以“x”处为起点，写入1字节的数据“y”(调用栈的最低有效字节)</li>
</ul>
<p>你可以简单把内存位置理解成数组的索引，如果要读写超过1字节的数据，只需在下一个索引继续读写。</p>
<h2 id="evm-playground">EVM Playground</h2>
<p>这个 <a href="#evm-playground">EVM
playground</a>(https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code='Vg<em>(<em>I...1W0GJ</em>!!!!z00FK22WJQ0Y22z20F8K33W33Q1Y33z21F8d(v0Z0-Jq00Xd(vJZJ-64q20Xdv33Z33-65q21Xpp'~N
locatioCzG1_wppVv7o7hBcall stack from~uIIIIq( ofNzpbytegSTOREdw)</em>_
0xZ9BY9Chex}zXpM)
可以巩固理解这三个opcode和内存是怎么工作的。点击Run和右上角的弯箭头一步一步执行，可以看到调用栈和内存的变化(每一部分都有注释)。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe3e29126-2954-40e3-bc1b-7ca5e780fd1c_1500x850.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe3e29126-2954-40e3-bc1b-7ca5e780fd1c_1500x850.png"
alt="img" /></a></p>
<p>使用这个的时候你会发现一些奇怪的事情，首先当我们用MSTORE8把一个单字节数据0x22写进内存时，内存从这样</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F954d54e6-0bce-4de3-a61d-dd41fdae49c7_836x152.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F954d54e6-0bce-4de3-a61d-dd41fdae49c7_836x152.png"
alt="img" /></a></p>
<p>变成了这样</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F225fde5a-09bf-4a24-a702-88ad5010951e_836x176.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F225fde5a-09bf-4a24-a702-88ad5010951e_836x176.png"
alt="img" /></a></p>
<p>你可能会问，我只加了一字节，怎么补了这么多的0？</p>
<h3 id="内存扩展">内存扩展</h3>
<p>合约往内存里写数据是要根据数据大小付费的，如果要写在之前没写过的区域，还会收取首次使用的附加费用。没写过的区域是会按照32字节的增量增加的。</p>
<blockquote>
<p>前724字节，内存扩展的花费成线性增长，后边按照二次方增长</p>
</blockquote>
<p>因为我们刚刚初始化所以到处都是初始化为0的内存区域，又因为增量是32字节，就看到了内存被追加写入了2200000000000000000000000000000000000000000000000000000000000000</p>
<h3 id="牢记内存是个字节数组">牢记内存是个字节数组</h3>
<p>在33 (0x21)处跑MLOAD发现了第二件事，调用栈返回了这个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3300000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>
<p>牢记内存就是一个字节数组，我们可以在任何位置读写它，不一定是32的倍数，它记录线性的、字节级别的位置</p>
<blockquote>
<p>内存只能被函数创建。可以是复杂类型比如数组和结构体的实例化，也可能是从存储区(storage)复制过来的引用变量。</p>
</blockquote>
<p>了解了内存的数据结构之后我们老看一下空闲内存指针。</p>
<h2 id="空闲内存指针">空闲内存指针</h2>
<p>空闲内存指针就是一个简单的指向未使用内存开始处的指针，它可以确保智能合约可以记录哪些内存位置被写入了、哪些没被写入。这避免了合约用本应申请新内存的其他变量去覆盖老数据。当变量需要被写入内存时，合约会根据空闲内存指针确认数据应该写到哪里。</p>
<p>写入之后空闲内存指针会更新，根据写入数据大小确定新指针位置。像这样用一个简单的两数相加，算出新的空闲内存从哪开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">freeMemoryPointer + dataSizeBytes = newFreeMemoryPointer </span><br></pre></td></tr></table></figure>
<h3 id="字节码">字节码</h3>
<p>根据上文所题，空闲内存指针是在字节码最前边的五个opcode声明的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60 80                       =   PUSH1 0x80</span><br><span class="line">60 40                       =   PUSH1 0x40</span><br><span class="line">52                          =   MSTORE  </span><br></pre></td></tr></table></figure>
<p>这实际上是在说空闲内存指针在0x40(十进制64)位置上，有一个值0x80(十进制128)。那么0x40和0x80是怎么来的呢？我们可以在下边表格看到：</p>
<blockquote>
<p>Solidity的内存布局将前4个32字节的插槽保留:</p>
<ul>
<li><code>0x00</code> - <code>0x3f</code> (64 bytes): 暂存空间(Scratch
space)</li>
<li><code>0x40</code> - <code>0x5f</code> (32 bytes): 空闲内训指针</li>
<li><code>0x60</code> - <code>0x7f</code> (32 bytes): 插槽0</li>
</ul>
</blockquote>
<p>我们可以看到0x40是Solidity定下的空闲内存指针的位置，而紧接着这四个保留值的内存地址即为0x80。</p>
<p>我们快速过一遍这四个保留值分别是干什么的：</p>
<ul>
<li>暂存空间, 用来给hash方法和内联汇编使用。</li>
<li>空闲内存指针,
记录当前已分配的内存大小，空闲内存的起点，初始值0x80。</li>
<li>插槽0，用作动态内存数组的初始值，不会被写入。</li>
</ul>
<h3 id="合约里的内存">合约里的内存</h3>
<p>我们巩固一下上边学到的知识，从真实的Solidity代码中看一下内存和空闲内存指针是如何更新的。我故意创建了一个很简单的MemoryLane合约，只有一个函数，里边声明了长度分别为5和2的梁哥数组，然后把b[0]赋1，尽管很简单，在这三行代码运行时依然发生了很多事。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F45614789-b470-43be-9bb5-f7e0aabf35b5_393x276.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F45614789-b470-43be-9bb5-f7e0aabf35b5_393x276.png"
alt="img" /></a></p>
<p>我们把代码复制到remix里，看看这段solidity代码在EVM里的工作细节。复制之后，把它编译部署了，运行memoryLane()函数然后进debug模式，能看见这个合约的opcodes。</p>
<p>我把opcodes简化了一下，删除JUMP和其他与内存操作无关的代码。代码中添加了注释，以提供上下文。代码分为6个不同的部分。大家可以把这六部分合在一起，在EVM
Playground里跑一下。</p>
<h3
id="空闲内存指针初始化evm-playground-lines-1-15">空闲内存指针初始化(EVM
Playground Lines 1-15)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">////////////////////////////////////////</span><br><span class="line">// Free Memory Pointer Initialisation //</span><br><span class="line">////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// value to store for free memory pointer 0x80 = 128 in decimal</span><br><span class="line">PUSH1 0x80</span><br><span class="line">// location for free memory pointer 0x40 = 64 in decimal</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MSTORE</span><br><span class="line"></span><br><span class="line">// jump location (required to prevent stack underflow) </span><br><span class="line">PUSH2 0xffff</span><br></pre></td></tr></table></figure>
<p>首先，按照上边所讲的，初始化空闲内存指针，把0x80压进栈里，这是solidity内存布局规定的。在这段时间里，我们内存里什么都没有。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6437f902-7104-4009-8858-230d73a765a8_1066x198.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6437f902-7104-4009-8858-230d73a765a8_1066x198.png"
alt="img" /></a></p>
<p>然后我们再按照内存布局把空闲内存指针的地址0x40压栈。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F61258407-3f1c-44ff-a81f-982dc17a174e_1066x256.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F61258407-3f1c-44ff-a81f-982dc17a174e_1066x256.png"
alt="img" /></a></p>
<p>最后我们调用MSTORE把栈顶的0x40弹出来，0x40处的值为0x80，把它写入内存。</p>
<p>现在调用栈空了但是我们需要处理一些内存，这些内存是16进制，每一个字符对应4个比特位。现在我们有了192个16进制字符，也就是96字节(1字节=8位=2个十六进制字符)。</p>
<p>前边讲过前64字节是solidity布局规定的暂存空间，紧接着的32字节是空闲内存指针，正如下边所表示的这样：(译者注：这个Memory并不是显示MSTORE存进去什么，而是从头到位显示，直到后边全是未分配内存，所以把前边的暂存空间也显示出来了)</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F62ee6b98-6d06-4b91-a12a-45cc86a9ab5c_1066x304.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F62ee6b98-6d06-4b91-a12a-45cc86a9ab5c_1066x304.png"
alt="img" /></a></p>
<h3
id="变量-a-的内存分配和空闲内存指针更新-evm-playground-lines-16-34">变量
a 的内存分配和空闲内存指针更新 (EVM Playground Lines 16-34)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//////////////////////////////////////////////////////////////////</span><br><span class="line">// Memory Allocation Varibale “a” &amp; Free Memory Pointer Update ///</span><br><span class="line">//////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// load free memory pointer</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MLOAD</span><br><span class="line"></span><br><span class="line">// duplicate free memory pointer</span><br><span class="line">DUP1</span><br><span class="line">// 0xa0 = 160 in decimal, 32 * 5 = 160 first array is length 5</span><br><span class="line">PUSH1 0xa0</span><br><span class="line">// free memory pointer (0x80) + space for array (0xa0) = new free memory pointer</span><br><span class="line">ADD</span><br><span class="line">// Save this new value 0x120 to the free memory location</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MSTORE</span><br></pre></td></tr></table></figure>
<p>剩下的部分，在剩下的部分中，我们将跳过到每个部分的结束状态，并简要地说一下发生了什么。单独的opcode步骤可以在
<a href="https://www.evm.codes/playground">EVM
playground</a>里自行探索。下一个分配内存的是“a”
<code>(bytes32[5])</code>
，空闲内存指针也更新了。编译器会根据数组大小和元素大小决定分配多大的内存。</p>
<blockquote>
<p>牢记内存数组中的元素永远是32字节的倍数(bytes1[]也一样，但是bytes和string不是)。</p>
</blockquote>
<p>32字节倍数大小的数组会告诉我们需要分配多少内存。</p>
<p>那在这里就是5 * 32
也就是160或者说0xa0。我们可以看到它被压入堆栈并添加到当前空闲内存指针0x80(十进制为128)以获得新的空闲内存指针值。本来空闲内存指针在0x80(十进制128)，加上160后等于288，也就是16进制0x120，已经写到Memory上了。</p>
<p>调用栈里有变量a的内存起始地址0x80，以后可能会用到，0xffff是一个JuNP地址，跟内存操作无关可以忽略。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdf90605a-11c5-4d15-a055-b45dc6f93d9f_1066x378.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdf90605a-11c5-4d15-a055-b45dc6f93d9f_1066x378.png"
alt="img" /></a></p>
<h3 id="变量-a-的内存初始化-evm-playground-lines-35-95">变量 a
的内存初始化 (EVM Playground Lines 35-95)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/////////////////////////////////////////</span><br><span class="line">// Memory Initialisation Varaible “a” ///</span><br><span class="line">/////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// duplicate 0x80</span><br><span class="line">DUP1</span><br><span class="line">// push 0x05 = 5 in decimal (array length)</span><br><span class="line">PUSH1 0x05</span><br><span class="line">// Swap the top 2 items on the stack in this case 0x05 and 0x80</span><br><span class="line">SWAP1</span><br><span class="line">// push 0x20 = 32 in decimal (array item size)</span><br><span class="line">PUSH1 0x20</span><br><span class="line">// Duplicate the 3rd item on the stack in this case 0x05 to the top of the stack</span><br><span class="line">DUP3</span><br><span class="line">// 0x05 * 0x20 = 5 * 32 in decmial = 160 on top of the stack (size of array in bytes)</span><br><span class="line">MUL</span><br><span class="line">// Duplicate 0xa0 = 160 in decimal</span><br><span class="line">DUP1</span><br><span class="line">// Returns size of calldata in bytes currently just function signature = 0x04 or 4 in decmial</span><br><span class="line">CALLDATASIZE</span><br><span class="line">// duplicate 4th item on stack (0x80)</span><br><span class="line">DUP4</span><br><span class="line">// 0x80 (byte offset in the memory where the result will be copied.), 0x04 (byte offset in the calldata to copy.), 0xa0 (byte size to copy.)</span><br><span class="line"></span><br><span class="line">// this offsets the 4 bytes in our call data with a size of 0xa0 which yeild a 160 bit set of 0&#x27;s to be stored at the free memory pointer location</span><br><span class="line"></span><br><span class="line">// this effectively initialises our array in memory </span><br><span class="line">CALLDATACOPY</span><br><span class="line"></span><br><span class="line">// The remaining lines in this section manipulate the stack to ensure we have the memory location of variable &quot;a&quot; and removes any items that are no longer needed</span><br><span class="line"></span><br><span class="line">// duplicate 0xa0</span><br><span class="line">DUP1</span><br><span class="line">// duplicate 0x80</span><br><span class="line">DUP3</span><br><span class="line">// new free memory pointer as before</span><br><span class="line">ADD</span><br><span class="line">// swap 1st (0x120) item on the stack and 3rd (0x80)</span><br><span class="line">SWAP2</span><br><span class="line">// pop top item off stack (0x80)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0xa0)</span><br><span class="line">POP</span><br><span class="line">// Swap top 2 items 0x120 &amp; 0x05</span><br><span class="line">SWAP1</span><br><span class="line">// pop top item off stack (0x05)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0x120)</span><br><span class="line">POP</span><br><span class="line">// swap top 2 items 0x80 &amp; 0xb6 (jump location)</span><br><span class="line">SWAP1</span><br><span class="line">// simulating a JUMP remove the top item off stack with POP</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// Simulated jump location</span><br><span class="line">PUSH2 0xffff</span><br><span class="line">// Simulated jump location</span><br><span class="line">PUSH2 0xffff</span><br><span class="line">// simulating a JUMP, remove the top item off stack with POP</span><br><span class="line">POP</span><br></pre></td></tr></table></figure>
<p>现在内存已经被分配了，空闲内存指针也更新了，我们需要初始化变量a的内存空间。变量只是声明却没被赋值，会被初始化为0。</p>
<p>为此EVM使用CALLDATACOPY，有三个参数：</p>
<ul>
<li>memoryOffset (数据拷贝的目标地址)</li>
<li>calldataOffset (待拷贝数据在calldata里的偏移量)</li>
<li>size (需要复制的大小)</li>
</ul>
<p>在这个例子里，memoryOffset是变量 a
的内存位置0x80。calldataOffset是待复制数据在calldata中的起点，因为我们反正不想复制任何calldata，就用0值初始化。最后size就是0xa0(十进制160)。</p>
<p>我们可以看到内存已经扩展到288字节了，调用栈又拿到了a的内存位置，还有一个无关痛痒的JUMP地址。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F77921922-6699-4ef7-a248-5b96667ac1cc_1066x548.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F77921922-6699-4ef7-a248-5b96667ac1cc_1066x548.png"
alt="img" /></a></p>
<h3
id="变量-b-的内存分配和空闲内存指针更新-evm-playground-lines-96-112">变量
b 的内存分配和空闲内存指针更新 (EVM Playground Lines 96-112)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/////////////////////////////////////////////////////////////////</span><br><span class="line">// Memory Allocation Varibale “b” &amp; Free Memory Pointer Update //</span><br><span class="line">/////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// free memory pointer load in </span><br><span class="line">PUSH1 0x40</span><br><span class="line">MLOAD</span><br><span class="line">// duplicate free memory pointer (0x120)</span><br><span class="line">DUP1</span><br><span class="line">// 0x40 = 64 in decimal, 32 * 2 = 64 second array is length 2</span><br><span class="line">PUSH1 0x40</span><br><span class="line">// free memory pointer (0x120) + space for array (0x40) = new free memory pointer</span><br><span class="line">ADD</span><br><span class="line">// save new free memory pointer value at free memory location 0x40</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MSTORE</span><br></pre></td></tr></table></figure>
<p>和 a
一样，对<code>“bytes32[2] memory b”</code>也要做内存申请和更新空闲内存指针。空闲内存指针更新到0x160(即十进制的352
= 288 + 2 * 32)。内存里显示空白内存指针已更新，栈上也有了变量 b
的内存地址0x120。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6d38d4d0-f02f-4f85-a16e-11a3687ae095_1066x610.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6d38d4d0-f02f-4f85-a16e-11a3687ae095_1066x610.png"
alt="img" /></a></p>
<h3 id="变量-b-的内存初始化-evm-playground-lines-113-162">变量 b
的内存初始化 (EVM Playground Lines 113-162)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">////////////////////////////////////////</span><br><span class="line">// Memory Initialisation Variable “b” //</span><br><span class="line">////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// duplicate 0x120 (memory start location for variable &quot;b&quot;)</span><br><span class="line">DUP1</span><br><span class="line">// 0x02 = 2 in decimal = array length</span><br><span class="line">PUSH1 0x02</span><br><span class="line">// swap top 2 items 0x02 &amp; 0x120</span><br><span class="line">SWAP1</span><br><span class="line">// 0x20 = 32 in decimal (array item size in bytes)</span><br><span class="line">PUSH1 0x20</span><br><span class="line">// duplicate 3rd item on the stack 0x02</span><br><span class="line">DUP3</span><br><span class="line">// 0x02 * 0x20 = 0x40 = 64 (amount of bytes in memory to initialise)</span><br><span class="line">MUL</span><br><span class="line">// duplicate 0x40 (free memory pointer location)</span><br><span class="line">DUP1</span><br><span class="line">// same as before 4 bytes for function signature 0x04</span><br><span class="line">CALLDATASIZE</span><br><span class="line">// duplicate 4th item on the stack = 0x120</span><br><span class="line">DUP4</span><br><span class="line">// 0x120 (byte offset in the memory where the result will be copied.), 0x04 (byte offset in the calldata to copy.), 0x40 (byte size to copy.)</span><br><span class="line">CALLDATACOPY</span><br><span class="line"></span><br><span class="line">// The remaining lines in this section manipulate the stack to ensure we have the memory location of variable &quot;a&quot; and removes any items that are no longer needed</span><br><span class="line"></span><br><span class="line">//duplicate the top of the stack 0x40</span><br><span class="line">DUP1</span><br><span class="line">// duplicate 3rd item on the stack 0x120</span><br><span class="line">DUP3</span><br><span class="line">// add together yields free memory pointer value</span><br><span class="line">ADD</span><br><span class="line">// swap 0x160 &amp; 0x120</span><br><span class="line">SWAP2</span><br><span class="line">// pop top item off stack (0x120)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0x40)</span><br><span class="line">POP</span><br><span class="line">// swap 0x160 &amp; 0x02</span><br><span class="line">SWAP1</span><br><span class="line">// pop top item off stack (0x02)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0x160)</span><br><span class="line">POP</span><br><span class="line">// jump location to top of the stack 0xbe</span><br><span class="line">SWAP1</span><br><span class="line">// simulate jump pop jump location off stack</span><br><span class="line">POP</span><br></pre></td></tr></table></figure>
<p>和变量 a
的初始化一样，现在内存已经扩展到352字节，栈里保存着两个变量的内存地址。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff45435da-8528-4e99-8a43-bab75decbf06_1066x630.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff45435da-8528-4e99-8a43-bab75decbf06_1066x630.png"
alt="img" /></a></p>
<h3 id="b0赋值-evm-playground-lines-163-207">b[0]赋值 (EVM Playground
Lines 163-207)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//////////////////////////</span><br><span class="line">// Assign Value to b[0] //</span><br><span class="line">//////////////////////////</span><br><span class="line"></span><br><span class="line">// push 0x01, value to add b[0]</span><br><span class="line">PUSH1 0x01</span><br><span class="line">// push 0x00</span><br><span class="line">PUSH1 0x00</span><br><span class="line">// left shift operation no shift, first input is 0 </span><br><span class="line">SHL</span><br><span class="line">// duplicate 2nd item on stack (0x120)</span><br><span class="line">DUP2</span><br><span class="line">// push 0x00 = [0] where in the array should this item go</span><br><span class="line">PUSH1 0x00</span><br><span class="line">// push 0x20 = 64 bytes the length of the array </span><br><span class="line">PUSH1 0x02</span><br><span class="line">// duplicate 2nd item on stack (0x00)</span><br><span class="line">DUP2</span><br><span class="line">// 0x00 &lt; 0x20 =  true = 0x01 (check the user is not trying to store a value at a location that doesn&#x27;t exist in the array)</span><br><span class="line">LT</span><br><span class="line">// jump location</span><br><span class="line">PUSH2 0x00d7</span><br><span class="line">// 2 POPs since this is a JUMPI (checking if LT returned true or false)</span><br><span class="line">// simulate JUMPI </span><br><span class="line">POP</span><br><span class="line">// simulate JUMPI </span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// push 0x20 (32 bytes aray item size)</span><br><span class="line">PUSH1 0x20</span><br><span class="line">// 0x20 * 0x00 = 0x00 = 0 in decimal (array item size * index to determine byte offset)</span><br><span class="line">MUL</span><br><span class="line">// 0x00 + 0x120</span><br><span class="line">ADD</span><br><span class="line">// duplicate 2nd on stack 0x01 (value for b[0])</span><br><span class="line">DUP2</span><br><span class="line">// duplicate 2nd on stack 0x120 (memory location for b[])</span><br><span class="line">DUP2</span><br><span class="line">// store 0x01 at memory location 0x120</span><br><span class="line">MSTORE</span><br><span class="line">// clean up stack</span><br><span class="line">POP</span><br><span class="line">POP</span><br><span class="line">POP</span><br><span class="line">POP</span><br></pre></td></tr></table></figure>
<p>最后一步我们需要给数组 b 的索引0处赋值，代码显示b[0] =
1。那么0x01压栈，紧接着一个左移opcode，但是参数是0，相当于没移。</p>
<p>接下来数组索引0也就是0x00会被压入栈中，然后检查这个值是否比数组长度0x02小，如果不是的话会跳到异常处理的部分。MUL和ADD可以根据数组的索引算出写入内存的位置，一个元素32，索引为0，则在0x00的偏移量开写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x20 (32 in decimal) * 0x00 (0 in decimal) = 0x00</span><br></pre></td></tr></table></figure>
<p>偏移量加上起始位置，最终算出来该值应该在0x120被写入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00 + 0x120 = 0x120 (288 in decimal)</span><br></pre></td></tr></table></figure>
<p>最后，我们把0x01写进0x120。</p>
<p>下图展示了这个函数执行完成后的状态，栈被弹空了。</p>
<p><strong><em>实际上在用remix中调用栈上还是会有一些条目，一个跳转地址和函数签名，但是与内存操作无关，就被EVM省略了</em></strong></p>
<p>我们的内存被更新成了b[0]=1，在倒数第三行。你也可以验证一下数据位置是否正确，b[0]应该在0x120
- 0x13f (289-320字节)。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fa5516282-632f-4af3-8e0f-40b07497a9d7_1066x578.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fa5516282-632f-4af3-8e0f-40b07497a9d7_1066x578.png"
alt="img" /></a></p>
<p>成了！这里信息量很大但我们现在理解已经很深刻了，下次写代码的时候也会有不小的帮助！以前挨行跑opcode的时候经常看见内存不断弹出0x40，现在知道为什么了。</p>
<p>这个系列的下一篇，我们会<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?s=r">揭开存储插槽的神秘面纱</a>。</p>
]]></content>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
</search>
