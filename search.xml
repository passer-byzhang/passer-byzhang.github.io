<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入理解EVM - Part2 - 内存</title>
    <url>/2022/06/21/Digging-Deep-EVM-Part2/</url>
    <content><![CDATA[<p>原文链接：<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?s=r">https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?s=r</a><br>译者博客:  <a href="alvan.coffee">Alvan的Blog</a></p>
<p>本系列的第二篇文章，我们会继续学习基础知识，以期成为“shadowy super coder”。如果没看过本系列的<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&s=r">第一篇</a>的话，建议看一下，有些前置的知识。在<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&s=r">第一篇</a>里，我们知道了EVM如何根据字节码找到调用的函数，对调用栈，calldata，函数签名和opcode有了一定了解。在第二篇我们学习一下合约的内存(memory)是怎么在EVM里工作的。</p>
<h2 id="A-Trip-Down-Memory-Lane"><a href="#A-Trip-Down-Memory-Lane" class="headerlink" title="A Trip Down Memory Lane"></a>A Trip Down Memory Lane</h2><p><a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&s=r">第一篇</a>出现的1_Storage.sol contract又来营业了。</p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3400bba6-f870-4b68-8ba8-118562b08aef_489x538.png" alt="img"></p>
<p>还是像上次一样，生成字节码然后把相关的截出来，在这篇里我们着重看一下前五字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6080604052</span><br><span class="line">60 80                       =   PUSH1 0x80</span><br><span class="line">60 40                       =   PUSH1 0x40</span><br><span class="line">52                          =   MSTORE </span><br></pre></td></tr></table></figure>

<p>这五个字节表示初始化“空闲内存指针”(free memory pointer)。要想完全理解它的含义，我们必须先对管理合约内存的数据结构有一定了解。</p>
<h2 id="内存的数据结构"><a href="#内存的数据结构" class="headerlink" title="内存的数据结构"></a>内存的数据结构</h2><p>合约的内存是一个很简单的字节数组，可以储存32字节或者1字节的数据块，也可以读取32字节的数据块。如下图所示：</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F33d7994b-a4b5-4268-8d53-85f214944599_717x437.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F33d7994b-a4b5-4268-8d53-85f214944599_717x437.png" alt="img"></a><br>来源: <a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf</a></p>
<p>这个功能是3个管理内存的opcode决定的</p>
<ul>
<li>MSTORE (x, y) - 以“x”处为起点，写入32字节的数据“y”</li>
<li>MLOAD (x) - 从“x”处取出32字节的数据加载到调用栈。</li>
<li>MSTORE8 (x, y) - 以“x”处为起点，写入1字节的数据“y”(调用栈的最低有效字节)</li>
</ul>
<p>你可以简单把内存位置理解成数组的索引，如果要读写超过1字节的数据，只需在下一个索引继续读写。</p>
<h2 id="EVM-Playground"><a href="#EVM-Playground" class="headerlink" title="EVM Playground"></a>EVM Playground</h2><p>这个 [EVM playground](<a href="https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code=&#39;Vg">https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code=&#39;Vg</a><em>(<em>I…1W0GJ</em>!!!!z00FK22WJQ0Y22z20F8K33W33Q1Y33z21F8d(v0Z0-Jq00Xd(vJZJ-64q20Xdv33Z33-65q21Xpp’<del>N locatioCzG1_wppVv7o7hBcall stack from</del>uIIIIq( ofNzp\nj bytegSTOREdw)</em>_ 0xZ9BY9Chex}zXpM) 可以巩固理解这三个opcode和内存是怎么工作的。点击Run和右上角的弯箭头一步一步执行，可以看到调用栈和内存的变化(每一部分都有注释)。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe3e29126-2954-40e3-bc1b-7ca5e780fd1c_1500x850.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe3e29126-2954-40e3-bc1b-7ca5e780fd1c_1500x850.png" alt="img"></a></p>
<p>使用这个的时候你会发现一些奇怪的事情，首先当我们用MSTORE8把一个单字节数据0x22写进内存时，内存从这样</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F954d54e6-0bce-4de3-a61d-dd41fdae49c7_836x152.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F954d54e6-0bce-4de3-a61d-dd41fdae49c7_836x152.png" alt="img"></a></p>
<p>变成了这样</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F225fde5a-09bf-4a24-a702-88ad5010951e_836x176.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F225fde5a-09bf-4a24-a702-88ad5010951e_836x176.png" alt="img"></a></p>
<p>你可能会问，我只加了一字节，怎么补了这么多的0？</p>
<h3 id="内存扩展"><a href="#内存扩展" class="headerlink" title="内存扩展"></a>内存扩展</h3><p>合约往内存里写数据是要根据数据大小付费的，如果要写在之前没写过的区域，还会收取首次使用的附加费用。没写过的区域是会按照32字节的增量增加的。</p>
<blockquote>
<p>前724字节，内存扩展的花费成线性增长，后边按照二次方增长</p>
</blockquote>
<p>因为我们刚刚初始化所以到处都是初始化为0的内存区域，又因为增量是32字节，就看到了内存被追加写入了2200000000000000000000000000000000000000000000000000000000000000 </p>
<h3 id="牢记内存是个字节数组"><a href="#牢记内存是个字节数组" class="headerlink" title="牢记内存是个字节数组"></a>牢记内存是个字节数组</h3><p>在33 (0x21)处跑MLOAD发现了第二件事，调用栈返回了这个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3300000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>

<p>牢记内存就是一个字节数组，我们可以在任何位置读写它，不一定是32的倍数，它记录线性的、字节级别的位置</p>
<blockquote>
<p>内存只能被函数创建。可以是复杂类型比如数组和结构体的实例化，也可能是从存储区(storage)复制过来的引用变量。</p>
</blockquote>
<p>了解了内存的数据结构之后我们老看一下空闲内存指针。</p>
<h2 id="空闲内存指针"><a href="#空闲内存指针" class="headerlink" title="空闲内存指针"></a>空闲内存指针</h2><p>空闲内存指针就是一个简单的指向未使用内存开始处的指针，它可以确保智能合约可以记录哪些内存位置被写入了、哪些没被写入。这避免了合约用本应申请新内存的其他变量去覆盖老数据。当变量需要被写入内存时，合约会根据空闲内存指针确认数据应该写到哪里。</p>
<p>写入之后空闲内存指针会更新，根据写入数据大小确定新指针位置。像这样用一个简单的两数相加，算出新的空闲内存从哪开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">freeMemoryPointer + dataSizeBytes = newFreeMemoryPointer </span><br></pre></td></tr></table></figure>

<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>根据上文所题，空闲内存指针是在字节码最前边的五个opcode声明的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60 80                       =   PUSH1 0x80</span><br><span class="line">60 40                       =   PUSH1 0x40</span><br><span class="line">52                          =   MSTORE  </span><br></pre></td></tr></table></figure>

<p>这实际上是在说空闲内存指针在0x40(十进制64)位置上，有一个值0x80(十进制128)。那么0x40和0x80是怎么来的呢？我们可以在下边表格看到：</p>
<blockquote>
<p>Solidity的内存布局将前4个32字节的插槽保留:</p>
<ul>
<li><code>0x00</code> - <code>0x3f</code> (64 bytes): 暂存空间(Scratch space)</li>
<li><code>0x40</code> - <code>0x5f</code> (32 bytes): 空闲内训指针</li>
<li><code>0x60</code> - <code>0x7f</code> (32 bytes): 插槽0</li>
</ul>
</blockquote>
<p>我们可以看到0x40是Solidity定下的空闲内存指针的位置，而紧接着这四个保留值的内存地址即为0x80。</p>
<p>我们快速过一遍这四个保留值分别是干什么的：</p>
<ul>
<li>暂存空间, 用来给hash方法和内联汇编使用。</li>
<li>空闲内存指针, 记录当前已分配的内存大小，空闲内存的起点，初始值0x80。</li>
<li>插槽0，用作动态内存数组的初始值，不会被写入。</li>
</ul>
<h3 id="合约里的内存"><a href="#合约里的内存" class="headerlink" title="合约里的内存"></a>合约里的内存</h3><p>我们巩固一下上边学到的知识，从真实的Solidity代码中看一下内存和空闲内存指针是如何更新的。我故意创建了一个很简单的MemoryLane合约，只有一个函数，里边声明了长度分别为5和2的梁哥数组，然后把b[0]赋1，尽管很简单，在这三行代码运行时依然发生了很多事。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F45614789-b470-43be-9bb5-f7e0aabf35b5_393x276.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F45614789-b470-43be-9bb5-f7e0aabf35b5_393x276.png" alt="img"></a></p>
<p>我们把代码复制到remix里，看看这段solidity代码在EVM里的工作细节。复制之后，把它编译部署了，运行memoryLane()函数然后进debug模式，能看见这个合约的opcodes。</p>
<p>我把opcodes简化了一下，删除JUMP和其他与内存操作无关的代码。代码中添加了注释，以提供上下文。代码分为6个不同的部分。大家可以把这六部分合在一起，在EVM Playground里跑一下。</p>
<h3 id="空闲内存指针初始化-EVM-Playground-Lines-1-15"><a href="#空闲内存指针初始化-EVM-Playground-Lines-1-15" class="headerlink" title="空闲内存指针初始化(EVM Playground Lines 1-15)"></a>空闲内存指针初始化(EVM Playground Lines 1-15)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">////////////////////////////////////////</span><br><span class="line">// Free Memory Pointer Initialisation //</span><br><span class="line">////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// value to store for free memory pointer 0x80 = 128 in decimal</span><br><span class="line">PUSH1 0x80</span><br><span class="line">// location for free memory pointer 0x40 = 64 in decimal</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MSTORE</span><br><span class="line"></span><br><span class="line">// jump location (required to prevent stack underflow) </span><br><span class="line">PUSH2 0xffff</span><br></pre></td></tr></table></figure>

<p>首先，按照上边所讲的，初始化空闲内存指针，把0x80压进栈里，这是solidity内存布局规定的。在这段时间里，我们内存里什么都没有。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6437f902-7104-4009-8858-230d73a765a8_1066x198.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6437f902-7104-4009-8858-230d73a765a8_1066x198.png" alt="img"></a></p>
<p>然后我们再按照内存布局把空闲内存指针的地址0x40压栈。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F61258407-3f1c-44ff-a81f-982dc17a174e_1066x256.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F61258407-3f1c-44ff-a81f-982dc17a174e_1066x256.png" alt="img"></a></p>
<p>最后我们调用MSTORE把栈顶的0x40弹出来，0x40处的值为0x80，把它写入内存。</p>
<p>现在调用栈空了但是我们需要处理一些内存，这些内存是16进制，每一个字符对应4个比特位。现在我们有了192个16进制字符，也就是96字节(1字节&#x3D;8位&#x3D;2个十六进制字符)。</p>
<p>前边讲过前64字节是solidity布局规定的暂存空间，紧接着的32字节是空闲内存指针，正如下边所表示的这样：(译者注：这个Memory并不是显示MSTORE存进去什么，而是从头到位显示，直到后边全是未分配内存，所以把前边的暂存空间也显示出来了)</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F62ee6b98-6d06-4b91-a12a-45cc86a9ab5c_1066x304.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F62ee6b98-6d06-4b91-a12a-45cc86a9ab5c_1066x304.png" alt="img"></a></p>
<h3 id="变量-a-的内存分配和空闲内存指针更新-EVM-Playground-Lines-16-34"><a href="#变量-a-的内存分配和空闲内存指针更新-EVM-Playground-Lines-16-34" class="headerlink" title="变量 a 的内存分配和空闲内存指针更新 (EVM Playground Lines 16-34)"></a>变量 a 的内存分配和空闲内存指针更新 (EVM Playground Lines 16-34)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//////////////////////////////////////////////////////////////////</span><br><span class="line">// Memory Allocation Varibale “a” &amp; Free Memory Pointer Update ///</span><br><span class="line">//////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// load free memory pointer</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MLOAD</span><br><span class="line"></span><br><span class="line">// duplicate free memory pointer</span><br><span class="line">DUP1</span><br><span class="line">// 0xa0 = 160 in decimal, 32 * 5 = 160 first array is length 5</span><br><span class="line">PUSH1 0xa0</span><br><span class="line">// free memory pointer (0x80) + space for array (0xa0) = new free memory pointer</span><br><span class="line">ADD</span><br><span class="line">// Save this new value 0x120 to the free memory location</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MSTORE</span><br></pre></td></tr></table></figure>

<p>剩下的部分，在剩下的部分中，我们将跳过到每个部分的结束状态，并简要地说一下发生了什么。单独的opcode步骤可以在 <a href="https://www.evm.codes/playground">EVM playground</a>里自行探索。下一个分配内存的是“a” <code>(bytes32[5])</code> ，空闲内存指针也更新了。编译器会根据数组大小和元素大小决定分配多大的内存。</p>
<blockquote>
<p>牢记内存数组中的元素永远是32字节的倍数(bytes1[]也一样，但是bytes和string不是)。</p>
</blockquote>
<p>32字节倍数大小的数组会告诉我们需要分配多少内存。</p>
<p>那在这里就是5 * 32 也就是160或者说0xa0。我们可以看到它被压入堆栈并添加到当前空闲内存指针0x80(十进制为128)以获得新的空闲内存指针值。本来空闲内存指针在0x80(十进制128)，加上160后等于288，也就是16进制0x120，已经写到Memory上了。</p>
<p>调用栈里有变量a的内存起始地址0x80，以后可能会用到，0xffff是一个JuNP地址，跟内存操作无关可以忽略。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdf90605a-11c5-4d15-a055-b45dc6f93d9f_1066x378.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdf90605a-11c5-4d15-a055-b45dc6f93d9f_1066x378.png" alt="img"></a></p>
<h3 id="变量-a-的内存初始化-EVM-Playground-Lines-35-95"><a href="#变量-a-的内存初始化-EVM-Playground-Lines-35-95" class="headerlink" title="变量 a 的内存初始化 (EVM Playground Lines 35-95)"></a>变量 a 的内存初始化 (EVM Playground Lines 35-95)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/////////////////////////////////////////</span><br><span class="line">// Memory Initialisation Varaible “a” ///</span><br><span class="line">/////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// duplicate 0x80</span><br><span class="line">DUP1</span><br><span class="line">// push 0x05 = 5 in decimal (array length)</span><br><span class="line">PUSH1 0x05</span><br><span class="line">// Swap the top 2 items on the stack in this case 0x05 and 0x80</span><br><span class="line">SWAP1</span><br><span class="line">// push 0x20 = 32 in decimal (array item size)</span><br><span class="line">PUSH1 0x20</span><br><span class="line">// Duplicate the 3rd item on the stack in this case 0x05 to the top of the stack</span><br><span class="line">DUP3</span><br><span class="line">// 0x05 * 0x20 = 5 * 32 in decmial = 160 on top of the stack (size of array in bytes)</span><br><span class="line">MUL</span><br><span class="line">// Duplicate 0xa0 = 160 in decimal</span><br><span class="line">DUP1</span><br><span class="line">// Returns size of calldata in bytes currently just function signature = 0x04 or 4 in decmial</span><br><span class="line">CALLDATASIZE</span><br><span class="line">// duplicate 4th item on stack (0x80)</span><br><span class="line">DUP4</span><br><span class="line">// 0x80 (byte offset in the memory where the result will be copied.), 0x04 (byte offset in the calldata to copy.), 0xa0 (byte size to copy.)</span><br><span class="line"></span><br><span class="line">// this offsets the 4 bytes in our call data with a size of 0xa0 which yeild a 160 bit set of 0&#x27;s to be stored at the free memory pointer location</span><br><span class="line"></span><br><span class="line">// this effectively initialises our array in memory </span><br><span class="line">CALLDATACOPY</span><br><span class="line"></span><br><span class="line">// The remaining lines in this section manipulate the stack to ensure we have the memory location of variable &quot;a&quot; and removes any items that are no longer needed</span><br><span class="line"></span><br><span class="line">// duplicate 0xa0</span><br><span class="line">DUP1</span><br><span class="line">// duplicate 0x80</span><br><span class="line">DUP3</span><br><span class="line">// new free memory pointer as before</span><br><span class="line">ADD</span><br><span class="line">// swap 1st (0x120) item on the stack and 3rd (0x80)</span><br><span class="line">SWAP2</span><br><span class="line">// pop top item off stack (0x80)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0xa0)</span><br><span class="line">POP</span><br><span class="line">// Swap top 2 items 0x120 &amp; 0x05</span><br><span class="line">SWAP1</span><br><span class="line">// pop top item off stack (0x05)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0x120)</span><br><span class="line">POP</span><br><span class="line">// swap top 2 items 0x80 &amp; 0xb6 (jump location)</span><br><span class="line">SWAP1</span><br><span class="line">// simulating a JUMP remove the top item off stack with POP</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// Simulated jump location</span><br><span class="line">PUSH2 0xffff</span><br><span class="line">// Simulated jump location</span><br><span class="line">PUSH2 0xffff</span><br><span class="line">// simulating a JUMP, remove the top item off stack with POP</span><br><span class="line">POP</span><br></pre></td></tr></table></figure>

<p>现在内存已经被分配了，空闲内存指针也更新了，我们需要初始化变量a的内存空间。变量只是声明却没被赋值，会被初始化为0。</p>
<p>为此EVM使用CALLDATACOPY，有三个参数：</p>
<ul>
<li>memoryOffset (数据拷贝的目标地址)</li>
<li>calldataOffset (待拷贝数据在calldata里的偏移量)</li>
<li>size (需要复制的大小)</li>
</ul>
<p>在这个例子里，memoryOffset是变量 a 的内存位置0x80。calldataOffset是待复制数据在calldata中的起点，因为我们反正不想复制任何calldata，就用0值初始化。最后size就是0xa0(十进制160)。</p>
<p>我们可以看到内存已经扩展到288字节了，调用栈又拿到了a的内存位置，还有一个无关痛痒的JUMP地址。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F77921922-6699-4ef7-a248-5b96667ac1cc_1066x548.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F77921922-6699-4ef7-a248-5b96667ac1cc_1066x548.png" alt="img"></a></p>
<h3 id="变量-b-的内存分配和空闲内存指针更新-EVM-Playground-Lines-96-112"><a href="#变量-b-的内存分配和空闲内存指针更新-EVM-Playground-Lines-96-112" class="headerlink" title="变量 b 的内存分配和空闲内存指针更新 (EVM Playground Lines 96-112)"></a>变量 b 的内存分配和空闲内存指针更新 (EVM Playground Lines 96-112)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/////////////////////////////////////////////////////////////////</span><br><span class="line">// Memory Allocation Varibale “b” &amp; Free Memory Pointer Update //</span><br><span class="line">/////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// free memory pointer load in </span><br><span class="line">PUSH1 0x40</span><br><span class="line">MLOAD</span><br><span class="line">// duplicate free memory pointer (0x120)</span><br><span class="line">DUP1</span><br><span class="line">// 0x40 = 64 in decimal, 32 * 2 = 64 second array is length 2</span><br><span class="line">PUSH1 0x40</span><br><span class="line">// free memory pointer (0x120) + space for array (0x40) = new free memory pointer</span><br><span class="line">ADD</span><br><span class="line">// save new free memory pointer value at free memory location 0x40</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MSTORE</span><br></pre></td></tr></table></figure>

<p>和 a 一样，对<code>“bytes32[2] memory b”</code>也要做内存申请和更新空闲内存指针。空闲内存指针更新到0x160(即十进制的352 &#x3D; 288 + 2 * 32)。内存里显示空白内存指针已更新，栈上也有了变量 b 的内存地址0x120。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6d38d4d0-f02f-4f85-a16e-11a3687ae095_1066x610.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6d38d4d0-f02f-4f85-a16e-11a3687ae095_1066x610.png" alt="img"></a></p>
<h3 id="变量-b-的内存初始化-EVM-Playground-Lines-113-162"><a href="#变量-b-的内存初始化-EVM-Playground-Lines-113-162" class="headerlink" title="变量 b 的内存初始化 (EVM Playground Lines 113-162)"></a>变量 b 的内存初始化 (EVM Playground Lines 113-162)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">////////////////////////////////////////</span><br><span class="line">// Memory Initialisation Variable “b” //</span><br><span class="line">////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// duplicate 0x120 (memory start location for variable &quot;b&quot;)</span><br><span class="line">DUP1</span><br><span class="line">// 0x02 = 2 in decimal = array length</span><br><span class="line">PUSH1 0x02</span><br><span class="line">// swap top 2 items 0x02 &amp; 0x120</span><br><span class="line">SWAP1</span><br><span class="line">// 0x20 = 32 in decimal (array item size in bytes)</span><br><span class="line">PUSH1 0x20</span><br><span class="line">// duplicate 3rd item on the stack 0x02</span><br><span class="line">DUP3</span><br><span class="line">// 0x02 * 0x20 = 0x40 = 64 (amount of bytes in memory to initialise)</span><br><span class="line">MUL</span><br><span class="line">// duplicate 0x40 (free memory pointer location)</span><br><span class="line">DUP1</span><br><span class="line">// same as before 4 bytes for function signature 0x04</span><br><span class="line">CALLDATASIZE</span><br><span class="line">// duplicate 4th item on the stack = 0x120</span><br><span class="line">DUP4</span><br><span class="line">// 0x120 (byte offset in the memory where the result will be copied.), 0x04 (byte offset in the calldata to copy.), 0x40 (byte size to copy.)</span><br><span class="line">CALLDATACOPY</span><br><span class="line"></span><br><span class="line">// The remaining lines in this section manipulate the stack to ensure we have the memory location of variable &quot;a&quot; and removes any items that are no longer needed</span><br><span class="line"></span><br><span class="line">//duplicate the top of the stack 0x40</span><br><span class="line">DUP1</span><br><span class="line">// duplicate 3rd item on the stack 0x120</span><br><span class="line">DUP3</span><br><span class="line">// add together yields free memory pointer value</span><br><span class="line">ADD</span><br><span class="line">// swap 0x160 &amp; 0x120</span><br><span class="line">SWAP2</span><br><span class="line">// pop top item off stack (0x120)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0x40)</span><br><span class="line">POP</span><br><span class="line">// swap 0x160 &amp; 0x02</span><br><span class="line">SWAP1</span><br><span class="line">// pop top item off stack (0x02)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0x160)</span><br><span class="line">POP</span><br><span class="line">// jump location to top of the stack 0xbe</span><br><span class="line">SWAP1</span><br><span class="line">// simulate jump pop jump location off stack</span><br><span class="line">POP</span><br></pre></td></tr></table></figure>

<p>和变量 a 的初始化一样，现在内存已经扩展到352字节，栈里保存着两个变量的内存地址。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff45435da-8528-4e99-8a43-bab75decbf06_1066x630.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff45435da-8528-4e99-8a43-bab75decbf06_1066x630.png" alt="img"></a></p>
<h3 id="b-0-赋值-EVM-Playground-Lines-163-207"><a href="#b-0-赋值-EVM-Playground-Lines-163-207" class="headerlink" title="b[0]赋值 (EVM Playground Lines 163-207)"></a>b[0]赋值 (EVM Playground Lines 163-207)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//////////////////////////</span><br><span class="line">// Assign Value to b[0] //</span><br><span class="line">//////////////////////////</span><br><span class="line"></span><br><span class="line">// push 0x01, value to add b[0]</span><br><span class="line">PUSH1 0x01</span><br><span class="line">// push 0x00</span><br><span class="line">PUSH1 0x00</span><br><span class="line">// left shift operation no shift, first input is 0 </span><br><span class="line">SHL</span><br><span class="line">// duplicate 2nd item on stack (0x120)</span><br><span class="line">DUP2</span><br><span class="line">// push 0x00 = [0] where in the array should this item go</span><br><span class="line">PUSH1 0x00</span><br><span class="line">// push 0x20 = 64 bytes the length of the array </span><br><span class="line">PUSH1 0x02</span><br><span class="line">// duplicate 2nd item on stack (0x00)</span><br><span class="line">DUP2</span><br><span class="line">// 0x00 &lt; 0x20 =  true = 0x01 (check the user is not trying to store a value at a location that doesn&#x27;t exist in the array)</span><br><span class="line">LT</span><br><span class="line">// jump location</span><br><span class="line">PUSH2 0x00d7</span><br><span class="line">// 2 POPs since this is a JUMPI (checking if LT returned true or false)</span><br><span class="line">// simulate JUMPI </span><br><span class="line">POP</span><br><span class="line">// simulate JUMPI </span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// push 0x20 (32 bytes aray item size)</span><br><span class="line">PUSH1 0x20</span><br><span class="line">// 0x20 * 0x00 = 0x00 = 0 in decimal (array item size * index to determine byte offset)</span><br><span class="line">MUL</span><br><span class="line">// 0x00 + 0x120</span><br><span class="line">ADD</span><br><span class="line">// duplicate 2nd on stack 0x01 (value for b[0])</span><br><span class="line">DUP2</span><br><span class="line">// duplicate 2nd on stack 0x120 (memory location for b[])</span><br><span class="line">DUP2</span><br><span class="line">// store 0x01 at memory location 0x120</span><br><span class="line">MSTORE</span><br><span class="line">// clean up stack</span><br><span class="line">POP</span><br><span class="line">POP</span><br><span class="line">POP</span><br><span class="line">POP</span><br></pre></td></tr></table></figure>

<p>最后一步我们需要给数组 b 的索引0处赋值，代码显示b[0] &#x3D; 1。那么0x01压栈，紧接着一个左移opcode，但是参数是0，相当于没移。</p>
<p>接下来数组索引0也就是0x00会被压入栈中，然后检查这个值是否比数组长度0x02小，如果不是的话会跳到异常处理的部分。MUL和ADD可以根据数组的索引算出写入内存的位置，一个元素32，索引为0，则在0x00的偏移量开写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x20 (32 in decimal) * 0x00 (0 in decimal) = 0x00</span><br></pre></td></tr></table></figure>

<p>偏移量加上起始位置，最终算出来该值应该在0x120被写入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00 + 0x120 = 0x120 (288 in decimal)</span><br></pre></td></tr></table></figure>

<p>最后，我们把0x01写进0x120。</p>
<p>下图展示了这个函数执行完成后的状态，栈被弹空了。</p>
<p><em><strong>实际上在用remix中调用栈上还是会有一些条目，一个跳转地址和函数签名，但是与内存操作无关，就被EVM省略了</strong></em></p>
<p>我们的内存被更新成了b[0]&#x3D;1，在倒数第三行。你也可以验证一下数据位置是否正确，b[0]应该在0x120 - 0x13f (289-320字节)。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fa5516282-632f-4af3-8e0f-40b07497a9d7_1066x578.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fa5516282-632f-4af3-8e0f-40b07497a9d7_1066x578.png" alt="img"></a></p>
<p>成了！这里信息量很大但我们现在理解已经很深刻了，下次写代码的时候也会有不小的帮助！以前挨行跑opcode的时候经常看见内存不断弹出0x40，现在知道为什么了。</p>
<p>这个系列的下一篇，我们会<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?s=r">揭开存储插槽的神秘面纱</a>。</p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解EVM - Part3 - 存储区</title>
    <url>/2022/06/22/Digging-Deep-EVM-Part3/</url>
    <content><![CDATA[<p>原文链接：<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?s=">https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?s=</a><br>译者：<a href="alvan.coffe">Alvan’s Blog</a></p>
<p>这是“深入理解EVM”系列的第三篇文章，需要<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&s=r">第一篇</a> 和<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?s=r">第二篇</a>的前置知识，因此如果您没读过的话建议先读一下。在这一篇里，我们会仔细研究合约存储区是怎么工作的，提供一些有助于理解插槽包装(slot packing)的思维方式，如果对装填插槽很陌生也不必担心，插槽包装的知识对EVM的骇客们至关重要，你也可以在本文结束时深刻了解它。</p>
<p>如果你玩过<a href="https://ethernaut.openzeppelin.com/">Ethernaut Solidity Wargame Series</a> 或者其他Solidity的CTF赛事，就会知道装填插槽的知识经常是解决难题的关键。(译者注: CTF全称Capture The Flag，中文名夺旗赛，一般指网络安全领域的技术竞赛)。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>在<a href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/">“Program the Blockchain”</a> 里对合约存储基础知识有一个相当完整的概述，我将回顾一下这篇文章里的关键知识点，当然也很推荐看一下这个全文。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>我们先从合约存储的数据结构说起，这是我们理解其他知识的坚实基础。</p>
<p>合约存储就是一个简单的 k-v map结构。32字节的key，32字节的value。key有32字节让我们可以拿到0到(2^256)-1的key值。</p>
<p>所有的value都会初始化为0，0不会显式写入。还挺有道理的，可观测宇宙里也是有 2^256 个原子。没有计算机能存储这个多的数据。存储区 value 置 0 返还gas，因为节点不用存储这些数据了。</p>
<p>你可以把存储区视为一个宇宙级的大数组，二进制 0 对应的 key 代表数组的第 0 个元素，二进制1对应的 key 代表数组的第一个元素，以此类推。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F13728261-0af4-4581-b03f-04057bdbb5dc_744x370.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F13728261-0af4-4581-b03f-04057bdbb5dc_744x370.png" alt="img"></a></p>
<h2 id="定长变量"><a href="#定长变量" class="headerlink" title="定长变量"></a>定长变量</h2><p>声明为存储(storage)的的合约变量分为两种，定长变量和不定长变量。我们着重研究一下前者，看看EVM是怎么把定长便利那个装进32字节的插槽里的。关于不定长变量可以看一下<a href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/">“Program the Blockchain”</a> 这篇文章。</p>
<p>现在我们知道存储区是一个map，那么下一个问题就是怎么给key分配value。假设我们有以下代码。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F211a6f5d-9a81-41b9-9643-e31c141d0827_335x298.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F211a6f5d-9a81-41b9-9643-e31c141d0827_335x298.png" alt="img"></a></p>
<p>给定的变量都是定长的，EVM可以从 0 开始挨个装填，装完 0 装 1，装完 1 装 2，以此类推。排列顺序基于合约里变量声明的顺序，第一个被声明的变量会在0插槽。在这个例子里插槽0存储  value1，value2 是一个长度为 2 的数组，所以存在插槽1 和插槽2，value3 存储在插槽3，如下图所示：</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F46352903-1395-49d0-a3a8-36b1bf5a3000_744x288.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F46352903-1395-49d0-a3a8-36b1bf5a3000_744x288.png" alt="img"></a></p>
<p>现在我们看一个类似的合约，猜下是怎么存的。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F48a5cb06-c390-4b92-8a20-39053f40d54c_335x316.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F48a5cb06-c390-4b92-8a20-39053f40d54c_335x316.png" alt="img"></a>注意变量类型不是 uint256</p>
<p>根据上一个例子你可能猜测我们会占用 0 到 3 插槽，因为有4个变量。但其实这个例子只占用了插槽0。这是变量类型不同造成的，之前我们用的都是 uint256 类型也就是32字节，在这里我们用的是 uint32，uint64 和 uint128，分别代表4字节，8字节和16字节的数据。</p>
<p>这就是插槽包装一词的由来。Solidity编译器知道一个插槽能装 32字节的数据， uint32 value1 装填在插槽0里只占用了4字节，等读到下一个可以装填的变量时，就会装进这个插槽。</p>
<p>(译者注：不知道你记不记得上一篇文章里有一个无法写入的0值插槽，它和插槽0是两个不同的东西，前者英文写作 zero slot，后者是 slot[0]，具体可见官方文档)</p>
<p>根据上边的例子我们开始从插槽0开始装填：</p>
<ul>
<li>value1 装进插槽0，占用4字节</li>
<li>插槽0剩余28字节</li>
<li>value2长4字节，小于等于28，装进插槽0</li>
<li>插槽0剩余24字节</li>
<li>value3长8字节，小于等于24，装进插槽0</li>
<li>插槽0剩余16字节</li>
<li>value4长16字节，小于等于16，装进插槽0</li>
<li>插槽0剩余0字节</li>
</ul>
<blockquote>
<p><em>注意uint8是solidity的最小类型，因此包装不能小于1字节(8位)</em></p>
</blockquote>
<p>下图展示了插槽0里存放的共32字节的4个变量。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdeb707da-60db-465d-a7c2-e45befefe3ff_744x434.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdeb707da-60db-465d-a7c2-e45befefe3ff_744x434.png" alt="img"></a></p>
<h2 id="EVM-Storage-Opcodes"><a href="#EVM-Storage-Opcodes" class="headerlink" title="EVM Storage Opcodes"></a>EVM Storage Opcodes</h2><p>了解了存储区数据结构和插槽包装的原理只有我们看两个相关的opcode，SSTORE 和 SLOAD。</p>
<h3 id="SSTORE"><a href="#SSTORE" class="headerlink" title="SSTORE"></a>SSTORE</h3><p>SSTORE 从调用栈取两个值，一个是32字节的 key，一个是32字节的 value。然后把 value 存在 key 值对应的插槽上，可以在[这里](<a href="https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code=&#39;z1uFFv1">https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code=&#39;z1uFFv1</a> 0w<del>z2uy8965w’</del>\nz%2F%2F Example yv2 w<del>SSTORE</del>v<del>PUSHuy0xFFuvwyz</del>_)看到他是怎么工作的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Example 1</span><br><span class="line">PUSH2 0xFFFF</span><br><span class="line">PUSH1 0</span><br><span class="line">SSTORE</span><br><span class="line"></span><br><span class="line">//Example 2</span><br><span class="line">PUSH2 0xFF</span><br><span class="line">PUSH2 8965</span><br><span class="line">SSTORE</span><br></pre></td></tr></table></figure>

<h3 id="SLOAD"><a href="#SLOAD" class="headerlink" title="SLOAD"></a>SLOAD</h3><p>SLOAD 从调用栈拿32字节的 key 值，然后把 key 值插槽的 value 拿出来压到调用栈上，可以在[这里](<a href="https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code=&#39;wSet">https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code=&#39;wSet</a> up thrstatez46z0<del>SSTOREy1z0vy2z1v</del>‘<del>\nz</del>PUSH1 y~~wExamplrw%2F%2F v<del>SLOADre rvwyz</del>_)看到他是怎么工作的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Set up the state</span><br><span class="line">PUSH1 46</span><br><span class="line">PUSH1 0</span><br><span class="line">SSTORE</span><br><span class="line"></span><br><span class="line">// Example 1</span><br><span class="line">PUSH1 0</span><br><span class="line">SLOAD</span><br><span class="line"></span><br><span class="line">//Example 2</span><br><span class="line">PUSH1 1</span><br><span class="line">SLOAD</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时候你就要问了，如果 SSTORE 和 SLOAD 都是处理32字节的数据，那不足32字节被包装进插槽的怎么办呢？那上边的例子来说，我们 SLOAD 插槽0之后，拿到32字节数据，里边有 value1 到 value4 四个变量，EVM怎么知道要返回什么呢？SSTORE 也有同样的问题，如果我们每次都写32字节，那怎么确保 value2 不会覆盖 value1 呢，怎么确保 value3 不会覆盖 value2 呢？接下来我们将找出答案：</p>
<h2 id="存取被包装-slot-packing-的变量"><a href="#存取被包装-slot-packing-的变量" class="headerlink" title="存取被包装(slot packing)的变量"></a>存取被包装(slot packing)的变量</h2><p>下边是一个仿照上个例子的合约，加上了一个方法，功能是存储然后读一个值去做算术操作。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F53bfa82f-b889-40c8-a407-3157f2e31385_457x452.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F53bfa82f-b889-40c8-a407-3157f2e31385_457x452.png" alt="img"></a></p>
<p>这个store()函数将会执行上边那些我们有疑问的操作：在不覆盖原有数据的情况下，将多个变量写进同一插槽，以及从插槽的32字节数据中取出我们想要的那个变量。</p>
<p>让我们看一看执行结束后，插槽0的最终状态，牢记十六进制数被机器识别为二进制码，它会在slot packing中作为位运算的操作数。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3ce409fd-b942-42d7-b7ea-02c18c4a8993_782x338.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3ce409fd-b942-42d7-b7ea-02c18c4a8993_782x338.png" alt="img"></a></p>
<p>记下 0x115c 为十进制 444，0x14d 为十进制 333，0x16 为十进制 22，0x01为十进制 1，与代码里的赋值相符，一个插槽持有 4 个变量。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>Slot packing使用 AND，OR 和 NOT 三个位运算，对应 EVM 的 opcode 与之同名。让我们快速过一遍。</p>
<h4 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h4><p>下看下边的两个 8 位二进制数，AND 操作第一个数的第一位和第二个数的第一位，如果都是 1 的话结果的第一位就是 1 。否则为 0。之后算两个操作数的第二位，以此类推。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F50496d7f-3e74-404c-b71c-472cf2440c2c_466x302.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F50496d7f-3e74-404c-b71c-472cf2440c2c_466x302.png" alt="img"></a></p>
<h4 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h4><p>OR就是两个操作数中，每位只要有一个 1 值，结果的对应位就是 1，否则为 0。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F42a806e1-3da7-4a11-901d-47d40a85ba3f_466x302.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F42a806e1-3da7-4a11-901d-47d40a85ba3f_466x302.png" alt="img"></a></p>
<h4 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h4><p>NOT 有些不一样，因为他只有一个操作数，效果就是对着每一位取反。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fed511be0-14bd-4f0e-adf5-e464e8cd7b4d_466x276.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fed511be0-14bd-4f0e-adf5-e464e8cd7b4d_466x276.png" alt="img"></a></p>
<p>现在看看他们是怎么应用于上边solidity例子里的。</p>
<h3 id="插槽操作：存储包装变量SSTORE"><a href="#插槽操作：存储包装变量SSTORE" class="headerlink" title="插槽操作：存储包装变量SSTORE"></a>插槽操作：存储包装变量SSTORE</h3><p>看一下solidity代码第18行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value2 = 22;</span><br></pre></td></tr></table></figure>

<p>在这时 value1 已经存进插槽0了，现在我们需要pack一些额外数据放进这个插槽。value3 和 value4 存储的时候也是一样的逻辑。我们来看一下理论上是怎么做的，也会提供一个EVM playground强化理解。</p>
<p>我们从以下变量开始讲起</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F4fdcbc53-b6a6-4d10-892e-ff2d3b159f53_778x244.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F4fdcbc53-b6a6-4d10-892e-ff2d3b159f53_778x244.png" alt="img"></a></p>
<p>注意0xffffffff 是二进制 11111111111111111111111111111111。</p>
<p>EVM干的第一件事就是用 EXP ，输入一个基数一个指数返回计算结果。我们现在使用 0x100 作为基数，代表一个字节的偏移量，之后指数为 0x04，代表 value2 的起始位置。下图展示了这个返回值的作用：</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff33571de-7414-4e29-9681-d2f9f5693550_1058x284.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff33571de-7414-4e29-9681-d2f9f5693550_1058x284.png" alt="img"></a></p>
<p>我们得到了EXP函数的返回值，现在可以把0x16写在正确的位置上，即4字节的位置。<br>(译者注：0x100 的 0x04 次幂，算出来是2 ^ 8，也就是0x100000000，插槽从右往左装填，相当于从右到左偏移八位)</p>
<p>我们现在还不能写进去，因为已经存储的 value1 会被覆盖，这时候掩码就发挥作用了。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F71f004c0-6d1d-40b9-a83c-3355832e3138_1058x706.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F71f004c0-6d1d-40b9-a83c-3355832e3138_1058x706.png" alt="img"></a></p>
<p>上图展示了掩码是怎么发挥作用的，怎么拿数据可以把待写入那个区域单独无视，其他部分正常提取。在这个情况下 value2 想占用的区域已经都置零了，如果没置零，我们将看到数据被清除。</p>
<p>(译者注：掩码的原理很简单，就是用AND命令制造一个某区域为0，其它区域数值不变的方法，比如给定一个数 0x1010，我想把从左到右第三位隐藏，那么我可以制造一个数 0x1101，即待隐藏位置为 0 其它为 1，那么由于 0 和任何数and都是0，1 和任何数and结果都与该数一致，用0x1101 AND 0x1010，我们得到了一个0x1000，第三位被抹去了，其它位数不变。用在这里就是为了抹去对应位的原值)</p>
<p>这有另一个例子是我们把4个变量全部存进去的情况下把 value2 值从 22 改成 99。看到0x016 值被清除了。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F5c1522f7-9467-4116-9c3a-a076d0bc0fcd_1058x414.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F5c1522f7-9467-4116-9c3a-a076d0bc0fcd_1058x414.png" alt="img"></a></p>
<p>你可能正在想 OR 是怎么用上的，这张图会展示下一个步骤：</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fb9ff9609-0488-4684-848b-5d4245b0d966_1058x880.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fb9ff9609-0488-4684-848b-5d4245b0d966_1058x880.png" alt="img"></a></p>
<p>(译者注：就是把第一步计算的“只有 value2”的32字节数据与第二步计算的“隐藏了value2位置的32位数据”做OR操作，即可得到最终结果)</p>
<p>我们现在可以把包含 value1 和 value2 的 32字节数据写入插槽0了，他们都在正确的位置。</p>
<h3 id="插槽操作：取出被包装的变量SLOAD"><a href="#插槽操作：取出被包装的变量SLOAD" class="headerlink" title="插槽操作：取出被包装的变量SLOAD"></a>插槽操作：取出被包装的变量SLOAD</h3><p>关于提取我们看一下solidity带么的22行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint96 value5 = value3 + uint32(666)</span><br></pre></td></tr></table></figure>

<p>我们只关心 value3 是怎么拿出来的，对它的算术计算不感兴趣。下面就是取出 value3 需要的数据，跟上边的不太一样。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fc8dffd1d-bcd2-461d-90c7-97287d7f0d2e_1148x204.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fc8dffd1d-bcd2-461d-90c7-97287d7f0d2e_1148x204.png" alt="img"></a></p>
<p>经过了一些修改，他们将会用于检索。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff55711ab-e05f-46a3-9291-c472409a7276_1058x672.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff55711ab-e05f-46a3-9291-c472409a7276_1058x672.png" alt="img"></a></p>
<p>我们现在从插槽0 里提取出了 value3，0x14d也就是十进制 333，跟solidity里看到的一样。<br>(译者注：就是和存储反过来了，先取出slot，再根据除法把待取一直右移到插槽最低位，最后用掩码把其它数据匿藏)</p>
<p>再次使用掩码和位操作和以帮助我们从32字节的插槽里准确提取数据，现在它放在栈上，可以执行 “value3 + uint32(666)” 了。</p>
<h2 id="EVM-Playground"><a href="#EVM-Playground" class="headerlink" title="EVM Playground"></a>EVM Playground</h2><p>这是store()的所有opcode了，你可以把它放在 <a href="https://www.evm.codes/playground">EVM playground</a>里跑一跑交互一下，会有一个直观的感受，可以看到调用栈和合约存储在你一步一步执行的时候是怎么变化的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// --------------------------------</span><br><span class="line">// Solidity Line 17 - &quot;value1 = 1;&quot;</span><br><span class="line">// --------------------------------</span><br><span class="line"></span><br><span class="line">PUSH1 0x01</span><br><span class="line">PUSH1 0x00</span><br><span class="line">DUP1</span><br><span class="line">PUSH2 0x0100</span><br><span class="line">EXP</span><br><span class="line">DUP2</span><br><span class="line">SLOAD</span><br><span class="line">DUP2</span><br><span class="line">PUSH4 0xffffffff</span><br><span class="line">MUL</span><br><span class="line">NOT</span><br><span class="line">AND</span><br><span class="line">SWAP1</span><br><span class="line">DUP4</span><br><span class="line">PUSH4 0xffffffff</span><br><span class="line">AND</span><br><span class="line">MUL</span><br><span class="line">OR</span><br><span class="line">SWAP1</span><br><span class="line">SSTORE</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// ---------------------------------</span><br><span class="line">// Solidity Line 18 - &quot;value2 = 22;&quot;</span><br><span class="line">// ---------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUSH1 0x16 // value2 = 22 decimal = 0x16 in hex</span><br><span class="line"></span><br><span class="line">PUSH1 0x00 // slot 0 - storage location for &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">PUSH1 0x04 // 4 bytes in - start position for &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">PUSH2 0x0100 // 0x100 in hex = 256 in decimal, 256 bits in 1 byte </span><br><span class="line"></span><br><span class="line">EXP // exponent of 0x0100 &amp; 0x04 = 0x100000000       </span><br><span class="line">    </span><br><span class="line">DUP2 // duplicate 0x00 to top of stack</span><br><span class="line"></span><br><span class="line">SLOAD // load data at slot 0</span><br><span class="line"></span><br><span class="line">DUP2 // duplicate exponent of 0x0100 &amp; 0x04 = 0x100000000</span><br><span class="line"></span><br><span class="line">PUSH4 0xffffffff // bitmask 4 bytes length      </span><br><span class="line"></span><br><span class="line">MUL // multiply to get bitmask for the 8 bytes assigned to &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">NOT // NOT operation to get bitmask for all bytes except the 8 bytes assigned to &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">AND // AND of bitmask and slot 0 value to zero out values in the 8 bytes assigned to &quot;value2&quot; and retain all other values</span><br><span class="line"></span><br><span class="line">SWAP1 // bring 0x100000000 to top of the stack</span><br><span class="line"></span><br><span class="line">DUP4 // duplicate value2 value = 22 = 0x16</span><br><span class="line"></span><br><span class="line">PUSH4 0xffffffff // bitmask 4 bytes length </span><br><span class="line"></span><br><span class="line">AND // AND to ensure the value is no more than 4 bytes in length</span><br><span class="line"></span><br><span class="line">MUL // returns value2 at the correct position - 4 bytes in</span><br><span class="line"></span><br><span class="line">OR // OR with previous value and the value AND yielded on line 38 gives us the 32 bytes that need to be stored</span><br><span class="line"></span><br><span class="line">SWAP1 // slot 0 to top of the stack</span><br><span class="line"></span><br><span class="line">SSTORE // store the 32 byte value at slot 0</span><br><span class="line"></span><br><span class="line">POP // pop 0x16 off the stack</span><br><span class="line"></span><br><span class="line">// ----------------------------------</span><br><span class="line">// Solidity Line 19 - &quot;value3 = 333;&quot;</span><br><span class="line">// ----------------------------------</span><br><span class="line"></span><br><span class="line">PUSH2 0x014d</span><br><span class="line">PUSH1 0x00</span><br><span class="line">PUSH1 0x08</span><br><span class="line">PUSH2 0x0100</span><br><span class="line">EXP</span><br><span class="line">DUP2</span><br><span class="line">SLOAD</span><br><span class="line">DUP2</span><br><span class="line">PUSH8 0xffffffffffffffff</span><br><span class="line">MUL</span><br><span class="line">NOT</span><br><span class="line">AND</span><br><span class="line">SWAP1</span><br><span class="line">DUP4</span><br><span class="line">PUSH8 0xffffffffffffffff</span><br><span class="line">AND</span><br><span class="line">MUL</span><br><span class="line">OR</span><br><span class="line">SWAP1</span><br><span class="line">SSTORE</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// -----------------------------------</span><br><span class="line">// Solidity Line 20 - &quot;value4 = 4444;&quot;</span><br><span class="line">// -----------------------------------</span><br><span class="line"></span><br><span class="line">PUSH2 0x115c</span><br><span class="line">PUSH1 0x00</span><br><span class="line">PUSH1 0x10</span><br><span class="line">PUSH2 0x0100</span><br><span class="line">EXP</span><br><span class="line">DUP2</span><br><span class="line">SLOAD</span><br><span class="line">DUP2</span><br><span class="line">PUSH16 0xffffffffffffffffffffffffffffffff</span><br><span class="line">MUL</span><br><span class="line">NOT</span><br><span class="line">AND</span><br><span class="line">SWAP1</span><br><span class="line">DUP4</span><br><span class="line">PUSH16 0xffffffffffffffffffffffffffffffff</span><br><span class="line">AND</span><br><span class="line">MUL</span><br><span class="line">OR</span><br><span class="line">SWAP1</span><br><span class="line">SSTORE</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// ----------------------------------------------------------</span><br><span class="line">// Solidity Line 22 - &quot;uint64 value5 = value3 + uint32(666);&quot;</span><br><span class="line">// ----------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUSH1 0x00</span><br><span class="line"></span><br><span class="line">PUSH2 0x029a // uint32(666)</span><br><span class="line"></span><br><span class="line">PUSH4 0xffffffff // bitmask 4 bytes length</span><br><span class="line"></span><br><span class="line">AND // ensure uint32(666) does not exceed 8 bytes, trim if it does </span><br><span class="line"></span><br><span class="line">PUSH1 0x00 // slot 0 - location of value3</span><br><span class="line"></span><br><span class="line">PUSH1 0x08 // 8 bytes in - start position for &quot;value3&quot;</span><br><span class="line"></span><br><span class="line">SWAP1 // bring 0x00 to top of stack for SLOAD of slot 0</span><br><span class="line"></span><br><span class="line">SLOAD // load data at slot 0</span><br><span class="line"></span><br><span class="line">SWAP1 // bring 0x08 to top of stack for EXP</span><br><span class="line"></span><br><span class="line">PUSH2 0x0100 // 256 bits in 1 byte </span><br><span class="line"></span><br><span class="line">EXP // exponent of 0x0100 &amp; 0x08 = 0x10000000000000000</span><br><span class="line"></span><br><span class="line">SWAP1 // get slot 0 value to top of stack</span><br><span class="line"></span><br><span class="line">DIV // DIV of slot 0 value with 0x10000000000000000 remove bottom 8 bytes  </span><br><span class="line"></span><br><span class="line">PUSH8 0xffffffffffffffff // bitmask 8 bytes length </span><br><span class="line"></span><br><span class="line">AND // Zero out bytes outside of the 8 byte mask to return variable &quot;value3&quot;</span><br><span class="line"></span><br><span class="line">// To see the rest of the opcodes for this calculation recreate the contract in remix and enter debugging mode</span><br></pre></td></tr></table></figure>

<p>在我们文章里提到的两个部分(solidity18行和22行)写了注释，强烈建议把这份代码拍一遍加深理解。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F2f0f0e5d-fd10-41d6-ad63-aa2b719f98d5_1497x847.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F2f0f0e5d-fd10-41d6-ad63-aa2b719f98d5_1497x847.png" alt="img"></a></p>
<p>你现在应该对存储插槽的工作原理和EVM存取插槽内特定位置数据有一定了解了，尽管SLOAD 和 SSTORE 两个opcode只能操作32字节数据，但是我们可以使用掩码和位运算存取想要的数据。</p>
<p>在这个系列的<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-5a5?s=r">第四篇</a>，我们会学习Geth是怎么实现 SSTORE 和 SLOAD 操作码的。</p>
<p>希望对您有帮助！</p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解EVM - Part1 - 初识opcode</title>
    <url>/2022/06/17/Digging-Deep-EVM-Part1/</url>
    <content><![CDATA[<p>原文链接：<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?s=r">https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?s=r</a><br>译者博客:  <a href="alvan.coffee">Alvan的Blog</a></p>
<h3 id="Digging-deep-into-the-EVM-mechanics-during-contract-function-calls"><a href="#Digging-deep-into-the-EVM-mechanics-during-contract-function-calls" class="headerlink" title="Digging deep into the EVM mechanics during contract function calls"></a>Digging deep into the EVM mechanics during contract function calls</h3><p>第一性原理我们经常听说，就是着重于理解事物的基本概念从而更好地理解构建与其之上的组件。</p>
<p>在智能合约的世界里，EVM和它的算法与数据结构就是第一性原理，我们写的智能合约就是建立在其之上的组件。要想成为一个优秀的solidity开发，必须要对EVM有深刻了解。</p>
<p>这系列文章的第一要义就是深入理解EVM，构建成为“shadowy super coder”的基础知识。</p>
<h2 id="The-Basics-Solidity-→-Bytecode-→-Opcode"><a href="#The-Basics-Solidity-→-Bytecode-→-Opcode" class="headerlink" title="The Basics: Solidity → Bytecode → Opcode"></a>The Basics: Solidity → Bytecode → Opcode</h2><p>开始之前，本文嘉定读者是掌握了solidity的基本用法以及怎么部署到以太坊的，后边只会简单提到，如果你想复习一下这部分知识的话请看<a href="https://medium.com/@eiki1212/explaining-ethereum-contract-abi-evm-bytecode-6afa6e917c3b">这篇文章</a>。</p>
<p>solidity在部署到以太坊网络之前是需要被编译成字节码的，这些字节码又和一系列opcode匹配，这些opcode可以被EVM解释。</p>
<p>这一个系列会着眼于编译后字节码的特定部分并阐释他们的工作机制。在每一篇文章的结尾，你都可以对这些函数更清晰的认知。一路下来，你会学到有关EVM的许多概念。 </p>
<p>今天我们就看一个基础的solidity合约，从它的字节码&#x2F;opcode片段里解释一下EVM是怎么选择函数的。</p>
<p>solidity创造的运行时字节码对应着一整个合约，合约部署之后，其中可能存在多个可以被调用的函数。这里边一个基础问题是EVM怎么根据合约调用的函数知道执行哪些字节码。</p>
<h3 id="1-Storage-sol-Breakdown"><a href="#1-Storage-sol-Breakdown" class="headerlink" title="1_Storage.sol Breakdown"></a>1_Storage.sol Breakdown</h3><p>在demo里我们使用了一个Storage.sol的合约，这是remix生成的默认合约之一。</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3400bba6-f870-4b68-8ba8-118562b08aef_489x538.png" alt="img"></p>
<p>在这个合约里有两个函数，store(uint256) 和 retrieve() ，当函数调用的时候EVM就必须进行区分，下边就是此合约编译出的字节码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">608060405234801561001057600080fd5b50600436106100365760003560e01c80632e64cec11461003b5780636057361d14610059575b600080fd5b610043610075565b60405161005091906100d9565b60405180910390f35b610073600480360381019061006e919061009d565b61007e565b005b60008054905090565b8060008190555050565b60008135905061009781610103565b92915050565b6000602082840312156100b3576100b26100fe565b5b60006100c184828501610088565b91505092915050565b6100d3816100f4565b82525050565b60006020820190506100ee60008301846100ca565b92915050565b6000819050919050565b600080fd5b61010c816100f4565b811461011757600080fd5b5056fea2646970667358221220404e37f487a89a932dca5e77faaf6ca2de3b991f93d230604b1b8daaef64766264736f6c63430008070033 </span><br></pre></td></tr></table></figure>

<p>我们看一下下面的片段，这个片段就是函数选择器的逻辑，可以用ctrl + f 验证一下它是否在上述字节码中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60003560e01c80632e64cec11461003b5780636057361d1461005957</span><br></pre></td></tr></table></figure>

<p>这段字节码对应一系列的opcode与其输入值，你可以在<a href="https://www.ethervm.io/">这里</a>查看EVM的opcode列表。opcode的长度为1个字节也就是最多支持256种opcode，现在EVM已使用140种。</p>
<p>下边展示了字节码所对应的opcode，它们会在EVM的调用战(call stack)中逐条执行。比如你可以从上边的链接里找到字节码 60 代表着opcode PUSH1等等。在这篇文章的结尾，你会对它们有一个全面的认知。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60 00                       =   PUSH1 0x00 </span><br><span class="line">35                          =   CALLDATALOAD</span><br><span class="line">60 e0                       =   PUSH1 0xe0</span><br><span class="line">1c                          =   SHR</span><br><span class="line">80                          =   DUP1  </span><br><span class="line">63 2e64cec1                 =   PUSH4 0x2e64cec1</span><br><span class="line">14                          =   EQ</span><br><span class="line">61 003b                     =   PUSH2 0x003b</span><br><span class="line">57                          =   JUMPI</span><br><span class="line">80                          =   DUP1 </span><br><span class="line">63 6057361d                 =   PUSH4 0x6057361d     </span><br><span class="line">14                          =   EQ</span><br><span class="line">61 0059                     =   PUSH2 0x0059</span><br><span class="line">57                          =   JUMPI  </span><br></pre></td></tr></table></figure>

<h3 id="Smart-Contract-Function-Calls-amp-Calldata"><a href="#Smart-Contract-Function-Calls-amp-Calldata" class="headerlink" title="Smart Contract Function Calls &amp; Calldata"></a>Smart Contract Function Calls &amp; Calldata</h3><p>在深挖opcode之前需要快速过一遍我们究竟是怎么调用函数的。当我们调用一个合约函数时，需要包含有函数签名和所需参数的calldata。可以在solidity里完成:</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fa9957ce1-945b-4afa-a395-c9d2563d2094_1614x670.png" alt="img"></p>
<p>这里我们调用了合约的store函数，参数为10。我们使用abi.encodeWithSignature()获得calldata，emit会记录用于测试的calldata。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x6057361d000000000000000000000000000000000000000000000000000000000000000a</span><br></pre></td></tr></table></figure>

<p>上边就是abi.encodeWithSignature(“store(uint256)”, 10) 返回的字节码</p>
<p>之前提到了函数签名，现在我们再明确一下：</p>
<blockquote>
<p>函数签名就是函数规范化表示的Keccak Hash的前四个字节。</p>
</blockquote>
<p>函数标准化表示其实就是函数名+参数类型，就像 “store(uint256)” 和 “retrieve()”。你可以在<a href="https://emn178.github.io/online-tools/keccak_256.html">这里</a>验证一下store(uint256)的hash。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keccak256(“store(uint256)”) →  first 4 bytes = 6057361d</span><br><span class="line"></span><br><span class="line">keccak256(“retrieve()”) → first 4 bytes = 2e64cec1</span><br></pre></td></tr></table></figure>

<p>我们可以看到calldata有36个字节)，前四字节对应着我们刚刚计算出来的 store(uint256) 函数签名，剩下的32个字节对应着传入的uint256参数，一个16进制的a，也就是10进制的10.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6057361d = function signature (4 bytes)</span><br><span class="line"></span><br><span class="line">000000000000000000000000000000000000000000000000000000000000000a = uint256 input (32 bytes)</span><br></pre></td></tr></table></figure>

<p>我们获得了函数选择器 6057361d，你可以ctrf + f去opcode那一段确认一下。</p>
<h3 id="Opcodes-amp-The-Call-Stack"><a href="#Opcodes-amp-The-Call-Stack" class="headerlink" title="Opcodes &amp; The Call Stack"></a>Opcodes &amp; The Call Stack</h3><p>现在关于EVM的函数选择器的前置知识已经学完了，现在正式开始。首先要过一遍每一个opcode和它们对调用栈的操作。如果你不熟悉栈的话可以看一下这个<a href="https://www.youtube.com/watch?v=FNZ5o9S9prU">视频</a>。</p>
<p>PUSH1代表着把下一个字节(0x00也就是十进制0)的数据压入调用栈中，下一个opcode我们可以知道这么做的理由。</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F52e45eff-44b3-4028-a075-9f5591fd2e7e_900x151.png" alt="img"></p>
<p>接下来用CALLDATALOAD弹出栈顶元素stack(0)作为该命令的输入值。</p>
<p>这个opcode要把calldata载入调用栈，而输入值(也就是上边弹出的值)是偏移量(offset)，我们设为i。栈元素是32字节，而calldata是36字节，要压入的数据就是msg.data[i:i+32] (译者注:msg.data就是完整的calldata)，这既保证了只有32字节压栈，又允许我们访问calldata的任何一部分。</p>
<p>在这种情况下，我们并没有偏移量，因为offset &#x3D; 0x00，所以我们把calldata前32字节压栈。之前我们记录过整个的call data为“0x6057361d000000000000000000000000000000000000000000000000000000000000000a”。这意味着我们丢失了后边四个字节(“0000000a”)，如果我们想访问这个uint256变量则需要使用4字节的偏移量，忽视前四字节的函数签名，而得到完整的变量。</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe6f79343-c4c4-4ee6-a29f-f1923fea5b9e_901x150.png" alt="img"></p>
<p>这次又有一个PUSH1，它想压一个0xe0，也就是十进制224。224是这么来的: 函数签名有4字节或者说32位，载入的calldata有32字节256位，256 - 32 &#x3D; 224。</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F161dea9b-d35b-4eb1-aac5-7adecb6cc17d_901x149.png" alt="img"></p>
<p>下一步，SHR操作意味着右移一位，而栈顶弹出的224则是移位次数，栈的下一个元素0x6057361d0…0a便是执行移位操作的主题。现在我们可以在调用栈里看到4字节的函数选择器了。如果你不了解移位操作的话请看这个<a href="https://youtu.be/fDKUq38H2jk?t=176">视频</a>。</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F8db5bd19-2271-44b3-99ed-0eec2731be5c_893x144.png" alt="img"></p>
<p>下一个是DUP1，一个复制栈顶元素的简单操作。</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F40b72e9d-6e80-4232-9099-8718604542a8_896x146.png" alt="img"></p>
<p>PUSH4压入了 retrieve()的4字节函数签名(2e64cec1)，你可能疑惑evm是怎么知道这个值的，请记住字节码由solidity编译而来，它有函数名和参数类型等所有信息。</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F23dc9994-e360-4205-bf5d-af92aaba42e5_899x189.png" alt="img"></p>
<p>EQ 操作会弹出两个元素去判断是否相等，在这里0x2e64cec1 !&#x3D; 0x6057361d ，如果他们相等则压1，不相等则压0。</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F7cfc3f88-d5eb-4b03-b4c3-eb605bdeb283_895x144.png" alt="img"></p>
<p>PUSH2压入两字节的 0x003b 也就是十进制59。</p>
<p>调用栈有一个称为程序计数器的东西，它会确认字节码下一个要执行的指令在哪里，现在我们设置59是因为这是 retrieve() 函数的起始位置是59。(看下边EVM Playground 部分可以清楚这里具体是怎么实现的)。你可以看到程序字节码定位方式类似solidity代码行数，如果这个函数在59行声明，你可以使用行数来告诉机器怎么找到这个函数。</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F67596d4e-054d-4cd7-b516-64b4789ee01f_900x190.png" alt="img"></p>
<p>JUMPI 表示 “jump if” ，它会弹出两个值作为参数，59表示跳转地址而第二个元素作为布尔值代表是否跳转。</p>
<p>如果真值为true，程序计数器将更新然后执行跳转到指定位置，而在我们这个例子里真值为false，程序计数器并没有改变，程序继续顺序执行。</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1357763b-4150-4e14-8a8c-583ee74572aa_896x146.png" alt="img"></p>
<p>再次DUP1</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F40b72e9d-6e80-4232-9099-8718604542a8_896x146.png" alt="img"></p>
<p>PUSH4把store(uint256) (0x6057361d)压栈</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff937657d-dbb3-4133-95bb-1b3f5b8117cd_897x188.png" alt="img"></p>
<p>EQ判断，此次为真</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9c0617f7-2181-427e-9dca-917be7847f0a_898x145.png" alt="img"></p>
<p>PUSH2把 store(uint256) 的定位0x0059也就是89压栈</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F44dea0e0-9e0c-4459-bd1e-4af814c89203_898x186.png" alt="img"></p>
<p>JUMPI，这次执行跳转了，程序计数器更新为89然后到字节码的其他部分运行去了。在目的地会有一个JUMPDEST，如果目的地没有这个opcode，跳转将会失败。( 译者注: 我们可以在两个函数跳转的目的地可以找到JUMPDEST的字节码 5b )</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f3a7f3c-a5f6-4e29-888f-60708e8863dc_896x146.png" alt="img"></p>
<p>我们可以到store(uint156)的字节码处依照此法继续执行了。虽然这个合约只有2个函数，但是原理和20+函数的合约是一样的。你现在知道EVM如何基于函数调用找到函数的字节码了，这其实就是对合约里所有函数的位址进行if-else判断实现的。</p>
<h3 id="EVM-Playground"><a href="#EVM-Playground" class="headerlink" title="EVM Playground"></a>EVM Playground</h3><p>我强烈建议大家看看<a href="https://www.evm.codes/playground]">这个</a>,这是一个EVM运行环境，你可以设置字节码然后在上边执行。在这里可以看到调用栈的变化，我也添加了JUMPDEST，所以你也可以看到JUMPI后发生了什么</p>
<p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F86591a6b-ee71-4590-8462-4ebb38f5cb80_1503x887.png" alt="img"></p>
<p>这个EVM运行环境也可以帮你理解程序计数器，在这份代码里，可以看到每个命令的注释，其偏移量代表程序计数器标记的位置。</p>
<p>你也可以看到Run按钮左边的calldata输入，去试试把它改成retrieve()  0x2e64cec1看看有什么变化吧！只需要点击Run然后step into按钮(就是那个弯箭头)，一步一步运行opcode。</p>
<p>本系列下一节我们会研究一下内存 <a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?s=r">EVM Deep Dives - Part 2</a>。</p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>Alpaca文档翻译</title>
    <url>/2022/06/13/Alpaca-docs/</url>
    <content><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Alpaca Finance是一个借贷协议，但它和Compound，Aave等单纯等待别人从池子里借款从而分红利息的项目不一样，在这里你不仅可以加上杠杆，还可以主动选择一些心仪的流动性挖矿项目并质押进去，吃到多次利润。</p>
<p>Alpaca Leverage Farming 主要有四个组成部分<br>    1.Vault<br>    2.Worker<br>    3.Strategy<br>    4.Fairlaunch(此模块另行介绍)</p>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><ul>
<li>前端(Frontend) - Alpaca 前端接口</li>
<li>清算机器人(Liquidator) - 观察仓位状态，一旦出现资不抵债就进行清算的机器人</li>
<li>复投机器人(Reinvestor) - 自动收获利润又复投的机器人</li>
</ul>
<p><img src="https://alpaca-doc.s3.ap-southeast-1.amazonaws.com/lyf/Export-3aa4ff3c-20f2-4868-95ee-96a4da364889/Contract%20Documentation%204c48a0c0db7442c6aa0268dd110e6b80/Screen_Shot_2564-09-29_at_12.03.52.png"></p>
<h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><p>顾名思义，这个合约用处是存放借款者的抵押物。作为在此时贡献资金池使用率的回报，借款者还可以向Vault申请资金。一个底层资产对应一个Vault合约。</p>
<h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>worker是一个管理仓位使用方法的合约，使用方法包括但不限于<br>在一个DEX里开启一个流动性挖矿的仓位<br>平掉这个仓位<br>调节这个仓位<br>每一个worker都对应特定的一些代币和一个特定的DEX，不同的ERC20代币&#x2F;DEX会使用不同的worker。</p>
<h2 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h2><p>strategy合约是具体操作DEX的合约，每次只处理一个特定场景。可以对动态指定的不同的token做出童谣的DEX操作。</p>
<h2 id="FairLaunch"><a href="#FairLaunch" class="headerlink" title="FairLaunch"></a>FairLaunch</h2><p>这是Alpaca的激励组件，可以接收ERC20然后给各个token池生成Alpaca代币，每个池子的发放量存在差异</p>
<h2 id="Contract-Document"><a href="#Contract-Document" class="headerlink" title="Contract Document"></a>Contract Document</h2><p>[Vault Contract](#Vault Contract)<br>[Worker Contract](#Worker Contract)<br>[Strategy Contract](#Strategy Contract)</p>
<h2 id="DEX-Integration"><a href="#DEX-Integration" class="headerlink" title="DEX Integration"></a>DEX Integration</h2><p>尽管Alpaca集成了不少不同的DEX，他们之间也在细节上有差别，但是大部分DEX都是基于uniswapV2的机制，在这版文档里我们只讨论与PancakeSwap对接的Worker和Strategy。即以下具体实现：</p>
<h3 id="Worker-1"><a href="#Worker-1" class="headerlink" title="Worker"></a>Worker</h3><p>PancakeSwap Worker</p>
<h3 id="Strategy-1"><a href="#Strategy-1" class="headerlink" title="Strategy"></a>Strategy</h3><p>PancakeswapV2RestrictedStrategyAddBaseTokenOnly Strategy<br>PancakeswapV2RestrictedStrategyAddTwoSidesOptimal Strategy<br>PancakeswapV2RestrictedStrategyLiquidate Strategy<br>PancakeswapV2RestrictedStrategyPartialCloseLiquidateStrategy<br>PancakeswapV2RestrictedStrategyPartialCloseMinimizeTrading Strategy<br>PancakeswapV2RestrictedStrategyWithdrawMinimizeTrading Strategy</p>
<h1 id="Vault-Contract"><a href="#Vault-Contract" class="headerlink" title="Vault Contract"></a>Vault Contract</h1><p><a name="Vault Contract"></a></p>
<p><a href="https://github.com/alpaca-finance/bsc-alpaca-contract/blob/main/contracts/6/protocol/Vault.sol">合约源码</a></p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Alpaca Finance里最重要的一个操作是通过vaults达成的，注意是vaults而非vault，vault被设计成连接存款者和借款者的中间体，存款者把资产储存进vault，借款者可以借出来一些用于流动性挖矿。<br>存储token的同时，vault会给用户ibToken，用户可以用这个在Alpaca Finance中进行更多操作，比如获得FairLaunch里的Alpaca激励，获得合作Token激励，以后还有更多。<br>借出token的同时，用户也可以获得debtToken，这也可以自动获得FairLuanch给的激励。</p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>Vault会给用户分配ibToken，用来标记用户在此vault里所占的份额(share)。随着时间推移，利息会进入份额，1份份额(share)的实际价值会增加。</li>
<li>当用户开仓时，他们先需要在vault里放质押物。这使得vault的债务价值(debt value)根据借款量增加。</li>
<li>一旦vault收获借款人的利息，vault的债务价值(debt value)会随着利息增加。这意味着随着时间推移，取出资产需要用到的量要比存款时更大。</li>
<li>当用户平仓时，初始抵押品债务会从总债务中去除，流动性挖矿的利息会完整地还给lender。</li>
<li>部分利息会被项目组留下，放在保留金池子里。</li>
<li>由于用户是在不同的时间存款的，我们要用债务份额价值(debt share value)保持记录用户从哪里进入vault。</li>
<li>债务份额(debt share)也被表示成vault铸造的生息token。</li>
<li>债务份额的计算方法：$\frac{DebtValue}{TotalDebtValue} \times ExistingDebtShare$</li>
</ul>
<h2 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Position &#123;</span><br><span class="line">    address worker;</span><br><span class="line">    address owner;</span><br><span class="line">    uint256 debtShare;</span><br><span class="line">  &#125;</span><br><span class="line">mapping(uint256 =&gt; Position) public positions;</span><br></pre></td></tr></table></figure>

<h2 id="Main-Function"><a href="#Main-Function" class="headerlink" title="Main Function"></a>Main Function</h2><p>Vault 主要业务逻辑有：<br>1.质押token获得ibToken (deposit)<br>2.赎回token燃烧ibToken (withdraw)<br>3.执行借贷+DEX流动性挖矿操作，调用worker.work，根据Position里worker的不同具体执行逻辑也不一样 (work)<br>4.清算，调用worker.liquidate，根据Position里worker的不同具体执行逻辑也不一样 (kill)</p>
<h1 id="Worker-Contract"><a href="#Worker-Contract" class="headerlink" title="Worker Contract"></a>Worker Contract</h1><p><a name="Worker Contract"></a></p>
<p><a href="https://github.com/alpaca-finance/bsc-alpaca-contract/blob/main/contracts/6/protocol/interfaces/IWorker02.sol">源码地址</a></p>
<h2 id="BackGround"><a href="#BackGround" class="headerlink" title="BackGround"></a>BackGround</h2><p>borrowers从vault申请款项唯一的办法就是从vault借出钱来做一些操作，特别是加杠杆的流动性挖矿。<br>每一个worker根据配置比如其连接的DEX和LP token pair 来进行不一样的操作，但是所有的Worker共用一个接口。<br>然而worker并不一定要做流动性挖矿，也可能就只是做一些简单的操作，比如Syrup Pool。<br>这部分我们只讲一下所有worker共通的Interface。</p>
<h2 id="Abstract-1"><a href="#Abstract-1" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>在整个系统里有多个worker</li>
<li>一个worker可以根据实际情况使用不同的strategy</li>
<li>worker会把特定的token对当成整体处理，即使他们在不同的仓里</li>
<li>worker和底层资产服务强关联，比如Pancake的BNB-BUSD worker处理不了Wault的BNB-BUSD</li>
<li>Base token是ERC20标准，是worker的主要资产，通常与借款，本金挂钩。</li>
<li>Farm token是ERC20标准，与base token结对可以给DEX提供流动性</li>
<li>worker把Fram token和Base token成对处理，如果我们需要将现在的farm token作为base token就需要另一个worker，反之亦然。因为在DEX中，Pancake的BNB-BUSD 也与 Pancake的BUSD- BNB不一样。</li>
<li>Worker Config作为一个分离出来的合约，存放着worker们的配置信息</li>
</ul>
<p>worker可以被两种角色调用：<br>1.Operator: 大多数情况是一个Vault合约<br>2.Reinvestor: 白名单EOA，取出LP收益再复投</p>
<h2 id="Main-Function-1"><a href="#Main-Function-1" class="headerlink" title="Main Function"></a>Main Function</h2><p>1.利息复投(_reinvest)<br>2.调用Strategy的excute方法，并将返回的LP token质押，根据Strategy种类不同具体实现不一样 (work)<br>3.计算某个position换算成baseToken的价值，用来做清算判断 (health)</p>
<h1 id="Strategy-Contract"><a href="#Strategy-Contract" class="headerlink" title="Strategy Contract"></a>Strategy Contract</h1><p><a name="Strategy Contract"></a></p>
<p><a href="https://github.com/alpaca-finance/bsc-alpaca-contract/blob/main/contracts/6/protocol/interfaces/IStrategy.sol">合约源码</a></p>
<h2 id="Background-1"><a href="#Background-1" class="headerlink" title="Background"></a>Background</h2><p>顾名思义，这类合约只做一件事，那就是制定交易策略，根据DEX，token和需求不同分配不同的Strategy。这一节我们详细介绍策略逻辑和公式。值得注意的是，这个合约是一个耦合度极低的合约，只负责把传给该合约的资产在DEX中操作，再转账，几乎没有存储任何信息，也就是不参与借贷相关的任何逻辑。借贷&#x2F;还账的逻辑应该在它的上层实现。</p>
<h2 id="Abstract-2"><a href="#Abstract-2" class="headerlink" title="Abstract"></a>Abstract</h2><p>根据用户的操作，前端会提供一个strategy，比如一个用户想借BUSD在Pancake开一个BUSD- USDT的仓，前端会用PancakeswapV2RestrictedStrategyAddBaseTokenOnly(一种Strategy合约)调用Vault.work，这样Vault将会调用USDT- BUSD PancakeSwap 的worker。worker随后调用PancakeswapV2RestrictedStrategyAddBaseTokenOnly.</p>
<h2 id="Main-Function-2"><a href="#Main-Function-2" class="headerlink" title="Main Function"></a>Main Function</h2><p>有六种Strategy都只有一个主要方法,excute：</p>
<h3 id="AddBaseTokenOnly"><a href="#AddBaseTokenOnly" class="headerlink" title="AddBaseTokenOnly:"></a>AddBaseTokenOnly:</h3><p>提供base token，根据最佳方案兑换farming token，再提供流动性拿LP，推导过程：<br>balance为托管处理的baseToken总量，aIn为swap为farming token的base token，rIn，rOut是池子里的量</p>
<p>$\begin{cases}<br>rIn\times rOut &#x3D; (rIn + aIn)\times(rOut - aOut)\<br>\frac{rIn}{rOut} &#x3D; \frac{balance - aIn}{ aOut }\<br>\end{cases}$</p>
<p>得出$aIn^{2} + 2rIn\times aIn - rIn\times balance &#x3D; 0$，即$aIn&#x3D;\frac{\sqrt{rIn\times (4balance + 4rIn)}-2rIn}{2}$<br>与代码吻合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 aIn = AlpacaMath.sqrt(rIn.mul(balance.mul(399000000).add(rIn.mul(399000625)))).sub(rIn.mul(19975)) / 19950;</span><br></pre></td></tr></table></figure>

<h3 id="AddTwoSideOptimal"><a href="#AddTwoSideOptimal" class="headerlink" title="AddTwoSideOptimal"></a>AddTwoSideOptimal</h3><p>同时提供base token和farming token，合约转换成正好的比例提供流动性，推导过程:<br>bIn,bOut是用户提供的两种token量，aIn是打算换成另一种的多余Token量，aOut是换出的token量，<br>$\begin{cases}<br>rIn\times rOut &#x3D; (rIn + aIn)\times(rOut - aOut)\<br>\frac{rIn + bIn }{rOut - bOut} &#x3D; \frac{bIn-aIn}{bOut+aOut}\<br>\end{cases}$</p>
<p>得出$aIn^{2} + 2rIn\times aIn + \frac {rIn\times bOut - rOut \times bIn}{rOut+bOut} \times rIn &#x3D; 0$<br>即$aIn &#x3D; \frac{\sqrt{4rIn^{2}-4\times (\frac {rIn\times bOut - rOut \times bIn}{rOut+bOut} \times rIn)}-2rIn}{2}$<br>与代码吻合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// @dev Compute optimal deposit amount helper</span><br><span class="line">  /// @param amtA amount of token A desired to deposit</span><br><span class="line">  /// @param amtB amonut of token B desired to deposit</span><br><span class="line">  /// @param resA amount of token A in reserve</span><br><span class="line">  /// @param resB amount of token B in reserve</span><br><span class="line">  function _optimalDepositA(</span><br><span class="line">    uint256 amtA,</span><br><span class="line">    uint256 amtB,</span><br><span class="line">    uint256 resA,</span><br><span class="line">    uint256 resB</span><br><span class="line">  ) internal pure returns (uint256) &#123;</span><br><span class="line">    require(amtA.mul(resB) &gt;= amtB.mul(resA), &quot;Reversed&quot;);</span><br><span class="line"></span><br><span class="line">    uint256 a = 9975;</span><br><span class="line">    uint256 b = uint256(19975).mul(resA);</span><br><span class="line">    uint256 _c = (amtA.mul(resB)).sub(amtB.mul(resA));</span><br><span class="line">    uint256 c = _c.mul(10000).div(amtB.add(resB)).mul(resA);</span><br><span class="line"></span><br><span class="line">    uint256 d = a.mul(c).mul(4);</span><br><span class="line">    uint256 e = AlpacaMath.sqrt(b.mul(b).add(d));</span><br><span class="line"></span><br><span class="line">    uint256 numerator = e.sub(b);</span><br><span class="line">    uint256 denominator = a.mul(2);</span><br><span class="line"></span><br><span class="line">    return numerator.div(denominator);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Liquidate"><a href="#Liquidate" class="headerlink" title="Liquidate"></a>Liquidate</h3><p>提供LPToken，取消所有流动性，之后所有farming token 兑换成base token 返还给用户。</p>
<h3 id="PartialCloseLiquidate"><a href="#PartialCloseLiquidate" class="headerlink" title="PartialCloseLiquidate"></a>PartialCloseLiquidate</h3><p>前面和Liquidate一样，也是把一定量的LP取消流动性，再全兑成base token提出来，最后留下一部分baseToken(数目是入参，一般做平账用，由合约传入)，剩下的返还给用户。</p>
<h3 id="PartialCloseMinimizeTrading"><a href="#PartialCloseMinimizeTrading" class="headerlink" title="PartialCloseMinimizeTrading"></a>PartialCloseMinimizeTrading</h3><p>提供一定量LPToken，取消流动性，返还base token和farming token，如果base token不够lessDebt值(数目是入参，一般做平账用，由合约传入)，用farming token兑换至足额，并将base token和剩余的farming token返还。</p>
<h3 id="WithdrawMinimizeTrading"><a href="#WithdrawMinimizeTrading" class="headerlink" title="WithdrawMinimizeTrading"></a>WithdrawMinimizeTrading</h3><p>把所有的LPToken取消流动性,返还base token和farming token，如果base token不够lessDebt值(数目是入参，一般做平账用，由合约传入)，用farming token兑换至足额，并将base token和剩余的farming token返还。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Alpaca小弟也是最近刚刚接触，如果有前辈研究过这个项目还请指路一下更多的资料，谢谢大家了。</p>
]]></content>
      <categories>
        <category>DeFi</category>
      </categories>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>AAVE v3 技术说明</title>
    <url>/2022/07/09/aave-v3-techpaper/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>2020年Aave协议于DeFi生态横空出世，前端开源并托管在IPFS上，在Aave治理模式的控制下，现在已经成为了最大的DeFi协议之一，巅峰流动性达到300亿美金。Aave的的很多关键feature(比如aToken，可选稳定利率与可变利率，信贷授权等等)都成为了行业标准，成为了DeFi协议的基础设施。但是跟所有的技术一样，Aave协议也会随着持续的研究、市场数据分析和社区反馈在一些方面进行迭代升级。</p>
<p>这次的提升在以下四个领域：</p>
<ol>
<li>资本效率</li>
<li>协议安全</li>
<li>去中心化</li>
<li>用户体验</li>
</ol>
<p>Aave V3的设计实现了上述四类增强，改善了用户体验，在不牺牲安全性的前提下提高了资本效率。</p>
<p>在介绍V3新特性之前，我们在下一节中介绍一下这些四方面需要改进的原因。</p>
<h3 id="1-1-资本效率"><a href="#1-1-资本效率" class="headerlink" title="1.1 资本效率"></a>1.1 资本效率</h3><p><strong>为流动性提供者创造更多收益</strong>      Aave协议在多个网络上的总流动性已经接近200亿美元，其中大多数都躺在合约里不动，仅仅从收到借款收益。尽管这笔收益稳定安逸，但是它完全可以给用户提供新的功能，在不增加风险的同时重新利用起来。(这并不包括把资金注入其它协议运作去流动性挖矿– 这会造成很大的风险，也不适合作为DeFi协议layer 0的Aave)</p>
<p><strong>优化借款能力</strong>    在以往的迭代中，由于在资产池模型中任何质押物都可以用来借入资产，借款人面临着最大化借款能力的挑战。也正因如此，借款交易的风险参数被设定的相当保守。</p>
<p><strong>低效的底层网络</strong>  Aave上的大多数资产都放在以太坊L1网络上。这个饱和的网络导致交易费比较高，也是用户的痛点。网络的低效率也会放映在预言机在短时间内提交准确价格的能力上。</p>
<p><strong>聚合流动性方法</strong>  在Aave协议里，用户的总质押量是所有质押物换算成某种基础货币(通常是eth)的量，总抵押量被用来计算平均借贷能力，即每种资产的借贷能力的加权平均值。总质押量和总借款量都是波动的，因此风控参数设置的比较保守。这在很多情况下限制了借款者的借贷能力，比如一个人质押稳定币去借稳定币，无论是借款还是质押的波动都是很小的，它理应有更强的担保能力。</p>
<p><strong>降低流动性隔离</strong>     新的流动性协议寻求提高担保能力，同时通过启用隔离的质押池或交易对来降低风险。尽管这会提高某些资产的担保能力，这实际上会使流动性隔离增加(流动性提供者必须要质押资产到不同池子&#x2F;交易对里，才能满足其风险策略)和用户体验的问题(借款人可能被迫将抵押品分配到不同的池&#x2F;对，才能借到他们需要的东西)。第二节会详细说明闲的的处理方案和提升。</p>
<h3 id="1-2-协议安全"><a href="#1-2-协议安全" class="headerlink" title="1.2 协议安全"></a>1.2 协议安全</h3><p>风险管理是流动性协议的头等大事，它要降低智能合约风险和流动性风险。对于管理智能合约风险来说，代码review和每次代码更新、治理提案的审计都是必要的。这是一个链下&#x2F;协调的问题，管理这种风险涉及到代码更新时的“mission-critical(关键业务)”文化。管理流动性风险更细致，包括市场调研，调整配置参数，以及社区对资产上市建议进行适当的尽职调查(Aave社区开发并维护了Aave风险框架)。</p>
<p>不幸的是，当前Aave协议迭代中的风险配置有限。尽管可以随时调整借贷能力(LTV)和维持保证金(清算阈值)，但如果增加对特定可能的打击(如无限铸币或预言机操纵)的防御措施，协议也会更加受益。</p>
<h3 id="1-3-去中心化"><a href="#1-3-去中心化" class="headerlink" title="1.3 去中心化"></a>1.3 去中心化</h3><p>协议被AAVE持有者(“Aave governance”)控制，是完全去中心化的，他们在协议配置上充当守门员的角色(比如加入新资产)，尽管这对保证协议安全很重要，但这希望往增加新资产的团队和项目来说是一种限制。</p>
<h3 id="1-4-用户体验"><a href="#1-4-用户体验" class="headerlink" title="1.4 用户体验"></a>1.4 用户体验</h3><p>在多链世界里，允许流动性在不同链上无缝流动越来越重要了。尽管现在Aave协议也部署在过个网络里，但是用户还是不能从一个Aave到另一个网络的Aave传递流动性。</p>
<h2 id="2-目前的解决方案"><a href="#2-目前的解决方案" class="headerlink" title="2.目前的解决方案"></a>2.目前的解决方案</h2><p>现在的某些流动性协议使用一些替代方案尤其是隔离交易对和隔离流动性池来解决这些问题。这些解决方案都寻求解决加入新资产时的权限问题和与之而来的风险，尽管他们的方法很有效果，但也反衬出了Aave V优化这些模型带来的优越性。</p>
<h3 id="2-1-隔离交易对"><a href="#2-1-隔离交易对" class="headerlink" title="2.1 隔离交易对"></a>2.1 隔离交易对</h3><p>这种方案通常被称为”隔离对”，因为借款者只能通过质押某种特定资产才能借到对应的某种资产，跟Aave V2的聚合池方案相比有以下一些优点：</p>
<p><em>降低gas费</em>   通常情况下，隔离对方案因为不需要每次遍历所有资产，状态管理变少，导致了gas费降低</p>
<p><em>对新增资产限制降低</em>  只要风险系数调高任何资产都可以添加</p>
<p>然而这种设计对协议的可扩展性有影响。</p>
<p><strong>流动性的极端隔离</strong>  现在流动性被每种质押资产分隔开了，这意味着质押这需要把资产拆开分配到不同池子才能谋求最大收益。虽然这可以通过上层协议去聚合，但是也会降低用户对风险配置微调的能力，丧失了一部分优势。这也意味着每加入一个新交易对，都需要给它建立一次流动性，才能让用户借到这个资产。</p>
<p><strong>借款者糟糕的体验</strong> 在Aave协议里，借出资产可以简单理解为质押 + 借款，用户用起来很简单：只要质押量够，借款人可以直接接触任何资产，只需要管理一个状态(资债情况)。但是在隔离交易对方案里，如果借款人想借多种资产，它必须和很多交易对交互，甚至有时候只借一种资产也是这样，结果就是协议需要同时维护很多状态。这当然也可以通过上层协议去自动聚合来缓解，但是也降低了这种解决方案的优势(gas费)。流动性隔离通常也意味着更高的借款利率。</p>
<p><strong>倾向于高风险资产</strong>  一般而言，与较安全的资产相比，使用高风险资产作为抵押品的借款人(在其他流动性协议中)愿意支付更高的价格。这样的用户行为可能会允许某些潜在的攻击，新增某种没有债务上限的资产。 例如，用户可能会把稳定币冲进一个新创建的不稳定的池子来借出这个资产，这增加了对质押者的吸引力。</p>
<h3 id="2-2-隔离流动性池"><a href="#2-2-隔离流动性池" class="headerlink" title="2.2 隔离流动性池"></a>2.2 隔离流动性池</h3><p>隔离流动性池的架构本质是Aave模式和隔离交易对模式的混合体，例如使用特定资产和自定义风险管理配置实例化独立市场的无权限协议。这种方法类似于Aave在2020年开创的以Uniswap V1 LP资产为抵押的首个Uniswap池。拥有多个市场让用户能够在资产集群中分散风险，减少对潜在投资失败的影响，而不牺牲用户体验，并在流动性隔离方面做出一些妥协。</p>
<p>鉴于其独特的架构，也会和隔离交易对一样产生一些问题。尽管没有那么严重，流动性隔离仍然很重要——许多资金池难以吸引流动性。TVL通常也倾向于高风险资产。</p>
<h2 id="3-Aave-V3-概述"><a href="#3-Aave-V3-概述" class="headerlink" title="3.Aave V3 概述"></a>3.Aave V3 概述</h2><p>Aave V3脱胎于对协议与其生态演化的分析，特性的增强可以引起用户和开发者的创新浪潮。Aave V3在上述四个方面都做了改进，同时提供新的方法增强rollup能力和生态在L1网络中的竞争力。</p>
<h3 id="3-1-资本效率和用户体验的提高"><a href="#3-1-资本效率和用户体验的提高" class="headerlink" title="3.1 资本效率和用户体验的提高"></a>3.1 资本效率和用户体验的提高</h3><p><strong>传送门</strong>  传送门代表着一系列核心特性，他们可以允许Aave的资产在不同的网络中无缝流通，如果站在顶层设计来看的话原理很简单：aToken在源网络burn掉，然后在目标链上mint。这提供了一种以延迟方式提供资产的方法，其中底层的加密资产在通过规范链桥后被提供给Aave协议。关于设计的更多细节可以在4.5节中看到。</p>
<p><strong>E-Model</strong>  高效模式(High Efficiency Mode, E-Model)允许借款人从他们的质押物中提取最高的借贷能力。现在可以对资产进行分类，每个类别都有以下风险管理参数:</p>
<ul>
<li>LTV(其实就是借款能力，有些合约称为质押系数)</li>
<li>清算阈值</li>
<li>清算激励系数</li>
<li>定制价格预言机(可选)</li>
</ul>
<p>E-Mode允许借款人限制自己只借入属于某一类的资产(比如稳定币)。当这种情况发生时，如果用户提供同类别的资产作为抵押品，LTV和清算阈值将被E-Mode配置覆盖，赋以更高的资金效率。详见图1的说明。</p>
<p>在V3里，Aave协议支持最多255种E-Mode类别，可以开启一波新用例的浪潮，比如：</p>
<ul>
<li>高效的流动性挖矿</li>
<li>多样化的风险管理</li>
</ul>
<p><strong>例子</strong>  Aave协议把E-Mode第一类(稳定币)定义为： 97%的LTV，98%的清算阈值和2%的清算激励，没有定制预言机。</p>
<p><img src="/2022/07/09/aave-v3-techpaper/figure1.jpg" title="图一"></p>
<ol>
<li>用户选择E- Mode的分类一，即稳定币</li>
<li>用户质押DAI(正常情况下的LTV为75%)</li>
<li>现在如果借E-Mode分类一里的资产就可以使用E-Mode的系数，即98%，资产利用率提高了23%。这些DAI依然可以作为质押物去借其他资产，但是只有在同一个E-Model里的资产能享受到更优惠的参数。</li>
</ol>
<p><strong>隔离模型</strong>  需要加强的最相关领域之一是风险的复杂性。当治理团队在Aave协议上新增一项资产时，使用它作为抵押品的借款人立即可以获得整个协议的流动性。这使得新资产的上市变得复杂，并降低了借款人的资本效率。因此，V3引入了隔离模式，其灵感来自于用于公开管理的MakerDAO方法。</p>
<p>现在资产可以以“隔离”的方式上市(在通过治理团队表决之后)。借款者质押了“隔离”的资产作为抵押物的同时不能把“非隔离”的资产作为质押物去借款(尽管可以冲进池子里拿收益)，隔离模式下只能借出由goverance指定的稳定币。</p>
<p>图2中有一个例子，用户提供 TOKEN2 作为抵押品。TOKEN2 是一种隔离资产，最高债务上限为 1000 万美元，USDT、DAI 和 USDC 作为「可借用」资产。在提供 TOKEN2 作为抵押品后，用户将能够借入高达 1000 万美元的 USDT、DAI 和 USDC。即使用户提供另一种资产，假设是 ETH，V3 智能合约也不会允许用户以这些资产为抵押借款。尽管用户仍将通过提供的 ETH 赚取收益。如果用户希望将所有资产用作抵押品并退出隔离模式，其只需进行交易以禁用 TOKEN2 作为抵押品（受智能合约中有关抵押品比率、清算等的所有通常限制）。</p>
<p><img src="/2022/07/09/aave-v3-techpaper/figure2.jpg" title="图二"></p>
<h3 id="3-2-风险管理"><a href="#3-2-风险管理" class="headerlink" title="3.2 风险管理"></a>3.2 风险管理</h3><p>Aave V3有更加精细的风控参数和特性去支撑协议的高安全性，以对抗破产风险。</p>
<p><em>存款与借款限额：</em><br>治理团队现在可以设置存款和借款限额，借款限额和其它流动性合约一样，就是协议能调配某种资产的借款最大值。存款限额可以限制每种资产存进Aave协议的最大值，这有助于减少对某一资产的敞口，并降低无限铸币或预言机操纵等风险。</p>
<p><em>精细借款能力控制</em><br>现在的流动性协议没法在不执行清算的情况下降低某种资产的借款能力，当某一资产的风险状况发生变化时，这种方法的局限性就很大。在Aave V3中，通过精细借款能力控制，治理团队可以在不影响现有借款人的情况下，将任何资产的借贷能力降低至0%(尽管仍有可能在必要时清算现有用户)。</p>
<p><em>风控管理员</em><br>Aave V3里治理团队创建实体并且移交权限，它可以越过投票修改风险系数，这个实体可以是DAO(例如RiskDAO)或者一个自动代理，可以在某些量被打破时自动做出反应。</p>
<p><em>价格预言机哨兵</em><br>预言机哨兵特性是为了L2设计的，目的是处理排序器的最终停机时间（也可扩展到L1上以处理其他事件）。它引入了清算宽限期，并在特定情况下禁止借贷。</p>
<p><em>可变的清算关闭因子 （清算关闭因子就是允许一次清算掉被清算人质押物的比例）</em><br>在Aave V2里，每次只能清算头寸的一半，这在很多情况下是低效的，特别是高交易费或者小头寸的清算。在V3里，这一机制得到改进，可以在临近破产时完全平仓(HF&lt;0.95)。</p>
<h3 id="3-3-去中心化"><a href="#3-3-去中心化" class="headerlink" title="3.3 去中心化"></a>3.3 去中心化</h3><p>Aave V3引入了资产列表管理员的概念，治理团队可以创建并向任何实体（甚至是智能合约）授权，以实施新策略以将资产添加到Aave协议，而不是通过链上投票。这将允许构建者创建自定义资产列表策略，可以设计为带来真正的无权限资产列表。</p>
<h3 id="3-4-其它特性"><a href="#3-4-其它特性" class="headerlink" title="3.4 其它特性"></a>3.4 其它特性</h3><ul>
<li>所有设计token转移的业务(质押，还债)都支持EIP 2612的permit函数</li>
<li>信用委托将支持EIP-712签名</li>
<li>用户可以使用aTokens代替原来借入的底层资产来偿还借入的头寸</li>
<li>治理团队可以让实体获得即时流动性</li>
<li>治理团队可以可以重新配置提供给 Aave DAO 财政部的清算或即时流动性交易的任何费用</li>
<li>新的 flashloanSimple() 减少了高达 20% 的 gas 消耗(标准的、功能齐全的功能仍然可用)</li>
<li>重写了价格预言机的逻辑，使基础资产的计算普遍化</li>
<li>尽管有了这些新功能，但所有功能的gas费都下降了约20 - 25%</li>
<li>代码重构后更加模块化</li>
<li>智能合约的代码变小了–最多能运行100K的<a href="https://www.osgeo.cn/solidity/internals/optimizer.html">优化器</a></li>
<li>优化稳定利率计算的新策略，实现可以看这里： <a href="https://governance.aave.com/t/base-">https://governance.aave.com/t/base-</a> stable-rate-oracle-update-and-improvements-in-aave-v2&#x2F;1879，4.4也会深入探讨</li>
</ul>
<h2 id="4-特性说明"><a href="#4-特性说明" class="headerlink" title="4.特性说明"></a>4.特性说明</h2><h3 id="4-1-E-Mode"><a href="#4-1-E-Mode" class="headerlink" title="4.1 E - Mode"></a>4.1 E - Mode</h3><p>当质押物和借出资产在价格上有相关性，甚至是同一种底层资产的衍生物时，E-Mode应运而生，它会最大化资本效率。稳定币通常与底层资产(比如USD)挂钩，剧烈脱钩事件发生的概率不大。ETH的衍生物如stETH, sETH, alETH 等等，跟ETH脱钩的概率也不大，这样赋予它们互相之间高质押系数就很合理了。</p>
<p>在Aave协议以往的设计里，借款和质押物的价值是要换算成某种底层资产(如USD和ETH)来记录的，很难实现前文说的某种质押物对应某种借款，从而提升资本效率。</p>
<p>E-Mode引入了资产分类取代Aave协议的资产列表，在同一个分类里的资产通常在价格上有很强的相关性。分类不是在链上强制执行的，需要实体进行管理(比如governance)。</p>
<p>用户可以选择只借特定分类里的资产，当使用相同分类的质押物时就可以享受到高质押系数。</p>
<p>E-Mode 让每一个分类下的资产都可以使用特定的预言机。例如某一个分类里只有renBTC和WBTC，那么就可以给使用同一个 BTC&#x2F;USD 预言机，可以消除预言机异步造成的不必要清算(在BTC价格大幅下跌的情况下，由于WBTC&#x2F;USD和renBTC&#x2F;USD是异步的，所以它们的更新时间可能略有不同，这可能会导致不必要的清算)。特定类别的预言机为协议带来了更多的风险，如果其中一项资产维持价格(例如，由于协议被黑客攻击或特定衍生品的潜在问题)，它可能会导致破产。 Aave治理需要在每个资产和每个类别的基础上仔细评估是否使用特定类别的预言机。基于以上原因，E-Mode适合更快的网络(尤其是rollup)，在这种网络中，预言机可以更高效，而且不会因为高交易成本而招致清算。</p>
<p><em>Category 0</em><br>分类0是一个默认值，并不是E-Mode分类。所有的资产默认分类都是它。</p>
<p><em>Enter E-Mode</em><br>如果用户所有借款都在某个分类里，它就可以进入这个分类的E-Mode （分类0除外）</p>
<p><em>Exit E-Mode</em><br>当头寸的HF&gt;&#x3D;1即不存在清算风险时，用户才能退出E-Mode(设置分类为0)</p>
<p><em>User borrowing</em><br>在E-Mode中的用户只能借当前分类的资产，他们可以使用其他分类的资产作抵押，但是只有同分类下的质押物享有高质押系数</p>
<p><em>Asset addition</em><br>只有当E-Mode的LTV和清算阈值高于该资产默认的非E-Mode风险参数时，才可以通过授权实体(风险管理员或资金池管理员)将资产加入E-Mode</p>
<p><em>Asset removal</em><br>资产可以通过授权实体(风险或池管理)从E-Mode中移除。这可能使一些用户的偿付能力陷入不必要的清算(见第4.7节)。根据设计，用户在E-Mode下借出资产，而该资产随后被从E-Mode类别中移除不受影响。在移除后，仍在E-Mode的用户将不能再借出该资产。</p>
<h3 id="4-2-隔离模式"><a href="#4-2-隔离模式" class="headerlink" title="4.2 隔离模式"></a>4.2 隔离模式</h3><p>在包括Aave V2在内的这一代流动性协议中，如果新增了一种资产，整个流动性池子都会对其暴露，这意味着用户可以用这个新资产作抵押借到整个流动性池子里的任意资产，这限制了Aave新增资产的自由度，因为这是一个风险很大的操作，隔离模式就是为了解决此问题诞生的。</p>
<p>隔离模式允许协议以“隔离”的方式加入新资产，隔离资产有一个特有的债务上限(debt ceiling)，代表着可借的最大USD金额，精度为小数点后两位。使用隔离资产作为抵押的借款人只能使用该特定资产作为抵押，不能启用任何其他资产(包括其他隔离资产)。使用隔离资产的用户仍然可以通过其他资产的存款(supply)来产生收益。</p>
<p>可以在隔离模式借出的资产用BORROWABLE_IN_ISOLATION这个flag标记，尽管设计上可以选择任何资产，但还是应该选择USD的稳定币。可在隔离模式借入的资产必须属于同一类别，否则债务上限(debt ceiling)的计算就会不一致。这种一致性不能在智能合约级别实现，治理团队在设置 BORROWABLE_IN_ISOLATION时应该小心。</p>
<p><em>Isolated assets</em><br>任何一个债务上限(debt ceiling)大于0的都是隔离资产(和borrowcap不同，borrowcap是所有token都有的)</p>
<p><em>Adding isolated asset</em><br>资产只能在没有人质押的时候才能设置为隔离资产（由checkNoSuppliers()执行检查）</p>
<p><em>Isolated collateral</em><br>使用隔离资产作为抵押品的用户将只被允许使用该资产作为抵押品</p>
<p><em>Supplying isolated</em><br>提供其他资产并将其用作抵押品的用户，仍然可以提供隔离资产以产生收益。当用户已经提供了其他非隔离资产并启用了这些资产作为抵押时，应该永远不可能启用隔离资产作为抵押</p>
<p><em>Exit isolation mode</em><br>用户可以通过禁用隔离资产作为抵押品来退出隔离模式。考虑到隔离资产的性质，只有当用户没有借款时才会发生这种情况</p>
<p><em>Removing asset from isolation mode</em><br>授权实体可以随时把资产从隔离模式中移除</p>
<p><em>Debt ceiling</em><br>如果达到隔离资产的债务上限，用户应被禁止借款(债务上限不包括随着时间的推移累积的利息，只包括借款的本金)</p>
<h3 id="4-3-精细借款能力控制"><a href="#4-3-精细借款能力控制" class="headerlink" title="4.3 精细借款能力控制"></a>4.3 精细借款能力控制</h3><p>精细借款能力控制设计包括常规流动性协议采用的方法，即把质押能力分割为LTV和清算阈值。在Aave V2里这个特性已经实现了，但是更倾向于是一种对抗借款者资不抵债的软性防护。</p>
<p>举个例子：</p>
<p>Alice 想用一个LTV&#x3D;0，清算阈值&gt;0的资产来借款。这本应是不可能的，但是Alice可以这样做：</p>
<ol>
<li>存一个LTV&gt;0的资产</li>
<li>存一个LTV&#x3D;0的资产</li>
<li>借款</li>
<li>赎回LTV&gt;0的资产</li>
</ol>
<p>这就会留下一个LTV&#x3D;0质押物的头寸(这一点我没理解，第4步应该会有undercollatealized判断，业务上不应该让它赎回的)</p>
<p>Aave V3引入了更严格的LTV规则，所以现在可以强制执行实际的0借贷能力，同时防止上述情况的发生。这种保护要求借款人使用多个资产作为抵押——其中一个资产的LTV &#x3D;&#x3D; 0，要求借款人首先赎回这些资产，因此不能在那之前赎回LTV &gt; 0的资产。在上面的例子中，在V3中，Alice将被允许执行最后一步，但要先取出LTV &#x3D;&#x3D; 0的资产。因此V3完全避免了这种情况。一般来说，这种精细借款能力控制强制执行以下规则：</p>
<ul>
<li>用户可以抵押任何LTV &gt;0, 清算阈值&gt;0资产进行借款</li>
<li>如果某个资产的LTV被重置为0，那么用户就不能再以该资产为抵押借款了。</li>
<li>使用多种资产作为抵押的借款人，如果希望赎回，必须在赎回任何其他资产之前提取所有LTV&#x3D;0的资产。取款和转账都是如此。不过，对于LTV不为0的资产，仍允许进行清算。</li>
<li>对于希望提高借贷能力(接近清算阈值)的借款人来说，使用上述例子中解释的程序仍然是可以接受的。$\Delta LTV$↔清算阈值对借款人是一种软保护，是一种平均降低清算风险的方法，但对该协议而言，清算阈值仍被认为是安全的。</li>
</ul>
<h3 id="4-4-移除稳定利率预言机"><a href="#4-4-移除稳定利率预言机" class="headerlink" title="4.4 移除稳定利率预言机"></a>4.4 移除稳定利率预言机</h3><p>正如治理论坛上讨论的那样，新的利率策略实现了一种管理稳定利率(stable)的算法。</p>
<p>在现在的实现里移除了稳定利率预言机转而使用利率策略，把最小的稳定欠款APR设置为 $slope_{v,1}+offset_{base}$。<br>例如，对于一个stable offset &#x3D; 2%的资产，在其最优利用率为90%时，其可变利率达到4%，那么其最小稳定利率将为6%。然后使用$slope_{s,1}$和$slope_{s,2}$计算利率，如果$O_{ratio}$在最佳范围外的话还要使用$offset_{excess}$<br>为计算稳定利率，设$O_{util}$和$O_{ratio}$分别为总负债率常数的最优利用率和最优稳定借款比例，则计算稳定利率公式如下:</p>
<p><img src="/2022/07/09/aave-v3-techpaper/figure3.jpg" title="图三"></p>
<h3 id="4-5-传送门"><a href="#4-5-传送门" class="headerlink" title="4.5 传送门"></a>4.5 传送门</h3><p>Portal代表了一组核心功能，让Aave上的资产可以在不同链上自由转移，在顶层逻辑上很好理解：</p>
<p>Aave协议利用aToken的独特设计在源网络上燃烧aTokens，同时在目标网络上铸造aTokens。然后，基础资产可以以一种延迟的方式提供给目标网络上的Aave，即在其通过跨链桥后将其传递给流动性池。但是这对计算利率和目标网络上的市场安全有许多影响。</p>
<p>由于巧妙的设计，在协议层面实现这个只需要一个简单的方法。我们需要在协议加上三个特性：</p>
<ol>
<li>铸造 “无担保(unbacked)”aToken</li>
<li>“无担保(unbacked)”aToken扶正为正常aToken</li>
<li>为想要使用这些特性的合同提供白名单机制。</li>
</ol>
<p>除了这些特性，还需要增加与无支持aToken相关的利率计算和储备金计算。</p>
<p>注意，铸造无担保aToken不会影响借款人的util(市场利用率，通常用于描述池子里借款与存款的比例，用来计算利率)，因为这一部分aToken没有加在流动性上(因为$util_{v2} &#x3D; util_{borrow}$)。但是它会加在存款者的uilt上，因为无担保aToken也是要生息的，这两部分的计算方法如下所示：</p>
<p><img src="/2022/07/09/aave-v3-techpaper/figure4.jpg" title="图四"></p>
<p>如公式6所示，增加无担保aToken将降低supply利用率，从而降低流动性提供者赚取的利息，因为它们被铸造的代币稀释了。为了抵消这种利息稀释，无担保aToken对应的资产会通过增加liquidity index的方式提供一些费用支持。这个费用应该能覆盖铸造aToken产生的利息，所以为了让它满足弥补利息，应该满足以下条件：</p>
<p><img src="/2022/07/09/aave-v3-techpaper/figure5.jpg" title="图五"></p>
<p>虽然利率计算在核心协议里，但是上述部分的计算是在核心协议以外实现的。由于延迟供应和这部分费用计算没有在协议里强制执行，就需要治理者对传送门的授权慎之又慎。为了避免无限铸造无担保aToken产生的风险，会给每一个资产加一个标记“unbackedMintCap”。</p>
<h3 id="4-6-价格预言机哨兵"><a href="#4-6-价格预言机哨兵" class="headerlink" title="4.6 价格预言机哨兵"></a>4.6 价格预言机哨兵</h3><p>如3.2小节所述，Aave V3引入了一个价格预言机哨兵(Price Oracle Sentinel)来缓解在layer 2中可能出现的一些用户体验问题。</p>
<p><strong>浅谈Layer2</strong></p>
<p>目前的Layer2都是使用一个中心化的序列器产生块，然后用去中心化的方式验证(欺诈和有效性的证明)，以提高区块链的吞吐率。这种体系支持两种交易pending的队列，一种在链上，一种在链下，由sequencer操作。尽管sequencer可以使用两个队列的交易来出块，但是L1的pending事务通常可以推迟到某个截止日期，在此之后，用户可以强制执行一个操作，无论是zk-sync的包含模式还是退出模式。当sequencer遭遇停机的时候，这个“网络”就不会再更新状态了，没有新区块产生了。虽然仍然有可能将交易发送到pending的交易队列，但也没有什么会立即发生，链下的事务甚至可能被拒绝或删除，这取决于sequencer架构和停机的性质。</p>
<p>对于Aave和其他使用预言机喂价机制的系统，这意味着在sequencer停机的时候无法更新数据。只要sequencer停机，整个价格体系里都会出问题。这种不确定性和“慢速缓存崩溃”的可能性，以及L2交易直接在L1排队的情况是大多数正常用户遇不到的，致使Aave V3在这些特定的情况下引入了清盘的宽限期。只要这个头寸没有严重的资不抵债(0.95 &lt; HF &lt; 1)，都会被设置一个宽限期。如果HF&lt;0.95，就可以完全按照L1进行平仓。注意，这个宽限期只有在sequencer已经停机的情况下才会被激活。在宽限期内，用户也不允许借款。</p>
<h3 id="4-7-系统身份与风险模式"><a href="#4-7-系统身份与风险模式" class="headerlink" title="4.7 系统身份与风险模式"></a>4.7 系统身份与风险模式</h3><p>Aave协议实现了一个访问控制列表，以区别每个身份的权利与收益。这些身份在ACLManager合约中进行管理。ACLManager跟踪各个身份和身份的持有者，并允许身份管理员管理身份。身份管理员本身是一个由DEFAULT_ADMIN_ROLE管理的身份。</p>
<p>合约PoolAddressesProvider管理协议的各种组件(包括ACLManager和Pool)。PoolAddressesProvider跟踪各种协议模块，并有能力更新指针(例如更新ACLManager合约)或更新代理合约的实现(例如更新Pool的实现)。</p>
<p>PoolAddressesProvider由Aave Governance拥有，并指定DEFAULT_ADMIN_ROLE的初始持有者。在以太坊以外的网络中，使用跨链桥(<a href="https://github.com/aave/governance-crosschain-bridges)%EF%BC%8C%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8%E7%A4%BE%E5%8C%BA%E5%A4%9A%E7%AD%BE%E6%9D%A5%E7%AE%A1%E7%90%86PoolAddressesProvider%E3%80%82">https://github.com/aave/governance-crosschain-bridges)，或者使用社区多签来管理PoolAddressesProvider。</a></p>
<p><big><big><strong>身份权责</strong></big></big></p>
<p>下面我们将概述这些身份的权责。FLASH_BORROWER和BRIDGE的直接责任很少，主要可以访问协议的特定特性，而管理员类型的身份有处理风险或配置参数的权力和责任。</p>
<p><em>FLASH BORROWER</em><br>拥有这个身份的人将会免除闪电贷的保费 </p>
<p><em>BRIDGE</em><br>拥有这个身份的人可以执行 mintUnbacked() 和backUnbacked()</p>
<p><em>ASSET LISTING ADMIN</em><br>拥有这个身份的人可以: 1.更新和回退资产的预言机源，2.给Aave市场增加新资产 </p>
<p><em>RISK ADMIN</em><br>拥有这个身份的人可以:<br>            1.更新预言机哨兵的宽限期；2.更新储备金参数，如保留金因子，上限，E-Mode类别，借款，冻结&#x2F;解冻，LTV，清算阈值，清算激励(不能暂停&#x2F;恢复或激活&#x2F;停用储备金)。3.创建新E-Mode类别或者更新E-Mode(除了分类0)。4.更新无担保猪鼻新航线与流动性池fee率。</p>
<p><em>ACL ADMIN</em><br>拥有这个身份的人可以管理ACLManager里的身份。</p>
<p><em>EMERGENCY ADMIN</em><br>拥有这个身份的人可以暂停和恢复资金池或者单个储备金。</p>
<p><em>POOL ADMIN</em><br>拥有这个身份的人可以更新token的实现，移除，暂停&#x2F;恢复储备金以及<em>RISK ADMIN</em>和<em>ASSET LISTING ADMIN</em> 的所有权限</p>
<p><big><big>风险模式</big></big></p>
<p>下面概述潜在危害。由作恶的参与者引起，假如该参与者拥有这些身份之一：</p>
<p><em>ORACLES</em><br>恶意的预言机可能会提供一个无效的价格，允许它借更多的钱，或者根据无效的价格进行清算。</p>
<p><em>SEQUENCER</em></p>
<p><em>FLASH BORROWER</em><br>如果这个地址是一个proxy，任何人都可以通过它来申请闪电贷，从而免除所有费用。这将导致闪电贷不会给流动性提供者带来手续费。</p>
<p><em>BRIDGE</em><br>如果拥有这一身份的合约&#x2F;地址变得恶意(或有缺陷)，它可能会累积到无担保上限，并且永远不会扶正它，从而实际上允许它从流动性提供者那里窃取利益。</p>
<p><em>ASSET LISTING ADMIN</em><br>攻击者可以更新预言机源，使协议处于与恶意预言机相同的状态。或者攻击者可以列出具有恶意aToken(或debt token)实现的资产，允许他们取出用这些资产质押所借出的任何资金。</p>
<p><em>RISK ADMIN</em><br>攻击者可以将清算阈值降为0并清算用户。这可以在同一个交易里中自动完成。</p>
<p><em>EMERGENCY ADMIN</em><br>攻击者可以暂停安全的池子，也可以恢复不安全的池子。在市场崩溃的时候，攻击者可以关闭池自，然后自动执行顺序(打开-清算-关闭)，让他成为唯一的清算人。</p>
<p><em>POOL ADMIN</em><br>这个攻击者可以实现<em>RISK ADMIN</em>和<em>ASSET LISTING ADMIN</em>的所有攻击方式，或者可以更改一个token的实现方式。</p>
<p><em>ACL ADMIN</em><br>这个人可能给自己任意其它身份进行攻击</p>
<p><em>ADDRESSES PROVIDER</em><br>要是这个身份是恶意的那就彻底玩完了</p>
<p>Aave governance会对控制这些潜在攻击，当治理团队将身份赋予特定的参与者时，它应该使用中间件合约来限制参与者的权限操作。例如，对于ASSET LISTING ADMIN拒绝更改现有oracle，只允许添加。</p>
]]></content>
      <categories>
        <category>Defi</category>
      </categories>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>基于bls12-381生成秘密随机点</title>
    <url>/2022/07/05/bls12-381-mpc/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>作者在搬groth16上链的项目里需要用到一些椭圆曲线上的秘密随机点(自然也可以把它当作root生成随机数)，需要用到MPC计算生成。记录一下算法和思路，加密部分使用bls12-381加密库。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>因为在Groth16中需要使用到一系列的随机点进行掩藏数据，产生这些随机数的参数绝不能泄漏，比如bls12-381上的一个$\alpha$点来源$g_1\times a$，由于陷门函数的特性，我们无法通过$\alpha$来推导出$a$，但是一旦$a$遭到泄漏，就可以直接计算出$\alpha$。</p>
<p>那么我们就需要一种在运算过程中不可能泄露$a$的方法去生成$\alpha$，这就可以转换成一个多方协同计算的问题：</p>
<p>假设有n个参与生成计算的节点参与，它们会依次提供$a_1，a_2，a_3…a_n$这n个随机数计算出$\alpha_1，\alpha_2…\alpha_n$，如果先计算$a$再进行隐藏：$\alpha&#x3D;(\prod_{i&#x3D;1}^n a_i)\times g_1$，那么$a$和传输过程中的$a_i$都有可能泄露。</p>
<p>要将中间变量加密变成$E(\prod_{i&#x3D;1}^n a_i)$和$E(a_i)$，才能在运行过程中不泄漏任何一个人提供的信息$a_i$，就可以保证每一个参与提供随机数的节点都不可能的知道最终的$a$，所有人拿到的只有加密后中间值。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>可以预见的一点就是在依次计算的过程中，我们需要防止有人作恶，篡改之前的结果。如果第3个节点收到了加密数据$E(a_1\times a_2)$，但是它传给下一个人的却是$E(a_3\times a_3 \times a_3)$——擅自修改了内容，我们需要如何验证呢？</p>
<p>如果我们没有使用加密数据$E(a_1\times a_2)$和$E(a_3\times a_3 \times a_3)$，而是直接存储了$a_1\times a_2$，接受第三个节点的$a_3\times a_3 \times a_3$和他自己的$a_3$，那么我们只需要验证上一次的结果$a_1\times a_2$与新节点提供的随机数$a_3$乘积是否等于它传给下一个人的$a_3\times a_3 \times a_3$，就可以了。</p>
<p>但是<strong>所有人拿到的只有加密后中间值</strong>，我们只要保证中间值的运算结果符合数字运算的规律，也就是“同态”即可。</p>
<p><strong>如果加密函数E(x)满足以下特性,则认为有同态性</strong><br>$$ 加法同态:E(a+b)&#x3D;E(a)+E(b)  \ 乘法同态:E(ka)&#x3D;kE(a) \双线性映射:假设有两个群G_1,G_2,G_1*G_1&#x3D;G_2,g是G_1的生成元,e(g,g)是G_2的生成元,则<br>e(g^a,g^b)&#x3D;e(g,g)^{ab}&#x3D;e(g^b,g^a)$$</p>
<p>我们的bls12-381中也符条件，既<br>加法同态：$(a_1+a_2)\times g_1 &#x3D; a_1\times g_1 + a_2\times g_1$<br>乘法同态：$k \times (a_1\times g_1) &#x3D; (k\times a_1)\times g_1$</p>
<p>双线性映射：$pairing(a_1\times g_1 , a_2\times g_2) &#x3D; pairing((a_1\times a_2)\times g_1，g_2)$</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>我使用双线性映射来进行验证，第i个节点传输的数据为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone, Copy)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ParameterPair</span>&lt;E: Engine&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> g1_result: <span class="type">Option</span>&lt;E::G1Affine&gt;,<span class="comment">//传给下一个节点的数据,g1上的点,既(a1*a2*..ai * g1)</span></span><br><span class="line">    <span class="keyword">pub</span> g2_result: <span class="type">Option</span>&lt;E::G2Affine&gt;,<span class="comment">//传给下一个节点的数据,g2上的点,既(a1*a2*..ai * g2)</span></span><br><span class="line">    <span class="keyword">pub</span> g1_mine: <span class="type">Option</span>&lt;E::G1Affine&gt;,<span class="comment">//该节点新加入的数据,g1上的点,既(ai * g1)</span></span><br><span class="line">    <span class="keyword">pub</span> g2_mine: <span class="type">Option</span>&lt;E::G2Affine&gt;,<span class="comment">//该节点新加入的数据,g1上的点,既(ai * g2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证端保存着之前$i-1$个节点传输数据的列表：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="type">Vec</span>&lt;ParameterPair&lt;E&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>需要通过这个列表 的最新数据和节点自己的随机数更新信息：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mpc_common_paramters_custom</span>&lt;E&gt;(</span><br><span class="line">    paramter_last: &amp;ParameterPair&lt;E&gt;,</span><br><span class="line">    num: E::Fr,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;ParameterPair&lt;E&gt;, SynthesisError&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    E: Engine,</span><br><span class="line">    E::G1: WnafGroup,</span><br><span class="line">    E::G2: WnafGroup,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g1</span> = E::G1::<span class="title function_ invoke__">generator</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g2</span> = E::G2::<span class="title function_ invoke__">generator</span>();<span class="comment">//g1,g2是两个群上的元，类似于自然数中的1。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g1_before</span> = paramter_last.g1_result.<span class="title function_ invoke__">unwrap</span>();<span class="comment">//之前列表的最新值：a1*a2*...a(n-1) * g1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g1_after</span> = (g1_before * num).<span class="title function_ invoke__">to_affine</span>();<span class="comment">//预期中更新之后的值：a1*a2*...a(n-1)*a(n) * g1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g2_before</span> = paramter_last.g2_result.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g2_after</span> = (g2_before * num).<span class="title function_ invoke__">to_affine</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g1_mine</span> = (g1 * num).<span class="title function_ invoke__">to_affine</span>();<span class="comment">//a(n)*g1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g2_mine</span> = (g2 * num).<span class="title function_ invoke__">to_affine</span>();<span class="comment">//a(n)*g2</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = ParameterPair &#123;</span><br><span class="line">        g1_result: <span class="title function_ invoke__">Some</span>(g1_after),</span><br><span class="line">        g2_result: <span class="title function_ invoke__">Some</span>(g2_after),</span><br><span class="line">        g1_mine: <span class="title function_ invoke__">Some</span>(g1_mine),</span><br><span class="line">        g2_mine: <span class="title function_ invoke__">Some</span>(g2_mine),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在新增数据之前，可以通过该列表和新节点传入数据验证：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">verify_mpc_g1</span>&lt;E&gt;(new_paramter: &amp;ParameterPair&lt;E&gt;, paramters: &amp;<span class="type">Vec</span>&lt;ParameterPair&lt;E&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">bool</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    E: Engine,</span><br><span class="line">    E::G1: WnafGroup,</span><br><span class="line">    E::G2: WnafGroup,</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	*g1,g2是两个群上的元，类似于自然数中的1。</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g1</span> = E::G1::<span class="title function_ invoke__">generator</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g2</span> = E::G2::<span class="title function_ invoke__">generator</span>();</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	*这一步验证传来的结构体里g1,g2上的点是一一对应而非假造的，验证方法为：</span></span><br><span class="line"><span class="comment">		* pairing(g1_mine, g2)== E::pairing(g1, g2_mine);</span></span><br><span class="line"><span class="comment">		* pairing(g1_result, g2)== E::pairing(g1, g2_result);</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = E::<span class="title function_ invoke__">pairing</span>(&amp;new_paramter.g1_mine.<span class="title function_ invoke__">unwrap</span>(), &amp;g2.<span class="title function_ invoke__">to_affine</span>())</span><br><span class="line">        == E::<span class="title function_ invoke__">pairing</span>(&amp;g1.<span class="title function_ invoke__">to_affine</span>(), &amp;new_paramter.g2_mine.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">  	result = E::<span class="title function_ invoke__">pairing</span>(&amp;new_paramter.g1_result.<span class="title function_ invoke__">unwrap</span>(), &amp;g2.<span class="title function_ invoke__">to_affine</span>())</span><br><span class="line">        == E::<span class="title function_ invoke__">pairing</span>(&amp;g1.<span class="title function_ invoke__">to_affine</span>(), &amp;new_paramter.g2_result.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span> = paramters.<span class="title function_ invoke__">len</span>();</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		* 这一步用来验证第i个节点是否篡改了原来的数据：拿出一个进故宫验证的节点i-1的数据list[i-1]</span></span><br><span class="line"><span class="comment">		* 那么应该有：pairing(list[i-1].g1_result,new_paramter.g2_mine)==pairing(new_paramter.g1_result,g2)</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    <span class="title function_ invoke__">if</span> (index &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">paramter_last</span> = new_paramter.g1_result.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">paramter_part2</span> = new_paramter.g2_mine.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">paramter_part1</span> = paramters[index - <span class="number">1</span>].g1_result.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        result = result</span><br><span class="line">            &amp;&amp; E::<span class="title function_ invoke__">pairing</span>(&amp;paramter_last, &amp;g2.<span class="title function_ invoke__">to_affine</span>())</span><br><span class="line">                == E::<span class="title function_ invoke__">pairing</span>(&amp;paramter_part1, &amp;paramter_part2);</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果验证通过，再将该节点的信息加入进列表，进行下一轮计算。</p>
<p>最后拿到的g1_result和g2_result就是$(\prod_{i&#x3D;1}^n a_i)\times g_1$和$(\prod_{i&#x3D;1}^n a_i)\times g_2$了，这同时我们确实没有泄露任何一个$a$，也避免了作恶。</p>
<h2 id="一些总结和延伸"><a href="#一些总结和延伸" class="headerlink" title="一些总结和延伸"></a>一些总结和延伸</h2><p>大家应该可以看出这个实例也可以用同态加法或乘法来做，比如每个人传$a_i\times g_1$，然后维护一个$(a_1+a_2+…+a_i)\times g_1$来使用和验证即可。或者说任何一个同态加密方法都可以依照此法进行多方计算。</p>
<p>同态加密也可以用于验证信息，比如同一组信息分成几个碎片，通过这吸热碎片验证这个集体对某物的所有权，我们可以通过同态加密计算，每一个人的私钥碎片是$k_1,k_2…k_n$，私钥为$K&#x3D;(\prod_{i&#x3D;1}^n k_i)$如何在不互通私钥信息的情况下一起生成一个私钥呢？可以把每一个私钥同态隐藏起来$E(k_i)$，计算$E(\prod_{i&#x3D;1}^n k_i) &#x3D; \prod_{i&#x3D;1}^n E(k_i)$来进行验证。</p>
<p>感谢您的观看，作者也是刚刚接触，如有错漏请诸君斧正。</p>
<p><a href="alvan.coffee">作者博客: alvan.coffee</a></p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解EVM - Part 5 - 调用/委托调用的原理与实现</title>
    <url>/2022/06/30/Digging-Deep-EVM-Part5/</url>
    <content><![CDATA[<p>原文链接：<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-a5f">https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-a5f</a><br>译者：<a href="alvan.coffee">Alvan’s Blog</a></p>
<h1 id="深入理解EVM-Part-5-调用-x2F-委托调用"><a href="#深入理解EVM-Part-5-调用-x2F-委托调用" class="headerlink" title="深入理解EVM - Part 5 - 调用&#x2F;委托调用"></a>深入理解EVM - Part 5 - 调用&#x2F;委托调用</h1><p>今天我们详细解读一下 CALL 和 DELEGATECALL 两个操作，如果没看过<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?utm_source=/profile/80455042-noxx&utm_medium=reader2&s=r">第二篇</a>，<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?utm_source=/profile/80455042-noxx&utm_medium=reader2&s=r">第三篇</a> 和<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-5a5?utm_source=/profile/80455042-noxx&utm_medium=reader2&s=r">第四篇</a>的话，建议作为前置知识读一下。</p>
<p>我们将从solidity，EVM 和 Geth 三个层面解读这两个opcode，让你对它们有一个全面的认识。然而在深入理解他们之前，我们先确认一下合约执行上下文的概念：</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p><em>当EVM运行合约时，会创造一个<a href="https://www.evm.codes/about">上下文</a>，它包含以下几个部分：</em></p>
<ul>
<li>Code<ul>
<li>存储在链上的合约的不可变代码。</li>
</ul>
</li>
<li>Call Stack<ul>
<li>前文讲过的合约的调用栈，EVM运行合约时会初始化一个空的。</li>
</ul>
</li>
<li>Memory<ul>
<li>合约的内存，EVM运行合约时会初始化一个空的。</li>
</ul>
</li>
<li>Storage<ul>
<li>存储区在执行过程中持久化，链上存储，根据合约地址和插槽寻址。</li>
</ul>
</li>
<li>The Call Data<ul>
<li>交易的传入数据</li>
</ul>
</li>
<li>The Return Data<ul>
<li>合约调用的返回数据</li>
</ul>
</li>
</ul>
<p>在阅读下面内容时，时刻记着这几个点。我们先从<a href="https://www.youtube.com/watch?v=uawCDnxFJ-0">Smart Contract Programmer</a>的DELEGATECALL使用用例开始讲：</p>
<h3 id="Solidity-样例"><a href="#Solidity-样例" class="headerlink" title="Solidity 样例"></a>Solidity 样例</h3><p>下图是同一个合约中的两个调用，一个使用了DELEGATECALL，另一个使用了CALL。现在我们看一下他们之间的区别。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fbd68e45d-6238-483a-bf8f-393db30ac39c_2650x1572.png"><img src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fbd68e45d-6238-483a-bf8f-393db30ac39c_2650x1572.png" alt="img"></a></p>
<p>下边是这次交互的一些信息(如果你在remix里自己执行的话，会是不一样的数据)：</p>
<p>我们有两个合约，即 Contract A 和 Contract B 还有一个 EOA：</p>
<ul>
<li>EOA 地址 &#x3D; 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</li>
<li>Contract A 地址 &#x3D; 0x7b96aF9Bd211cBf6BA5b0dd53aa61Dc5806b6AcE</li>
<li>Contract B 地址 &#x3D; 0x3328358128832A260C76A4141e19E2A943CD4B6D</li>
</ul>
<p>现在把 Contract B 的地址和一个uint值 12以及 1000000000000000000 Wei 传入，调用 Contract A 里的两个方法， setVarsDelegateCall 和 setVarsCall。</p>
<p><em><strong>Delegate Call</strong></em></p>
<ol>
<li>一个 EOA 地址把 Contract B 的地址和一个uint值 12以及 1000000000000000000 Wei 传入，调用Contract A的setVarsDelegateCall，这次是委托调用Contract B执行setVars(uint256)，参数是12。</li>
<li>委托调用运行 Contract B 的 setVars(uint256) 但是更新的是 Contract A 的存储区，它运行时的存储区，msg.sender 和msg.value 也都和父调用一样。</li>
<li>Contract A的存储区写入数据：num&#x3D;12，sender &#x3D; EOA Address以及value &#x3D; 1000000000000000000。尽管Contract A 调用的setVars(uint256)不带value，</li>
</ol>
<p>执行完这个方法之后我们检查Contract A 和Contract B的num， sender 和 value状态。我们可以看到Contract B没有被初始化，都设置在Contract A里了。</p>
<p><em><strong>Call</strong></em></p>
<ol>
<li>一个 EOA 地址把 Contract B 的地址和一个uint值 12以及 1000000000000000000 Wei 传入，调用 Contract A 的setVarsCall，这次是调用Contract B执行setVars(uint256)，参数是12。</li>
<li>调用运行 Contract B 的setVars(uint256) ，不改变(本合约的)存储区，msg.sender,和msg.value</li>
<li>Contract B的存储区写入数据：num&#x3D;12，sender &#x3D; Contract A Address 以及value &#x3D; 0。(1000000000000000000 Wei被传进了父调用setVarsCall。)</li>
</ol>
<p>执行完这个方法之后我们检查Contract A 和Contract B的num， sender 和 value状态。我们可以看到Contract A没有被初始化，都设置在Contract B里了。</p>
<p>“委托调用”就是允许你从别的合约里复制一个方法粘贴到你的合约里，运行起来就行在你的合约里执行的一样，使用本合约的存储区，msg.sender 和 msg.value。而“调用”是进入到另一个合约去执行方法，相当于发了一笔交易，有其自己的value值和sender(也就是调用call的合约)。</p>
<h3 id="Delegate-Call-amp-Storage-Layout委托调用与内存布局"><a href="#Delegate-Call-amp-Storage-Layout委托调用与内存布局" class="headerlink" title="Delegate Call &amp; Storage Layout委托调用与内存布局"></a>Delegate Call &amp; Storage Layout委托调用与内存布局</h3><p>在上述例子里，你肯呢个注意到Contract B 第5行的注释<em>“NOTE: storage layout must be the same as contract A”</em>。</p>
<p>合约里的每一个函数都会经过编译成为一个静态的字节码。当我们理解solidity变量的时候，是看见num，sender和value去理解的。但是字节码不知道这些，它只认存储插槽，而声明变量的时候就把插槽定下来了。</p>
<p>Contract B 的 setVars(uint256) 函数里，“num &#x3D; _num”就是说要把 _num 存进插槽0。当我们看一个DELEGATECALL的时候不要去想num → num，sender → sender的映射，因为在字节码的层面不是这样的，我们需要认识到这是slot 0 → slot 0, slot 1 → slot 1的映射。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcf64c77b-f60f-4720-96bb-575dabef8917_1006x306.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcf64c77b-f60f-4720-96bb-575dabef8917_1006x306.png" alt="img"></a></p>
<p>试想如果我们改变了声明变量的顺序会怎样。那么他们的插槽位置会改变，同时setVars(uint256) 的字节码也跟着变了。如果我们把 Contract B 的6行和8行互换位置，先声明 value 后声明 num 。那就意味着11行的“num &#x3D; _num”意味着把 _num存进插槽2里，13行的“value &#x3D; msg.value”意味着把msg.value 存进插槽0。这就用意味着两合约中，我们变量之间的映射和插槽之间的映射不匹配了</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F0f24b3ce-a2ed-4bbe-b87d-6d36b9148640_1006x306.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F0f24b3ce-a2ed-4bbe-b87d-6d36b9148640_1006x306.png" alt="img"></a></p>
<p>在这种情况下，当我们运行 DELEGATECALL 时，num变量会被存在插槽2，而这里在 Contract A 中映射到 value 变量。反过来也是一样的，两个变量就会存储进预想之外的地方。这就是DELEGATECALL比较危险的原因之一。我们意外地 value 值把 num 覆盖了，用 num 值把 value 覆盖了。但是黑客可不会意外，他们会有目的地攻击。</p>
<p>试想我们知道一个开放 delegatecall 的合约，我们知道那个合约存储 owner的插槽。现在我们可以做一个相同布局的合约，然后写一个更新owner的方法，这就意味着我们可以通过委托调用这个更新方法来改变该合约的owner。</p>
<p>如果你对这个黑客攻击感兴趣的话可以在这里深入了解一下：</p>
<ul>
<li><a href="https://ethernaut.openzeppelin.com/level/0x9451961b7Aea1Df57bc20CC68D72f662241b5493">Ethernaut Level 6 - Delegation</a></li>
<li><a href="https://ethernaut.openzeppelin.com/level/0x97E982a15FbB1C28F6B8ee971BEc15C78b3d263F">Ethernaut Level 16 - Preservation</a></li>
</ul>
<p>下面看一看opcode层面</p>
<h2 id="Opcodes"><a href="#Opcodes" class="headerlink" title="Opcodes"></a>Opcodes</h2><p>我们现在知道DELEGATECALL怎么工作了，那么深入一下，看看DELEGATECALL和CALL的操作码。</p>
<p>对于DELEGATECALL我们有以下输入变量</p>
<ul>
<li><code>gas</code>: 执行的gas费</li>
<li><code>address</code>: 执行上下文的account</li>
<li><code>argsOffset</code>: 输入数据(calldata)的偏移量</li>
<li><code>argsSize</code>: calldata的大小</li>
<li><code>retOffset</code>: 输出数据(returndata)的偏移量</li>
<li><code>retSize</code>: returndata的大小</li>
</ul>
<p>CALL比起上边的只多一个value，其它的都一样</p>
<ul>
<li><code>value</code>: 发送给account的以太币(CALL only)</li>
</ul>
<p>委托调用不需要value输入，它从父调用继承。我们的执行上下文有和父调用一样的存储区，msg.sender 和 msg.value。</p>
<p>他们都是有一个返回值布尔值”success”，为0则为执行失败，反之则为1。</p>
<blockquote>
<p><em>如果调用位置没有合约或者没有代码，Delegatecall会返回true。这会出现bug，因为它没执行，我们是希望返回False的</em></p>
</blockquote>
<h3 id="DELEGATECALL-Opcode-Inspection-With-Remix利用Remix检验DELEGATECALL"><a href="#DELEGATECALL-Opcode-Inspection-With-Remix利用Remix检验DELEGATECALL" class="headerlink" title="DELEGATECALL Opcode Inspection With Remix利用Remix检验DELEGATECALL"></a>DELEGATECALL Opcode Inspection With Remix利用Remix检验DELEGATECALL</h3><p>下边是Remix中调用DELEGATECALL操作码的截图。对应Solidity代码的24-26行。</p>
<p>我们可以看到栈和内存的条目以及它们是怎么传进DELEGATECALL的。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F39945796-94b6-4d6b-8bf6-52b29ac22559_3404x1334.png"><img src="https://substackcdn.com/image/fetch/w_5760,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F39945796-94b6-4d6b-8bf6-52b29ac22559_3404x1334.png" alt="img"></a></p>
<p>我们按照这条路线理解：opcode → stack → memory → calldata</p>
<ol>
<li>Solidity代码的24行，使用了delegatecall 调用 Contract B 的 setVars(unit256)，调用了DELEGATECALL操作码。</li>
<li>DELEGATECALL从栈上拿6个输入：<ol>
<li>Gas &#x3D; 0x45eb</li>
<li>Address &#x3D; 0x3328358128832A260C76A4141e19E2A943CD4B6D (Address for Contract B)</li>
<li>ArgsOffset &#x3D; 0xc4</li>
<li>ArgsSize &#x3D; 0x24</li>
<li>RetOffset &#x3D; 0xc4</li>
<li>RetSize &#x3D; 0x00</li>
</ol>
</li>
<li>注意到 argsOffset 和 argsSize 两个代表了传入 Contract B 的 calldata。这两个变量让我们从内存位置0xc4开始，复制后边的 0x24 (十进制36)作为calldata。</li>
<li>我们因此拿到了0x6466414b000000000000000000000000000000000000000000000000000000000000000c，6466414b是setVars(uint256) 的函数签名，而000000000000000000000000000000000000000000000000000000000000000c是我们传入的数据 12。</li>
<li>这对应了Solidity代码的25行，abi.encodeWithSignature(“setVars(uint256)”, _num)。</li>
</ol>
<p>因为setVars(uint256)不返回任何值，所以retSize置0。</p>
<p>如果有返回值的话，就是存在retOffset以后的retOffset以内。这应该让你对这个操作码的底层逻辑了解的深一点，也会和Solidity联系起来了。</p>
<p>现在我们看一下Geth里的实现。</p>
<h3 id="Geth实现"><a href="#Geth实现" class="headerlink" title="Geth实现"></a>Geth实现</h3><p>我们看一下Geth里写DELEGATECALL的部分。目标是展现DELEGATECALL和CALL在存储的层面的区别，以及是怎么联系上SLOAD的。</p>
<p>下边的图有点唬人，但是我们拆解开来一步一步做，在结束的时候你就会对DELEGATECALL和CALL有深刻的认识。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F60abd9bd-475f-4694-8bce-aa4c4b43fadd_4102x3874.png"><img src="https://substackcdn.com/image/fetch/w_5760,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F60abd9bd-475f-4694-8bce-aa4c4b43fadd_4102x3874.png" alt="img"></a></p>
<p>We have the DELEGATECALL &amp; CALL opcodes labeled on the left-hand side and the SLOAD opcode labeled bottom right. Let’s see how they’re connected.</p>
<ol>
<li>这图里有两个 [1] 号截图，分别对应DELEGATECALL和CALL操作码的代码，在<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/instructions.go">instructions.go</a>里。我们可以看到从栈里弹出的那几个变量，之后可以看到调用 interpreter.evm.DeleagteCall和 interpreter.evm.Call 这两个函数，传进去了栈里的变量，目标地址和现在的合约上下文</li>
<li>图里也有两个 [2] 号截图，分别对应 evm.DelegateCall 和 evm.Call 的代码的代码，在 <a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/evm.go">evm.go</a>里边。中间省略了一些校验和其它函数，我们主要关注执行调用NewContract方法新建上下文的代码，其它的可以忽略掉。</li>
<li>图里有两个 [3] 号截图。里边主要是evm.DelegateCall和evm.Call 调用NewContract。它们非常相似，以下两点除外：<ol>
<li>DelegateCall的value参数设为nil，它从之前的上下文继承，所以不写进这个参数里。</li>
<li>NewContract的第二个参数也不一样。evm.DelegateCall 里caller.Address( ) 用的是Contract A的地址。evm.Call 里addrCopy是复制的toAddr，也就是Contract B的地址，这一点区别非常大。他俩都是AccountRef类型，这个很重要，后边会提到。</li>
</ol>
</li>
<li>DelegateCall’s的NewContract会返回一个Contract结构体。它又调用了AsDelegate()方法(在<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/contract.go">contract.go</a>里)(见图[4])，把msg.sender 和 msg.value设置成了父调用的样子，也就是EOA地址和1000000000000000000 Wei。这在Call的实现里是没有的。</li>
<li>evm.DelegateCall 和 evm.Call 都执行NewContract方法(在<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/contract.go">contract.go</a>里)，NewContract方法的第二个入参是“object ContractRef”，对应着第三点里提到的AccountRef。</li>
<li>“object ContractRef”和一些其他值被用来初始化合约，对应Contract结构体里的“self”</li>
<li>Contract结构体( 在<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/contract.go">contract.go</a>里)有一个“self”字段，你可以看到也有其他的字段与我们之前提到的执行上下文有关。</li>
<li>现在我们跳跃一下，去看看Geth里SLOAD(在<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/instructions.go">instructions.go</a>里)的实现，它在调用GetState时用的参数就是scope.Contract.Address( )。这里的“Contract”就是我们在第7条提到的结构体。</li>
<li>Contract结构体的Address( ) 返回的是self.Address。</li>
<li>Self是一个ContractRef类型，ContractRef必然有一个Address( ) 方法。</li>
<li>ContractRef是一个接口，规定如果一个类型要做ContractRef，那必须有一个返回值类型是common.Address的Address( ) 函数。common.Address是一个长度20的字节数组，也就是以太坊地址的长度。</li>
<li>我们回到第3块看一下evm.DelegateCall和evm.Call 中AccountRef的区别。我们可以看到AccountRef就是一个有Address( ) 函数的地址，那它也符合ContractRef接口的规则。</li>
<li>AccountRef 的 Address( ) 函数是把 AccountRef 转化成common.Address，也就是 evm.DelegateCall 里的 Contract A 地址和 evm.Call 里的Contract B 地址。这意味着第8部分讲的 SLOAD 会在 DELEGATECALL 时使用 Contract A 的存储区，在 CALL 时使用 Contract B 的存储区。</li>
</ol>
<p>通过学习Geth的实现你应该对DelegateCall的存储区， msg.sender和msg.value的来龙去脉有了深刻了解，对DELEGATECALL也有了一定的认识，很棒！下次再见！</p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>defi-compound经济模型</title>
    <url>/2022/06/09/test-blog/</url>
    <content><![CDATA[<p><u>注：本篇文章适合初步了解区块链以及去中心化知识的Defi初学者&#x2F;合约开发者，仅供学习参考，作者不推荐中国大陆居民购买任何加密货币与其理财产品</u></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作者在fork一份compound的项目之后，觉得其中有不少值得一说的思想，比如激励comp的分配模式，利率模型等等。这篇文章会主要从业务逻辑和合约代码来讲解其经济模型，其治理模式，预言机与其他组件不做讲解，争取做到Defi初学者看完可以理解模型，开发者看完可以直接复现(不是，compound的代码本身也出现过一些漏洞，copy需谨慎)。</p>
<h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p> compound是一个借贷合约，想想通常情况下在中心化的机构例如银行里进行质押 - 借贷的程序是：</p>
<p>小张 存入 100元 到 某银行的资金池</p>
<p>小李 抵押 价值150元的资产 从 某银行的资金池 借出 100元</p>
<p>一个月后</p>
<p>小李 还账 100元本金+1元(借款利息) 给 某银行</p>
<p>小张 取钱时 某银行按照利率 返还 100元本金和0.02元(存款利息)</p>
<p>如果小李资不抵债，银行清算小李的抵押资产，小张的借款利息不变</p>
<p>看到什么问题了吗，借款利息和存款利息受银行调控，放贷的利息远比存款利息要高。随之出现的就是P2P借贷，P2P借贷的模式繁杂，大致是以下程序：</p>
<p>小李 发布 100元借款的需求(自定义利率) 到 P2P平台</p>
<p>P2P平台 对 小李 资质审查 判断风险与是否上架</p>
<p>小张 选择 小李的借款单子 出借 100元 给 小李</p>
<p>小李 按照单子约定 还款 100元(本金) + 10元(借款利息)</p>
<p>P2P平台 中间收取 一定比例的手续费与管理费1元</p>
<p>小张 拿走其余9元利息和100元本金</p>
<p>如果小李逾期未还，看P2P平台的心情平账</p>
<p>P2P的问题依然明显，用户为了取得更高的收益承担了更多的风险，P2P平台的诚信和公正也无法保证。去中心化想要解决的就是大平台的高抽成和垄断问题和小平台的信任问题，把分账，风险评估，清算全部交给不可更改的程序，这就是co mpound与其他Defi项目所做的事情。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>compound提供了借款，还款，存款，取款，清算等功能，它的质押资产和借出资产都是虚拟货币。</p>
<p>其中每一种虚拟货币的资金池称为一个market，所有质押A货币的用户共同构成一个A market。同理，所有借出A货币的用户都从这个market借款，还款。他们共同使用A market的借款利率和抵押利率。这让风险和收益平分到了每个使用者的身上，一个人不用因为借出某个坏人而坏账，因为他们共用这个market。</p>
<p>——-这就是CToken合约做的事情</p>
<p>我们这样做的前提是可以判断质押物和借出的价值和数量。例如小李想要借走1个eth，那么他的质押物总值应该大于等于value(1 eth) &#x2F; factor ，此处的factor为质押率，我们需要一个中间系统来整合每个market的情况和用户在每个market里的存款和借款。我们把CToken和用户信息登记到这个comptroller合约内，这样可以整合每个用户的资&#x2F;债情况， 再由comptroller合约来对接预言机，获得虚拟货币的单价。这样通过使用每个虚拟货币的单价和用户在每个market里的质押&#x2F;借出值，算出用户目前的财务状态，帮助CToken判断是否同意用户的借款&#x2F;取款操作   </p>
<p> ——-这就是comptroller合约做的事情</p>
<p>我们在上边两个合约里解决了信任问题，使用固定利率明显不符合大开大合的加密货币市场，我们要添加一个市场调节的利率模型和利息计算模式，这也是compound的核心经济模型。我将在下一节 业务逻辑 详细介绍。</p>
<p> ——-这就是InterestModel合约做的事情</p>
<p>作为一个Defi项目自然要自己发行一个新币啦，它会给每个market的用户的几乎每次财产操作发放激励，它也作为compound项目的治理代币，可以参与修改预言机或者市场的利率模型等，其激励机制我也会在下一节 业务逻辑 详细介绍。</p>
<p> ——-这就是Comp合约做的事情</p>
<h2 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h2><h3 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h3><p>首先，我们需要一个标记用户质押资产和借款的方法，而质押资产的价值和借款的数目与价值会随着利息改变，这时引入一个概念 cToken。cToken是CToken合约发行的货币，在用户存入底层资产时，发给用户作为资产凭证。</p>
<p>比如小张存入100A币，则A market对应的CToken合约会给用户发放 100&#x2F;exchangeRate 个 cA币。exchange的初始值由管理员设定，之后的公式为：</p>
<p>$exchangeRate &#x3D; \frac{totalCash+totalBorrow-totalReserves}{totalSupply}$</p>
<p>其中totalSupply为发行的所有cA 币总量，totalCash为存入该market且没被借走的A币总值，totalBorrow为从market里借走的A币总量，totalReserves为CToken自己收取的中介费。</p>
<p>小李想借出一些A币，那么他向market发起借款申请：借100个A币。comptroller查询了他在所有market里的资&#x2F;债情况，也就是借款记录和cB,cC,cD…….等等的持有量，判断该次操作是否会造成资不抵债，如果不会，则给小李的账户发送100A币，并在A market里更新小李的A 借款额。</p>
<p>在小李借走100A的时间里，每一个用户的每次资产操作都会 “刷新利息&#x2F;利率” ，会更新一些系数，控制exchangeRate和每个人的借款额。</p>
<p>如果小李借走100A的期间里，A币价格暴跌，套利机器人将把小李的其他资产贱卖进行平账。</p>
<p>因为一个用户的资产凭证只有cA，相同的cA在不同的时间可以兑换不同数量的A币，这就是该项目产生收益和亏损的直接原因。</p>
<h3 id="利率模型"><a href="#利率模型" class="headerlink" title="利率模型"></a>利率模型</h3><h4 id="利息的产生"><a href="#利息的产生" class="headerlink" title="利息的产生"></a>利息的产生</h4><p>每一个资产操作前都要进行的刷新利率&#x2F;利息，合约内的数据变动是这样的：</p>
<p>$interestAccmulated &#x3D; totalBorrow \times borrowRate \times deltaBlock $</p>
<p>$totalBorrowNew &#x3D; totalBorrow + interestAccmulated$ </p>
<p>$totalReservesNew &#x3D; totalReserves + reservesFactor \times interestAccmulated $</p>
<p>$borrowIndexNew &#x3D; borrowIndex + borrowIndex \times borrowRate \times deltaBlock$</p>
<p>borrowRate是借款利率(后面细说来源)，reservesFactor是market设置的中介费系数，通常比较低。</p>
<p>borrowIndex是用来调节借款者利息的标记位，初始值为1。</p>
<p>我们可以看到如果不动任何资产，</p>
<p>对于cA持有者，也就是A的存款者来说，每一次刷新之后totalBorrow - totalReserves 就会变大，exchangeRate就会变大，那么每一个A兑换的cA 变少了，持有cA 的人在取款时可以收到比存取时更加多的A币。</p>
<p>对于A的借款者来说，他的利息通过borrowIndex控制，每次还款和借款都会更新，具体如下：</p>
<p>$borrowAmount &#x3D; \frac {principal \times borrowIndexA} {borrowIndexB}$</p>
<p>其中，principal为该账户借款的目前更新前记账数值数值，borowIndexA为整个A market现在的borrowIndex，borrowIndexB是上一次借款时的borrowIndexA，他的借款额也就更新到账户上了。需要还掉的借款变多了。</p>
<h4 id="利率的计算"><a href="#利率的计算" class="headerlink" title="利率的计算"></a>利率的计算</h4><p>compound的利率模型其实就是一个核心观念：市场使用率(utilizationRate)</p>
<p>$utilizationRate &#x3D; \frac{borrows}{cash+borrows-reserves}$</p>
<p>使用率越高，我们的意愿是引入更多的存款者，限制更多的借款者，也就是利息越高，这时我们看借款利率：</p>
<p>$borrowRatePerBlock &#x3D; baseRatePerBlock + utilizationRate \times multiplierPerBlock$</p>
<p>baseRatePerBlock和multiplierPerBlock，都由模型自己指定，作为配合市场利用率的参数。</p>
<p>实际上compound并不需要一个计算存款利率的函数，只是通过记录exchangeRate来获利，但是我们依然可以算出来</p>
<p>$supplyRatePerBlock &#x3D; borrowRatePerBlock \times utilizationRate \times (1 - reserversFactor)$</p>
<h3 id="激励模型"><a href="#激励模型" class="headerlink" title="激励模型"></a>激励模型</h3><p>compound的激励代币称为Comp，激励发生在每次资产交易中，分为两种，一种发放给存款人，一种发放给借款人，量的大小由该用户的持有量&#x2F;借款和总量的比例决定，每一个market在一个区块里发放的激励comp是固定的，存款激励和借款激励的比例也是固定的，分别称为supplySpeed和borrowSpeed，先从这两个式子讲起</p>
<p>$SupplyIndexNew &#x3D; SupplyIndex + \frac{deltaBlocks \times SupplySpeed} {totalSupply}$</p>
<p>$BorrowIndexNew &#x3D; BorrowIndex + \frac{deltablock \times BorrowSpeed}{\frac{totalBorrows}{borrowIndex}}$</p>
<p><small>在此模块里，BorrowIndex和BorrowIndex指在激励系统中标记借款激励的参数，而borrowIndex是指前文提到的利息参数。</small></p>
<p>这是每个market共用的激励记录公式，每一次激励都会刷新的两个参数，分别是SupplyIndex和BorrowIndex，每一组绑定一个market，表示该market的整体激励状态。看起来有点抽象是吧，我们再看下边两个给用户分配激励的公式：</p>
<p>$SupplierAccruedNew &#x3D; SupplierAccrued + cToken.balanceOf(user) \times (SupplyIndex - SupplierIndex)$</p>
<p>$BorrowerAccruedNew &#x3D; BorrowerAccruced + \frac{cToken.borrowBalance(user) } {borrowIndex} \times (BorrowIndex - BorrowerIndex)$</p>
<p>SupplierIndex和BorrowerIndex是上次user做出对应交易时，该market的SupplyIndex和BorrowIndex。</p>
<p>SupplyIndex - SupplierIndex则代表着这次操作中，每持有一个cToken，获得的激励量。</p>
<p>举个例子在某区块totalSuppy &#x3D; 10000，小张操作资产得到激励，此时距离上次刷新的x区块又产生了100个区块，speed &#x3D; v，小张持有量为100，现在开始刷新SupplyIndex，</p>
<p>$SupplyIndex1 &#x3D; SupplyIndex + \frac{100v}{10000}$</p>
<p>又过了100个区块，小张操作资产再次获得激励，其余均不变，这时的</p>
<p>$SupplyIndex2 &#x3D; SupplyIndex1 + \frac{100v}{10000}$</p>
<p>$SupplierIndex &#x3D; SupplyIndex1$</p>
<p>$SupplierAccruedNew &#x3D; SupplierAccrued + 100 \times \frac{100v}{10000}$</p>
<p>这次获得的新激励是$\frac{balance}{totalSupply} \times speed \times deltaBlock$，确实和我们预想的一样。</p>
<p>就是这样，完成了激励的分配，不多不少，刚好分完。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>compound的经济模型大概就是这样了，新人初稿，大家海涵，如有错漏请多指教小弟。下一篇可能是compound源码解析或者是AMM模型，最后祝大家财运昌隆！</p>
]]></content>
      <categories>
        <category>DeFi</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解EVM - Part 4 - Geth中存储区的实现</title>
    <url>/2022/06/25/Digging-Deep-EVM-Part4/</url>
    <content><![CDATA[<p>原文链接：<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-5a5?s=r">https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-5a5?s=r</a></p>
<p>这是“深入理解EVM”系列的第四期。在<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?s=">第三期</a>中我们了解了合约存储相关的知识，这期会说明以太链的“世界状态”是怎么容纳单个合约的存储区的。为此我们需要审视以太链的体系结构和数据结构，一探Geth客户端深处的秘密。</p>
<p>我们从以太区块的数据开始，反推回特定合约存储区。再用Geth如何实现SSTORE与SLOAD收尾。需要了解的知识有很多，我们会介绍Geth代码库，讲讲以太坊的世界状态，让你对EVM有一个更深的了解。</p>
<h2 id="以太坊体系结构"><a href="#以太坊体系结构" class="headerlink" title="以太坊体系结构"></a>以太坊体系结构</h2><p>我们从下图开始，不要有恐惧心理，在文章的结尾你会对它有一个全面的认识，这里画出了以太坊的体系结构和以太链的数据。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff6f48734-3cd7-42a0-a2dd-8f09fdd8a90e_1048x728.png"><img src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff6f48734-3cd7-42a0-a2dd-8f09fdd8a90e_1048x728.png" alt="img"></a>以太坊体系结构 - 来源： <a href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture">Zanzu</a></p>
<p>相比看整个的图，我们不如一块一块看。现在我们看一下第N块的区块头和它包含的字段。</p>
<h3 id="区块头"><a href="#区块头" class="headerlink" title="区块头"></a>区块头</h3><p>区块头包含以太区块的关键信息，下边的第N块区块头就划分出了这些信息。看看以太坊<a href="https://etherscan.io/block/14698834">第14698834块</a> 是否有下图的字段吧。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1e081473-12c5-4b01-ab0b-5f1ec1db106d_482x231.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1e081473-12c5-4b01-ab0b-5f1ec1db106d_482x231.png" alt="img"></a></p>
<p>区块头包含以下字段：</p>
<ul>
<li>Prev Hash - 父区块的Keccak 哈希</li>
<li>Nonce - 用于PoW计算，检验区块是否被成功挖出</li>
<li>Timestamp - UNIX时间戳</li>
<li>Uncles Hash - 叔叔节点的Keccak 哈希</li>
<li>Beneficiary - 收款人地址，矿工费接收者</li>
<li>LogsBloom - 布隆过滤器，提取自receipt，用于查找交易回执中的智能合约事件信息。</li>
<li>Difficulty - 表示当前区块的挖出难度</li>
<li>Extra Data - 最长32字节的自定义信息，由矿工自定义</li>
<li>Block Num - 区块高度</li>
<li>Gas Limit - 每个区块允许的最大gas量</li>
<li>Gas Used - 该区块实际消耗的gas量</li>
<li>Mix Hash - PoW验证时使用，代表区块不含nonce时的哈希值</li>
<li><em><strong>State Root - 执行完此区块中的所有交易后以太坊中，所有账户状态的默克尔树根哈希值</strong></em></li>
<li>Transaction Root - 交易生成的梅克尔树的根节点哈希值。</li>
<li>Receipt Root - 交易回执生成的梅克尔树的根节点哈希值。</li>
</ul>
<p>让我们看看这些和Geth代码的对应关系，<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/types/block.go#L70">block.go</a>里定义的“Header”结构体就代表一个区块头。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F35765b7d-a78d-4350-86b7-02925e25b35a_3226x1178.png"><img src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F35765b7d-a78d-4350-86b7-02925e25b35a_3226x1178.png" alt="img"></a>代码地址： <a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/types/block.go">go-ethereum&#x2F;core&#x2F;types&#x2F;block.go</a></p>
<p>我们可以看到代码里声明的变量是和上边的概念图匹配的，我们的目标是从从区块头一路找到合约存储区。为此我们要关注被标红的“State Root”字段</p>
<h3 id="状态根"><a href="#状态根" class="headerlink" title="状态根"></a>状态根</h3><p>“状态根(State Root)”是一个梅克尔根，它取决于其下所有的数据块，任何一块数据的变动都会改变它。这个状态树的数据结构是MPT，叶子结点存储这网络上每一个以太坊账户的数据。该数据为k-v结构，key是地址，value是账户信息。</p>
<p><em>实际上key是地址的哈希值而value是账户信息的RLP编码，但是我们可以暂时忽略这件事</em></p>
<p>以太坊体系结构图的这一部分正是代表了状态根的MRT。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fd1cf36d8-9880-4aa1-9b7b-a4176273d210_178x258.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fd1cf36d8-9880-4aa1-9b7b-a4176273d210_178x258.png" alt="img"></a></p>
<p>MPT是一种复杂的数据结构，我们这篇文章不做深究。如果你对MPT感兴趣的话建议看<a href="https://medium.com/shyft-network-media/understanding-trie-databases-in-ethereum-9f03d2c3325d">这篇文章</a>。接下来我们重点看看以太坊的账户信息是如何映射到地址的。</p>
<h3 id="以太坊账户"><a href="#以太坊账户" class="headerlink" title="以太坊账户"></a>以太坊账户</h3><p>以太坊账户由以下四项构成：</p>
<ul>
<li>Nonce - 账户的交易数</li>
<li>Balance - 账户余额</li>
<li>Code Hash - 合约账户的所执行的代码，一旦被初始化就是只读的。</li>
<li>Storage Root - 存储根，该值随着合约的存储区的增加、删除、改动而不断变更</li>
</ul>
<p>(译者注：后两项是合约账户拥有的数据段，普通账户并没有)</p>
<p>我们在之前以太坊体系结构图的这一段可以看到：</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F0f0b898c-8fb1-469a-9fb1-0346ccbae601_409x57.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F0f0b898c-8fb1-469a-9fb1-0346ccbae601_409x57.png" alt="img"></a></p>
<p>现在我们去看看Geth的代码，找到对应的 <a href="https://github.com/ethereum/go-ethereum/blob/b1e72f7ea998ad662166bcf23705ca59cf81e925/core/types/state_account.go#L27">state_account.go</a> ，这个StateAccount结构体就是“以太坊账户”。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F630df44e-bdab-41b9-8894-f09be4a09ea7_2122x574.png"><img src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F630df44e-bdab-41b9-8894-f09be4a09ea7_2122x574.png" alt="img"></a>代码地址： <a href="https://github.com/ethereum/go-ethereum/blob/b1e72f7ea998ad662166bcf23705ca59cf81e925/core/types/state_account.go">go-ethereum&#x2F;core&#x2F;types&#x2F;state_account.go</a></p>
<p>可以看到代码里声明的变量与概念图对应上了。接下来我们需要探讨以太坊账户的存储根。</p>
<h3 id="存储根"><a href="#存储根" class="headerlink" title="存储根"></a>存储根</h3><p>存储根(storage root)很像状态根，在它的下面是另一棵MPT。区别就是这次的key是存储插槽，而value是插槽里的数据。</p>
<p><em>跟状态根一样，key其实是哈希值而value是RLP编码</em></p>
<p>以太坊体系结构图的这一部分正是代表了存储根的MRT。</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F18d30b84-5853-4505-9466-a8c2804be40e_196x260.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F18d30b84-5853-4505-9466-a8c2804be40e_196x260.png" alt="img"></a></p>
<p>存储根是一个梅克尔根，任何合约存储区的数据的改变都会改变存储根的值，从而影响区块头的值。现在我们知道怎么从区块找到合约存储区了。下一步我们继续研究Geth的代码，看看存储区是怎么初始化的，以及调用SSTORE和SLOAD是会发生什么。这会帮助你找到底层opcode和solidity代码之间的联系。</p>
<h3 id="StateDB-→-stateObject-→-StateAccount"><a href="#StateDB-→-stateObject-→-StateAccount" class="headerlink" title="StateDB → stateObject → StateAccount"></a>StateDB → stateObject → StateAccount</h3><p>我们需要一个全新的合约，全新的合约意味着StateAccount也是全新的。</p>
<p>开始之前我们看三个结构：</p>
<ul>
<li>StateAccount<ul>
<li>StateAccount 是以太坊账户的一致化表达</li>
</ul>
</li>
<li>stateObject<ul>
<li>stateObject 代表着尚未被修改的以太坊账户</li>
</ul>
</li>
<li>StateDB<ul>
<li>StateDB 存储梅克尔树的所有数据，用于检索合约和以太坊账户的查询接口</li>
</ul>
</li>
</ul>
<p>我们看看这三个结构的内在关系：</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fc0e579c8-adb2-4679-9744-03c4bd3c1182_2002x1572.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fc0e579c8-adb2-4679-9744-03c4bd3c1182_2002x1572.png" alt="img"></a>StateDB → stateObject → StateAccount</p>
<ol>
<li><a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/statedb.go#L64">StateDB struct</a>, 我们可以看到它有一个stateObjects字段，是地址到stateObject的映射集(牢记状态根的MPT是地址到以太坊账户的映射，而stateObject是尚未修改的以太坊账户)。</li>
<li><a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L66">stateObject struct</a>, 我们可以看到它包含一个StateAccount字段，这是一个代码实现里的中间态。</li>
<li><a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/types/state_account.go#L29">StateAccount struct</a>, 现在我们终于看到这个代表以太坊账户的结构了，它的Root字段就是我们之前讨论的存储根。</li>
</ol>
<p>现在一些令人疑惑的东西逐渐明晰了起来，我们看一看新的以太坊账户，或者说StateAccount是怎么初始化的。</p>
<h3 id="Initalising-A-New-Ethereum-Account-StateAccount"><a href="#Initalising-A-New-Ethereum-Account-StateAccount" class="headerlink" title="Initalising A New Ethereum Account (StateAccount)"></a>Initalising A New Ethereum Account (StateAccount)</h3><p>我们需要操作<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/statedb.go">statedb.go</a>以及它的StateDB结构体去创建新的StateAccount。StateDB有一个名为createObject的函数，它会创建一个新的stateObject然后放进去一个空的StateAccount。</p>
<p>下图是代码细节：</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F5b2cc945-1634-4315-9adc-f5a2a147406e_3296x1104.png"><img src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F5b2cc945-1634-4315-9adc-f5a2a147406e_3296x1104.png" alt="img"></a></p>
<ol>
<li>StateDB有一个 <a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/statedb.go#L575">createObject 函数</a> ，传入一个地址返回一个stateObject。(重申stateObject是一个未修改的以太坊账户)。</li>
<li>这个createObject函数调用<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L102">newObject 函数</a> ，它传入stateDB，地址和一个空的StateAccount，返回一个stateObject。</li>
<li>在newObject函数的返回语句中，我们可以看到有许多字段与stateObject, address, data, dirtyStorage等相关</li>
<li>tateObject的data映射到空的StateAccount，可以在103-111行看到从nil值转变为初始化空值的过程。</li>
<li>stateObject被成功创建并带着已经初始化完成的StateAccount(也就是data字段)返回了。</li>
</ol>
<p>现在我们有了一个空stateAccount，下一步我们存些数据吧，用SSTORE。</p>
<h2 id="SSTORE"><a href="#SSTORE" class="headerlink" title="SSTORE"></a>SSTORE</h2><p>在深入了解SSTORE的Geth实现之前我们先回忆一下SSTORE是干什么的。</p>
<p>SSTORE会从栈上弹出两个值，一个32字节的key，一个32字节的value。key决定了value存在哪个插槽里。</p>
<p>下面就是Geth的SSTORE操作的源码，我们看看他做了什么：</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F8b9e61f6-7a74-48db-9c07-b2a3717bd3b5_2882x1762.png"><img src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F8b9e61f6-7a74-48db-9c07-b2a3717bd3b5_2882x1762.png" alt="img"></a></p>
<ol>
<li>我们从 <a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/instructions.go#L524">instructions.go</a>开始看，它定义了所有的opcode，在这个文件里我们可以看到opSstore函数。</li>
<li>这个函数的入参包括合约上下文信息，例如栈，内存等，我们把两个值弹出栈，标记成loc(location)和val(value)。</li>
<li>这两个值被弹出来后作为入参和合约地址一起传进<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/statedb.go#L414">StateDB的SetState 函数</a>，SetState会用合约地址检验合约里是否有stateObject如果没有就创建一个。之后调用stateObject的SetState，传进StateDB，key和value。</li>
<li><a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L245">stateObject的SetState 函数</a>对fakeStorage做了检查，看看value是否被改变过，之后运行journal的append函数。</li>
<li>如果你阅读<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/journal.go#L38">journal struct</a>的注释会看到journal是用来跟踪状态的改变(就是保存中间变量)，这样它们就可以在执行异常或撤销请求的情况下恢复。</li>
<li>journal更新之后，调用<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L245">stateObject的SetState 函数</a>。更新stateObject.dirtyStorage。</li>
</ol>
<p>现在我们已经更新了stateObject 的 dirtyStorage。而这究竟意味着什么呢？与我们学的东西有什么关系吗？</p>
<p>让我们看看定义dirtyStorage的代码</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe62db976-b29d-4803-af46-22bc577d5755_2210x1794.png"><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe62db976-b29d-4803-af46-22bc577d5755_2210x1794.png" alt="img"></a>dirtyStorage → Storage → Hash → 32-byte</p>
<ol>
<li>dirtyStorage是在<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L66">stateObject</a>里定义的，被描述为”在当前事务执行中被修改的存储项”。</li>
<li>dirtyStorage的类型<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L41">Storage type</a>是一种从common.Hash到common.Hash的映射。</li>
<li><a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/common/types.go#L49">Hash type</a> 就是一个长度为HashLength的字节数组</li>
<li><a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/common/types.go#L36">HashLength</a>是常量，值是32。</li>
</ol>
<p>32字节key到32字节value的映射对你来说应该很熟悉，这完全就是<a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?utm_source=/profile/80455042-noxx&utm_medium=reader2&s=r">第三篇</a>我们提到过的合约存储区的概念。你现在可能注意到dirtyStorage字段上边的pendingStorage和originStorage了。他们是有相关性的，dirtyStorage在确定写入的过程中，会复制到pendingStorage，然后在MPT更新时复制到originStorage。MPT更新了之后，StateDB的commit过程中StateAccount的状态根也会更新。会将新的状态写进MPT的底层数据库。</p>
<p>下面轮到最后一个难点，SLOAD。</p>
<h2 id="SLOAD"><a href="#SLOAD" class="headerlink" title="SLOAD"></a>SLOAD</h2><p>我们快速回忆一下SLOAD是干什么的：它会把一个32字节的key从栈里弹出来，然后返回key对应的插槽里的值。下面看一下Geth实现SLOAD的代码：</p>
<p><a href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F991e7cec-54bd-41b2-afe4-247144fea091_3430x1316.png"><img src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F991e7cec-54bd-41b2-afe4-247144fea091_3430x1316.png" alt="img"></a></p>
<ol>
<li>我们依然从<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/instructions.go#L516">instructions.go file</a> 开始，找到opSload函数，我们从栈顶获取到了存储插槽。也就是临时变量loc。</li>
<li>调用<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/statedb.go#L308">StateDB的GetState函数</a>传入合约地址和存储位置，GetState获得了合约地址对应的stateObject，如果它不为空，则调用<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L172">stateObject的GetState函数</a>。</li>
<li><a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L172">stateObject的GetState函数</a>对fakeStorage和dirtyStorage做检查。</li>
<li>如果dirtyStorage存在，则返回key在dirtyStorage映射里的值(dirtyStorage代表着合约的最新状态，所以要最先返回它)。</li>
<li>否则将调用<a href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L187">GetCommitedState 函数</a>里查询数据，再次检验fakeStorage。在这个函数里完成下面两步。</li>
<li>如果pendingStorage存在，则返回key在pendingStorage映射里的值。</li>
<li>如果上边的都没有，就检索originStorage里的值并返回。</li>
</ol>
<p>你会发现函数最先试图返回dirtyStorage，然后依次是pendingStorage和originStorage。这是合情合理的，在运行的过程中dirtyStorage是最新状态，紧接着是pendingStorage和originStorage。一个交易可能多次改变同一个插槽的数据所以我们必须保证拿到的是最新的值。</p>
<p>让我们设想在同一笔交易里，SLOAD之前在同一个插槽发生了SSTORE操作，在这种情况下dirtyStorage是被SSTORE更新过的，SLOAD返回的正应该是它。</p>
<p>现在您已经了解了Geth是如何实现SSTORE和SLOAD的。它们如何与状态和存储区交互，以及如何更新插槽与世界状态相关的知识。</p>
<p>这篇文章的强度很大但是你坚持下来了，我猜这篇文章会让你的问题比刚开始更多了，但这正是加密世界的乐趣不是吗？</p>
<p>只要功夫深，铁杵磨成针！</p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>入门Defi第一步，初识DEX,AMM与LP token</title>
    <url>/2022/06/13/Intro-DEX-AMM-LP-Token/</url>
    <content><![CDATA[<h2 id="DEX是什么？"><a href="#DEX是什么？" class="headerlink" title="DEX是什么？"></a>DEX是什么？</h2><p>​		DEX(Decentralized Exchange)，即去中心化交易所，不依赖券商、银行等金融机构提供金融工具，而是利用区块链上的智能合约就可以提供交易服务的交易所。例如Uniswap，Curve，Pancake等等。</p>
<h2 id="DEX与传统交易所"><a href="#DEX与传统交易所" class="headerlink" title="DEX与传统交易所"></a>DEX与传统交易所</h2><p>​		DEX和传统交易所的区别并不只在于数据存储的方式和所有权不同，在交易方式和原理上也有着本质的区别。我们以最常见的DEX框架即AMM模型与传统交易所挂单模型对比：</p>
<h3 id="两种交易所订单簿模型的区别："><a href="#两种交易所订单簿模型的区别：" class="headerlink" title="两种交易所订单簿模型的区别："></a>两种交易所订单簿模型的区别：</h3><p>中心化交易所：<img src="https://fintechruminations.com/wp-content/uploads/2021/07/Screenshot-2021-07-09-at-17.12.18-1024x887.png" alt="img" style="zoom:30%;" />DEX：<img src="https://fintechruminations.com/wp-content/uploads/2021/07/Screenshot-2021-07-09-at-17.12.24-1024x500.png" alt="img" style="zoom:33%;" /><br>中心化交易所的卖方在交易所挂单，买方通过交易所自动撮合下单购买。<br>DEX的不存在买方和卖方的差异，其本质也不是购兑换对方的资产，而是直接从流动性资产池中换取需要的资产。<br>        <small>流动性资金池(liquidity pools)：用户交易使用的资产池，其中的资金由用户提供，提供资金的行为被称为提供流动性(add liquidity)。为了保证交易稳定、流动性充足，提供流动性的用户(liquidity provider)可以从每笔交易的手续费里提取分成作为奖励。</small></p>
<h3 id="两种方案的优劣比较："><a href="#两种方案的优劣比较：" class="headerlink" title="两种方案的优劣比较："></a>两种方案的优劣比较：</h3><table>
<thead>
<tr>
<th>中心化交易所</th>
<th>DEX</th>
</tr>
</thead>
<tbody><tr>
<td>审查身份</td>
<td>不审查身份</td>
</tr>
<tr>
<td>手续费只存在于执行交易时</td>
<td>每一步操作都需要手续费</td>
</tr>
<tr>
<td>数据中心化，放在服务器</td>
<td>数据去中心化，放在区块链</td>
</tr>
<tr>
<td>交易迅速</td>
<td>交易缓慢</td>
</tr>
<tr>
<td>巨鲸操盘，交易所黑幕</td>
<td>套利机器人日夜巡逻</td>
</tr>
</tbody></table>
<p>​		<small>存在DEX像0x协议这样使用零知识证明原理，实现“链上+链下”结合的方式实现挂单模型，在下文中DEX特指使用AMM的去中心化交易所</small></p>
<h2 id="AMM和LP-token是什么？"><a href="#AMM和LP-token是什么？" class="headerlink" title="AMM和LP token是什么？"></a>AMM和LP token是什么？</h2><h3 id="AMM"><a href="#AMM" class="headerlink" title="AMM:"></a>AMM:</h3><p>​		AMM即Automated Market Maker，自动化做市商。AMM应用在DEX中，使得买方和卖方之间不需要任何信任关系以及第三方就可以安全完成交易。AMM用户的买&#x2F;卖本质上是在对相应资产的流动性资金池做兑换，而非买卖双方的动作。所以AMM天生适合去中心化交易所使用，只要资金池和定价模式完全依托去中心化平台，就没有任何单独实体可以操纵这个系统，同时每个人都可以在这个基础上建立新的应用。</p>
<h3 id="LP-token"><a href="#LP-token" class="headerlink" title="LP token:"></a>LP token:</h3><p>​		LP token即(Liquidity Provider Token)，对于AMM来说，x - y两种资产的兑换需要一个x - y 的资金池，而x，y两种资产由用户提供。用户把x和y资产质押进流动性以获取流动性挖矿(yield farming )奖励，而质押的凭证就是AMM给流动性提供者签发的一种新代币，称为LP token。<br>​		在DeFi飞速发展的过程中，DeFi的术语也在不断。很多情况下LP token具体叫什么是随着项目变化的。比如在Balancer中，通常被称为BPT或者pools tokens；在Uniswap里被称为liquidity tokens或者pool tokens，在Curve中被称为LP token。</p>
<h2 id="AMM的原理"><a href="#AMM的原理" class="headerlink" title="AMM的原理"></a>AMM的原理</h2><p>​		AMM发展至今已经落地在不少应用中，虽然具体实现方法和应用场景略有差别，但很多以简单模型为基础改进，本节将以其代表项目UniswapV2为例讲解。各种改进算法将不做讨论<br>AMM实现功能靠以下两个核心功能：</p>
<h3 id="Swaps"><a href="#Swaps" class="headerlink" title="Swaps:"></a>Swaps:</h3><p>​		AMM的token交换基于流动性资金池和恒定乘积公式算法：$x \times y &#x3D; k$，即交易发生在 （卖出资产- 买入资产）交易对的流动性资金池中，交易价格由恒定乘积公式决定。<br>x，y为资金池中两种资产的量：<br><img src="https://lh3.googleusercontent.com/DlgPwa6IlYeRgPkAPdwHPY7P0UCGMSiiESzvhCpUUSFuJ0HhFWG3rV1FSxEb_RFyV1JfdBQ1MUjVkzO8yDmJQXf-O0Ym0UWj-CM5xla9hARaA0kY6D6tSDhsYVhVkhbDrOj2-WHv" alt="img" style="zoom:50%;" /></p>
<p>​		例如在一个$x &#x3D; 200$, $y &#x3D; 300$的资金池内想用100个y来兑换x，那么有$(y+100)\times (x- \delta x) &#x3D; x \times y$，可解兑换出50个x资产。一个池子内，x越少，就可以用x换取更多的y，反之亦然，套利者会自发将两者价格与全链同步，这就是swap的基本原理。<br>​		那么K值是否能够改变呢？答案是肯定的，因为手续费和流动性的原因，几乎每一笔交易成功实际发生后，k都会改变。所谓的固定乘积，是交易发生前计算价格的方法。</p>
<h3 id="Liquidity-Pools"><a href="#Liquidity-Pools" class="headerlink" title="Liquidity Pools:"></a>Liquidity Pools:</h3><p>​		AMM的用户不直接与另一个用户发生交易，他们的交易要通过liquidity pools实现，而且因为在AMM的恒定乘积公式算法中，当流动性池内资金量少时，很容易出现x，y有一个非常小导致价格离谱的情况。<br>​		流动性资金池由用户质押资产提供，用户质押资产进入liquidity pools，然后获得质押凭证LP token，而提供流动性的用户也会获得手续费收益，即LP token分红和对应交易所的治理代币。用户也可以使用LP token赎回其质押的资产，被称为移除流动性(remove liquidity)。</p>
<h2 id="流动性挖矿与LP-Tokens"><a href="#流动性挖矿与LP-Tokens" class="headerlink" title="流动性挖矿与LP Tokens"></a>流动性挖矿与LP Tokens</h2><p>​		LP Tokens的一个很引人注目的应用领域就是流动性挖矿(Yield Farming)，将他们两个结合起来，是一种向多个不同合约组合操作以达到收益最大化的挖矿方式，下面举一个Curve中的例子：</p>
<ol>
<li>向Curve 的liquidity pool质押DAI</li>
<li>获得LP tokens</li>
<li>将LP tokens质押进Curve的质押池</li>
<li>获得Curve利息</li>
</ol>
<h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><p><a href="https://fintechruminations.com/2021/07/09/uniswap-and-the-amm-model/">UNISWAP AND THE AMM MODEL</a><br><a href="https://www.gemini.com/cryptopedia/liquidity-provider-amm-tokens">How Liquidity Provider (LP) Tokens Work</a></p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>使用vscode中运行rust单元测试找不到cargo的解决方法</title>
    <url>/2022/07/02/vscode-rust-extension-bug/</url>
    <content><![CDATA[<p>最近在vscode上写rust代码时，插件自带的运行和调试用不了了，说是读不到cargo:</p>
<p><img src="/2022/07/02/vscode-rust-extension-bug/vscode-runtest.png"></p>
<p>一点就会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executing task: cargo test -- --nocapture test_add</span><br><span class="line">&lt; zsh:1: command not found: cargo</span><br></pre></td></tr></table></figure>

<p>我们找到这个插件的位置，再修改一下这个文件，路径里的版本号换成当前使用的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.vscode/extensions/rust-lang.rust-0.7.8/out/src/tasks.js</span><br></pre></td></tr></table></figure>

<p>找到掌管shell初始化的createShellExecution函数：</p>
<p>把这句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cmdLine = <span class="string">`<span class="subst">$&#123;command || binary&#125;</span> <span class="subst">$&#123;args.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>加上加载cargo环境变量，变成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cmdLine = <span class="string">`source $HOME/.cargo/env; <span class="subst">$&#123;command || binary&#125;</span> <span class="subst">$&#123;args.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>就ok了，重启一下就好。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello</title>
    <url>/2022/06/09/hello-world/</url>
    <content><![CDATA[<p>你好呀，我是张钰Alvan，主业是区块链&#x2F;智能合约开发，了解一些defi项目，喜欢芥川龙之介和卡夫卡，希望能和更多的人交朋友！qq1541115709</p>
]]></content>
  </entry>
</search>
