<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Alpaca文档翻译</title>
    <url>/2022/06/13/Alpaca-docs/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>Alpaca
Finance是一个借贷协议，但它和Compound，Aave等单纯等待别人从池子里借款从而分红利息的项目不一样，在这里你不仅可以加上杠杆，还可以主动选择一些心仪的流动性挖矿项目并质押进去，吃到多次利润。</p>
<p>Alpaca Leverage Farming 主要有四个组成部分 1.Vault 2.Worker
3.Strategy 4.Fairlaunch(此模块另行介绍)</p>
<h2 id="architecture">Architecture</h2>
<ul>
<li>前端(Frontend) - Alpaca 前端接口</li>
<li>清算机器人(Liquidator) -
观察仓位状态，一旦出现资不抵债就进行清算的机器人</li>
<li>复投机器人(Reinvestor) - 自动收获利润又复投的机器人</li>
</ul>
<p><img
src="https://alpaca-doc.s3.ap-southeast-1.amazonaws.com/lyf/Export-3aa4ff3c-20f2-4868-95ee-96a4da364889/Contract%20Documentation%204c48a0c0db7442c6aa0268dd110e6b80/Screen_Shot_2564-09-29_at_12.03.52.png" /></p>
<h2 id="vault">Vault</h2>
<p>顾名思义，这个合约用处是存放借款者的抵押物。作为在此时贡献资金池使用率的回报，借款者还可以向Vault申请资金。一个底层资产对应一个Vault合约。</p>
<h2 id="worker">Worker</h2>
<p>worker是一个管理仓位使用方法的合约，使用方法包括但不限于
在一个DEX里开启一个流动性挖矿的仓位 平掉这个仓位 调节这个仓位
每一个worker都对应特定的一些代币和一个特定的DEX，不同的ERC20代币/DEX会使用不同的worker。</p>
<h2 id="strategy">Strategy</h2>
<p>strategy合约是具体操作DEX的合约，每次只处理一个特定场景。可以对动态指定的不同的token做出童谣的DEX操作。</p>
<h2 id="fairlaunch">FairLaunch</h2>
<p>这是Alpaca的激励组件，可以接收ERC20然后给各个token池生成Alpaca代币，每个池子的发放量存在差异</p>
<h2 id="contract-document">Contract Document</h2>
<p><a href="#Vault%20Contract">Vault Contract</a> <a
href="#Worker%20Contract">Worker Contract</a> <a
href="#Strategy%20Contract">Strategy Contract</a></p>
<h2 id="dex-integration">DEX Integration</h2>
<p>尽管Alpaca集成了不少不同的DEX，他们之间也在细节上有差别，但是大部分DEX都是基于uniswapV2的机制，在这版文档里我们只讨论与PancakeSwap对接的Worker和Strategy。即以下具体实现：</p>
<h3 id="worker-1">Worker</h3>
<p>PancakeSwap Worker</p>
<h3 id="strategy-1">Strategy</h3>
<p>PancakeswapV2RestrictedStrategyAddBaseTokenOnly Strategy
PancakeswapV2RestrictedStrategyAddTwoSidesOptimal Strategy
PancakeswapV2RestrictedStrategyLiquidate Strategy
PancakeswapV2RestrictedStrategyPartialCloseLiquidateStrategy
PancakeswapV2RestrictedStrategyPartialCloseMinimizeTrading Strategy
PancakeswapV2RestrictedStrategyWithdrawMinimizeTrading Strategy</p>
<h1 id="vault-contract">Vault Contract</h1>
<p><a name="Vault Contract"></a></p>
<p><a
href="https://github.com/alpaca-finance/bsc-alpaca-contract/blob/main/contracts/6/protocol/Vault.sol">合约源码</a></p>
<h2 id="background">Background</h2>
<p>Alpaca
Finance里最重要的一个操作是通过vaults达成的，注意是vaults而非vault，vault被设计成连接存款者和借款者的中间体，存款者把资产储存进vault，借款者可以借出来一些用于流动性挖矿。
存储token的同时，vault会给用户ibToken，用户可以用这个在Alpaca
Finance中进行更多操作，比如获得FairLaunch里的Alpaca激励，获得合作Token激励，以后还有更多。
借出token的同时，用户也可以获得debtToken，这也可以自动获得FairLuanch给的激励。</p>
<h2 id="abstract">Abstract</h2>
<ul>
<li>Vault会给用户分配ibToken，用来标记用户在此vault里所占的份额(share)。随着时间推移，利息会进入份额，1份份额(share)的实际价值会增加。</li>
<li>当用户开仓时，他们先需要在vault里放质押物。这使得vault的债务价值(debt
value)根据借款量增加。</li>
<li>一旦vault收获借款人的利息，vault的债务价值(debt
value)会随着利息增加。这意味着随着时间推移，取出资产需要用到的量要比存款时更大。</li>
<li>当用户平仓时，初始抵押品债务会从总债务中去除，流动性挖矿的利息会完整地还给lender。</li>
<li>部分利息会被项目组留下，放在保留金池子里。</li>
<li>由于用户是在不同的时间存款的，我们要用债务份额价值(debt share
value)保持记录用户从哪里进入vault。</li>
<li>债务份额(debt share)也被表示成vault铸造的生息token。</li>
<li>债务份额的计算方法：<span
class="math inline">\(\frac{DebtValue}{TotalDebtValue} \times
ExistingDebtShare\)</span></li>
</ul>
<h2 id="structs">Structs</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Position &#123;</span><br><span class="line">    address worker;</span><br><span class="line">    address owner;</span><br><span class="line">    uint256 debtShare;</span><br><span class="line">  &#125;</span><br><span class="line">mapping(uint256 =&gt; Position) public positions;</span><br></pre></td></tr></table></figure>
<h2 id="main-function">Main Function</h2>
<p>Vault 主要业务逻辑有： 1.质押token获得ibToken (deposit)
2.赎回token燃烧ibToken (withdraw)
3.执行借贷+DEX流动性挖矿操作，调用worker.work，根据Position里worker的不同具体执行逻辑也不一样
(work)
4.清算，调用worker.liquidate，根据Position里worker的不同具体执行逻辑也不一样
(kill)</p>
<h1 id="worker-contract">Worker Contract</h1>
<p><a name="Worker Contract"></a></p>
<p><a
href="https://github.com/alpaca-finance/bsc-alpaca-contract/blob/main/contracts/6/protocol/interfaces/IWorker02.sol">源码地址</a></p>
<h2 id="background-1">BackGround</h2>
<p>borrowers从vault申请款项唯一的办法就是从vault借出钱来做一些操作，特别是加杠杆的流动性挖矿。
每一个worker根据配置比如其连接的DEX和LP token pair
来进行不一样的操作，但是所有的Worker共用一个接口。
然而worker并不一定要做流动性挖矿，也可能就只是做一些简单的操作，比如Syrup
Pool。 这部分我们只讲一下所有worker共通的Interface。</p>
<h2 id="abstract-1">Abstract</h2>
<ul>
<li>在整个系统里有多个worker</li>
<li>一个worker可以根据实际情况使用不同的strategy</li>
<li>worker会把特定的token对当成整体处理，即使他们在不同的仓里</li>
<li>worker和底层资产服务强关联，比如Pancake的BNB-BUSD
worker处理不了Wault的BNB-BUSD</li>
<li>Base
token是ERC20标准，是worker的主要资产，通常与借款，本金挂钩。</li>
<li>Farm token是ERC20标准，与base token结对可以给DEX提供流动性</li>
<li>worker把Fram token和Base token成对处理，如果我们需要将现在的farm
token作为base
token就需要另一个worker，反之亦然。因为在DEX中，Pancake的BNB-BUSD 也与
Pancake的BUSD- BNB不一样。</li>
<li>Worker Config作为一个分离出来的合约，存放着worker们的配置信息</li>
</ul>
<p>worker可以被两种角色调用： 1.Operator: 大多数情况是一个Vault合约
2.Reinvestor: 白名单EOA，取出LP收益再复投</p>
<h2 id="main-function-1">Main Function</h2>
<p>1.利息复投(_reinvest) 2.调用Strategy的excute方法，并将返回的LP
token质押，根据Strategy种类不同具体实现不一样 (work)
3.计算某个position换算成baseToken的价值，用来做清算判断 (health)</p>
<h1 id="strategy-contract">Strategy Contract</h1>
<p><a name="Strategy Contract"></a></p>
<p><a
href="https://github.com/alpaca-finance/bsc-alpaca-contract/blob/main/contracts/6/protocol/interfaces/IStrategy.sol">合约源码</a></p>
<h2 id="background-2">Background</h2>
<p>顾名思义，这类合约只做一件事，那就是制定交易策略，根据DEX，token和需求不同分配不同的Strategy。这一节我们详细介绍策略逻辑和公式。值得注意的是，这个合约是一个耦合度极低的合约，只负责把传给该合约的资产在DEX中操作，再转账，几乎没有存储任何信息，也就是不参与借贷相关的任何逻辑。借贷/还账的逻辑应该在它的上层实现。</p>
<h2 id="abstract-2">Abstract</h2>
<p>根据用户的操作，前端会提供一个strategy，比如一个用户想借BUSD在Pancake开一个BUSD-
USDT的仓，前端会用PancakeswapV2RestrictedStrategyAddBaseTokenOnly(一种Strategy合约)调用Vault.work，这样Vault将会调用USDT-
BUSD PancakeSwap
的worker。worker随后调用PancakeswapV2RestrictedStrategyAddBaseTokenOnly.</p>
<h2 id="main-function-2">Main Function</h2>
<p>有六种Strategy都只有一个主要方法,excute：</p>
<h3 id="addbasetokenonly">AddBaseTokenOnly:</h3>
<p>提供base token，根据最佳方案兑换farming
token，再提供流动性拿LP，推导过程：
balance为托管处理的baseToken总量，aIn为swap为farming token的base
token，rIn，rOut是池子里的量</p>
<p><span class="math inline">\(\begin{cases} rIn\times rOut = (rIn +
aIn)\times(rOut - aOut)\\ \frac{rIn}{rOut} = \frac{balance - aIn}{ aOut
}\\ \end{cases}\)</span></p>
<p>得出<span class="math inline">\(aIn^{2} + 2rIn\times aIn - rIn\times
balance = 0\)</span>，即<span
class="math inline">\(aIn=\frac{\sqrt{rIn\times (4balance +
4rIn)}-2rIn}{2}\)</span> 与代码吻合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 aIn = AlpacaMath.sqrt(rIn.mul(balance.mul(399000000).add(rIn.mul(399000625)))).sub(rIn.mul(19975)) / 19950;</span><br></pre></td></tr></table></figure>
<h3 id="addtwosideoptimal">AddTwoSideOptimal</h3>
<p>同时提供base token和farming
token，合约转换成正好的比例提供流动性，推导过程:
bIn,bOut是用户提供的两种token量，aIn是打算换成另一种的多余Token量，aOut是换出的token量，
<span class="math inline">\(\begin{cases} rIn\times rOut = (rIn +
aIn)\times(rOut - aOut)\\ \frac{rIn + bIn }{rOut - bOut} =
\frac{bIn-aIn}{bOut+aOut}\\ \end{cases}\)</span></p>
<p>得出<span class="math inline">\(aIn^{2} + 2rIn\times aIn + \frac
{rIn\times bOut - rOut \times bIn}{rOut+bOut} \times rIn = 0\)</span>
即<span class="math inline">\(aIn = \frac{\sqrt{4rIn^{2}-4\times (\frac
{rIn\times bOut - rOut \times bIn}{rOut+bOut} \times
rIn)}-2rIn}{2}\)</span> 与代码吻合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// @dev Compute optimal deposit amount helper</span><br><span class="line">  /// @param amtA amount of token A desired to deposit</span><br><span class="line">  /// @param amtB amonut of token B desired to deposit</span><br><span class="line">  /// @param resA amount of token A in reserve</span><br><span class="line">  /// @param resB amount of token B in reserve</span><br><span class="line">  function _optimalDepositA(</span><br><span class="line">    uint256 amtA,</span><br><span class="line">    uint256 amtB,</span><br><span class="line">    uint256 resA,</span><br><span class="line">    uint256 resB</span><br><span class="line">  ) internal pure returns (uint256) &#123;</span><br><span class="line">    require(amtA.mul(resB) &gt;= amtB.mul(resA), &quot;Reversed&quot;);</span><br><span class="line"></span><br><span class="line">    uint256 a = 9975;</span><br><span class="line">    uint256 b = uint256(19975).mul(resA);</span><br><span class="line">    uint256 _c = (amtA.mul(resB)).sub(amtB.mul(resA));</span><br><span class="line">    uint256 c = _c.mul(10000).div(amtB.add(resB)).mul(resA);</span><br><span class="line"></span><br><span class="line">    uint256 d = a.mul(c).mul(4);</span><br><span class="line">    uint256 e = AlpacaMath.sqrt(b.mul(b).add(d));</span><br><span class="line"></span><br><span class="line">    uint256 numerator = e.sub(b);</span><br><span class="line">    uint256 denominator = a.mul(2);</span><br><span class="line"></span><br><span class="line">    return numerator.div(denominator);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="liquidate">Liquidate</h3>
<p>提供LPToken，取消所有流动性，之后所有farming token 兑换成base token
返还给用户。</p>
<h3 id="partialcloseliquidate">PartialCloseLiquidate</h3>
<p>前面和Liquidate一样，也是把一定量的LP取消流动性，再全兑成base
token提出来，最后留下一部分baseToken(数目是入参，一般做平账用，由合约传入)，剩下的返还给用户。</p>
<h3 id="partialcloseminimizetrading">PartialCloseMinimizeTrading</h3>
<p>提供一定量LPToken，取消流动性，返还base token和farming
token，如果base
token不够lessDebt值(数目是入参，一般做平账用，由合约传入)，用farming
token兑换至足额，并将base token和剩余的farming token返还。</p>
<h3 id="withdrawminimizetrading">WithdrawMinimizeTrading</h3>
<p>把所有的LPToken取消流动性,返还base token和farming token，如果base
token不够lessDebt值(数目是入参，一般做平账用，由合约传入)，用farming
token兑换至足额，并将base token和剩余的farming token返还。</p>
<h1 id="后记">后记</h1>
<p>Alpaca小弟也是最近刚刚接触，如果有前辈研究过这个项目还请指路一下更多的资料，谢谢大家了。</p>
]]></content>
      <categories>
        <category>DeFi</category>
      </categories>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解EVM - Part1 - 初识opcode</title>
    <url>/2022/06/17/Digging-Deep-EVM-Part1/</url>
    <content><![CDATA[<p>原文链接：https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?s=r
译者博客: <a href="alvan.coffee">Alvan的Blog</a></p>
<h3
id="digging-deep-into-the-evm-mechanics-during-contract-function-calls">Digging
deep into the EVM mechanics during contract function calls</h3>
<p>第一性原理我们经常听说，就是着重于理解事物的基本概念从而更好地理解构建与其之上的组件。</p>
<p>在智能合约的世界里，EVM和它的算法与数据结构就是第一性原理，我们写的智能合约就是建立在其之上的组件。要想成为一个优秀的solidity开发，必须要对EVM有深刻了解。</p>
<p>这系列文章的第一要义就是深入理解EVM，构建成为“shadowy super
coder”的基础知识。</p>
<h2 id="the-basics-solidity-bytecode-opcode">The Basics: Solidity →
Bytecode → Opcode</h2>
<p>开始之前，本文嘉定读者是掌握了solidity的基本用法以及怎么部署到以太坊的，后边只会简单提到，如果你想复习一下这部分知识的话请看<a
href="https://medium.com/@eiki1212/explaining-ethereum-contract-abi-evm-bytecode-6afa6e917c3b">这篇文章</a>。</p>
<p>solidity在部署到以太坊网络之前是需要被编译成字节码的，这些字节码又和一系列opcode匹配，这些opcode可以被EVM解释。</p>
<p>这一个系列会着眼于编译后字节码的特定部分并阐释他们的工作机制。在每一篇文章的结尾，你都可以对这些函数更清晰的认知。一路下来，你会学到有关EVM的许多概念。</p>
<p>今天我们就看一个基础的solidity合约，从它的字节码/opcode片段里解释一下EVM是怎么选择函数的。</p>
<p>solidity创造的运行时字节码对应着一整个合约，合约部署之后，其中可能存在多个可以被调用的函数。这里边一个基础问题是EVM怎么根据合约调用的函数知道执行哪些字节码。</p>
<h3 id="storage.sol-breakdown">1_Storage.sol Breakdown</h3>
<p>在demo里我们使用了一个Storage.sol的合约，这是remix生成的默认合约之一。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3400bba6-f870-4b68-8ba8-118562b08aef_489x538.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在这个合约里有两个函数，store(uint256) 和 retrieve()
，当函数调用的时候EVM就必须进行区分，下边就是此合约编译出的字节码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">608060405234801561001057600080fd5b50600436106100365760003560e01c80632e64cec11461003b5780636057361d14610059575b600080fd5b610043610075565b60405161005091906100d9565b60405180910390f35b610073600480360381019061006e919061009d565b61007e565b005b60008054905090565b8060008190555050565b60008135905061009781610103565b92915050565b6000602082840312156100b3576100b26100fe565b5b60006100c184828501610088565b91505092915050565b6100d3816100f4565b82525050565b60006020820190506100ee60008301846100ca565b92915050565b6000819050919050565b600080fd5b61010c816100f4565b811461011757600080fd5b5056fea2646970667358221220404e37f487a89a932dca5e77faaf6ca2de3b991f93d230604b1b8daaef64766264736f6c63430008070033 </span><br></pre></td></tr></table></figure>
<p>我们看一下下面的片段，这个片段就是函数选择器的逻辑，可以用ctrl + f
验证一下它是否在上述字节码中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60003560e01c80632e64cec11461003b5780636057361d1461005957</span><br></pre></td></tr></table></figure>
<p>这段字节码对应一系列的opcode与其输入值，你可以在<a
href="https://www.ethervm.io/">这里</a>查看EVM的opcode列表。opcode的长度为1个字节也就是最多支持256种opcode，现在EVM已使用140种。</p>
<p>下边展示了字节码所对应的opcode，它们会在EVM的调用战(call
stack)中逐条执行。比如你可以从上边的链接里找到字节码 60 代表着opcode
PUSH1等等。在这篇文章的结尾，你会对它们有一个全面的认知。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60 00                       =   PUSH1 0x00 </span><br><span class="line">35                          =   CALLDATALOAD</span><br><span class="line">60 e0                       =   PUSH1 0xe0</span><br><span class="line">1c                          =   SHR</span><br><span class="line">80                          =   DUP1  </span><br><span class="line">63 2e64cec1                 =   PUSH4 0x2e64cec1</span><br><span class="line">14                          =   EQ</span><br><span class="line">61 003b                     =   PUSH2 0x003b</span><br><span class="line">57                          =   JUMPI</span><br><span class="line">80                          =   DUP1 </span><br><span class="line">63 6057361d                 =   PUSH4 0x6057361d     </span><br><span class="line">14                          =   EQ</span><br><span class="line">61 0059                     =   PUSH2 0x0059</span><br><span class="line">57                          =   JUMPI  </span><br></pre></td></tr></table></figure>
<h3 id="smart-contract-function-calls-calldata">Smart Contract Function
Calls &amp; Calldata</h3>
<p>在深挖opcode之前需要快速过一遍我们究竟是怎么调用函数的。当我们调用一个合约函数时，需要包含有函数签名和所需参数的calldata。可以在solidity里完成:</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fa9957ce1-945b-4afa-a395-c9d2563d2094_1614x670.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>这里我们调用了合约的store函数，参数为10。我们使用abi.encodeWithSignature()获得calldata，emit会记录用于测试的calldata。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x6057361d000000000000000000000000000000000000000000000000000000000000000a</span><br></pre></td></tr></table></figure>
<p>上边就是abi.encodeWithSignature("store(uint256)", 10)
返回的字节码</p>
<p>之前提到了函数签名，现在我们再明确一下：</p>
<blockquote>
<p>函数签名就是函数规范化表示的Keccak Hash的前四个字节。</p>
</blockquote>
<p>函数标准化表示其实就是函数名+参数类型，就像 “store(uint256)” 和
“retrieve()”。你可以在<a
href="https://emn178.github.io/online-tools/keccak_256.html">这里</a>验证一下store(uint256)的hash。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keccak256(“store(uint256)”) →  first 4 bytes = 6057361d</span><br><span class="line"></span><br><span class="line">keccak256(“retrieve()”) → first 4 bytes = 2e64cec1</span><br></pre></td></tr></table></figure>
<p>我们可以看到calldata有36个字节)，前四字节对应着我们刚刚计算出来的
store(uint256)
函数签名，剩下的32个字节对应着传入的uint256参数，一个16进制的a，也就是10进制的10.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6057361d = function signature (4 bytes)</span><br><span class="line"></span><br><span class="line">000000000000000000000000000000000000000000000000000000000000000a = uint256 input (32 bytes)</span><br></pre></td></tr></table></figure>
<p>我们获得了函数选择器 6057361d，你可以ctrf +
f去opcode那一段确认一下。</p>
<h3 id="opcodes-the-call-stack">Opcodes &amp; The Call Stack</h3>
<p>现在关于EVM的函数选择器的前置知识已经学完了，现在正式开始。首先要过一遍每一个opcode和它们对调用栈的操作。如果你不熟悉栈的话可以看一下这个<a
href="https://www.youtube.com/watch?v=FNZ5o9S9prU">视频</a>。</p>
<p>PUSH1代表着把下一个字节(0x00也就是十进制0)的数据压入调用栈中，下一个opcode我们可以知道这么做的理由。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F52e45eff-44b3-4028-a075-9f5591fd2e7e_900x151.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>接下来用CALLDATALOAD弹出栈顶元素stack(0)作为该命令的输入值。</p>
<p>这个opcode要把calldata载入调用栈，而输入值(也就是上边弹出的值)是偏移量(offset)，我们设为i。栈元素是32字节，而calldata是36字节，要压入的数据就是msg.data[i:i+32]
(译者注:msg.data就是完整的calldata)，这既保证了只有32字节压栈，又允许我们访问calldata的任何一部分。</p>
<p>在这种情况下，我们并没有偏移量，因为offset =
0x00，所以我们把calldata前32字节压栈。之前我们记录过整个的call
data为“0x6057361d000000000000000000000000000000000000000000000000000000000000000a”。这意味着我们丢失了后边四个字节(“0000000a”)，如果我们想访问这个uint256变量则需要使用4字节的偏移量，忽视前四字节的函数签名，而得到完整的变量。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe6f79343-c4c4-4ee6-a29f-f1923fea5b9e_901x150.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>这次又有一个PUSH1，它想压一个0xe0，也就是十进制224。224是这么来的:
函数签名有4字节或者说32位，载入的calldata有32字节256位，256 - 32 =
224。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F161dea9b-d35b-4eb1-aac5-7adecb6cc17d_901x149.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>下一步，SHR操作意味着右移一位，而栈顶弹出的224则是移位次数，栈的下一个元素0x6057361d0…0a便是执行移位操作的主题。现在我们可以在调用栈里看到4字节的函数选择器了。如果你不了解移位操作的话请看这个<a
href="https://youtu.be/fDKUq38H2jk?t=176">视频</a>。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F8db5bd19-2271-44b3-99ed-0eec2731be5c_893x144.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>下一个是DUP1，一个复制栈顶元素的简单操作。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F40b72e9d-6e80-4232-9099-8718604542a8_896x146.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>PUSH4压入了
retrieve()的4字节函数签名(2e64cec1)，你可能疑惑evm是怎么知道这个值的，请记住字节码由solidity编译而来，它有函数名和参数类型等所有信息。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F23dc9994-e360-4205-bf5d-af92aaba42e5_899x189.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>EQ 操作会弹出两个元素去判断是否相等，在这里0x2e64cec1 != 0x6057361d
，如果他们相等则压1，不相等则压0。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F7cfc3f88-d5eb-4b03-b4c3-eb605bdeb283_895x144.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>PUSH2压入两字节的 0x003b 也就是十进制59。</p>
<p>调用栈有一个称为程序计数器的东西，它会确认字节码下一个要执行的指令在哪里，现在我们设置59是因为这是
retrieve() 函数的起始位置是59。(看下边EVM Playground
部分可以清楚这里具体是怎么实现的)。你可以看到程序字节码定位方式类似solidity代码行数，如果这个函数在59行声明，你可以使用行数来告诉机器怎么找到这个函数。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F67596d4e-054d-4cd7-b516-64b4789ee01f_900x190.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>JUMPI 表示 “jump if”
，它会弹出两个值作为参数，59表示跳转地址而第二个元素作为布尔值代表是否跳转。</p>
<p>如果真值为true，程序计数器将更新然后执行跳转到指定位置，而在我们这个例子里真值为false，程序计数器并没有改变，程序继续顺序执行。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1357763b-4150-4e14-8a8c-583ee74572aa_896x146.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>再次DUP1</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F40b72e9d-6e80-4232-9099-8718604542a8_896x146.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>PUSH4把store(uint256) (0x6057361d)压栈</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff937657d-dbb3-4133-95bb-1b3f5b8117cd_897x188.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>EQ判断，此次为真</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9c0617f7-2181-427e-9dca-917be7847f0a_898x145.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>PUSH2把 store(uint256) 的定位0x0059也就是89压栈</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F44dea0e0-9e0c-4459-bd1e-4af814c89203_898x186.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>JUMPI，这次执行跳转了，程序计数器更新为89然后到字节码的其他部分运行去了。在目的地会有一个JUMPDEST，如果目的地没有这个opcode，跳转将会失败。(
译者注: 我们可以在两个函数跳转的目的地可以找到JUMPDEST的字节码 5b )</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9f3a7f3c-a5f6-4e29-888f-60708e8863dc_896x146.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>我们可以到store(uint156)的字节码处依照此法继续执行了。虽然这个合约只有2个函数，但是原理和20+函数的合约是一样的。你现在知道EVM如何基于函数调用找到函数的字节码了，这其实就是对合约里所有函数的位址进行if-else判断实现的。</p>
<h3 id="evm-playground">EVM Playground</h3>
<p>我强烈建议大家看看<a
href="https://www.evm.codes/playground%5D">这个</a>,这是一个EVM运行环境，你可以设置字节码然后在上边执行。在这里可以看到调用栈的变化，我也添加了JUMPDEST，所以你也可以看到JUMPI后发生了什么</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F86591a6b-ee71-4590-8462-4ebb38f5cb80_1503x887.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>这个EVM运行环境也可以帮你理解程序计数器，在这份代码里，可以看到每个命令的注释，其偏移量代表程序计数器标记的位置。</p>
<p>你也可以看到Run按钮左边的calldata输入，去试试把它改成retrieve()
0x2e64cec1看看有什么变化吧！只需要点击Run然后step
into按钮(就是那个弯箭头)，一步一步运行opcode。</p>
<p>本系列下一节我们会研究一下内存 <a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?s=r">EVM
Deep Dives - Part 2</a>。</p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解EVM - Part 4 - Geth中存储区的实现</title>
    <url>/2022/06/25/Digging-Deep-EVM-Part4/</url>
    <content><![CDATA[<p>原文链接：https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-5a5?s=r</p>
<p>这是“深入理解EVM”系列的第四期。在<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?s=">第三期</a>中我们了解了合约存储相关的知识，这期会说明以太链的“世界状态”是怎么容纳单个合约的存储区的。为此我们需要审视以太链的体系结构和数据结构，一探Geth客户端深处的秘密。</p>
<p>我们从以太区块的数据开始，反推回特定合约存储区。再用Geth如何实现SSTORE与SLOAD收尾。需要了解的知识有很多，我们会介绍Geth代码库，讲讲以太坊的世界状态，让你对EVM有一个更深的了解。</p>
<h2 id="以太坊体系结构">以太坊体系结构</h2>
<p>我们从下图开始，不要有恐惧心理，在文章的结尾你会对它有一个全面的认识，这里画出了以太坊的体系结构和以太链的数据。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff6f48734-3cd7-42a0-a2dd-8f09fdd8a90e_1048x728.png"><img
src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff6f48734-3cd7-42a0-a2dd-8f09fdd8a90e_1048x728.png"
alt="img" /></a>以太坊体系结构 - 来源： <a
href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture">Zanzu</a></p>
<p>相比看整个的图，我们不如一块一块看。现在我们看一下第N块的区块头和它包含的字段。</p>
<h3 id="区块头">区块头</h3>
<p>区块头包含以太区块的关键信息，下边的第N块区块头就划分出了这些信息。看看以太坊<a
href="https://etherscan.io/block/14698834">第14698834块</a>
是否有下图的字段吧。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1e081473-12c5-4b01-ab0b-5f1ec1db106d_482x231.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1e081473-12c5-4b01-ab0b-5f1ec1db106d_482x231.png"
alt="img" /></a></p>
<p>区块头包含以下字段：</p>
<ul>
<li>Prev Hash - 父区块的Keccak 哈希</li>
<li>Nonce - 用于PoW计算，检验区块是否被成功挖出</li>
<li>Timestamp - UNIX时间戳</li>
<li>Uncles Hash - 叔叔节点的Keccak 哈希</li>
<li>Beneficiary - 收款人地址，矿工费接收者</li>
<li>LogsBloom -
布隆过滤器，提取自receipt，用于查找交易回执中的智能合约事件信息。</li>
<li>Difficulty - 表示当前区块的挖出难度</li>
<li>Extra Data - 最长32字节的自定义信息，由矿工自定义</li>
<li>Block Num - 区块高度</li>
<li>Gas Limit - 每个区块允许的最大gas量</li>
<li>Gas Used - 该区块实际消耗的gas量</li>
<li>Mix Hash - PoW验证时使用，代表区块不含nonce时的哈希值</li>
<li><strong><em>State Root -
执行完此区块中的所有交易后以太坊中，所有账户状态的默克尔树根哈希值</em></strong></li>
<li>Transaction Root - 交易生成的梅克尔树的根节点哈希值。</li>
<li>Receipt Root - 交易回执生成的梅克尔树的根节点哈希值。</li>
</ul>
<p>让我们看看这些和Geth代码的对应关系，<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/types/block.go#L70">block.go</a>里定义的“Header”结构体就代表一个区块头。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F35765b7d-a78d-4350-86b7-02925e25b35a_3226x1178.png"><img
src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F35765b7d-a78d-4350-86b7-02925e25b35a_3226x1178.png"
alt="img" /></a>代码地址： <a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/types/block.go">go-ethereum/core/types/block.go</a></p>
<p>我们可以看到代码里声明的变量是和上边的概念图匹配的，我们的目标是从从区块头一路找到合约存储区。为此我们要关注被标红的“State
Root”字段</p>
<h3 id="状态根">状态根</h3>
<p>“状态根(State
Root)”是一个梅克尔根，它取决于其下所有的数据块，任何一块数据的变动都会改变它。这个状态树的数据结构是MPT，叶子结点存储这网络上每一个以太坊账户的数据。该数据为k-v结构，key是地址，value是账户信息。</p>
<p><em>实际上key是地址的哈希值而value是账户信息的RLP编码，但是我们可以暂时忽略这件事</em></p>
<p>以太坊体系结构图的这一部分正是代表了状态根的MRT。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fd1cf36d8-9880-4aa1-9b7b-a4176273d210_178x258.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fd1cf36d8-9880-4aa1-9b7b-a4176273d210_178x258.png"
alt="img" /></a></p>
<p>MPT是一种复杂的数据结构，我们这篇文章不做深究。如果你对MPT感兴趣的话建议看<a
href="https://medium.com/shyft-network-media/understanding-trie-databases-in-ethereum-9f03d2c3325d">这篇文章</a>。接下来我们重点看看以太坊的账户信息是如何映射到地址的。</p>
<h3 id="以太坊账户">以太坊账户</h3>
<p>以太坊账户由以下四项构成：</p>
<ul>
<li>Nonce - 账户的交易数</li>
<li>Balance - 账户余额</li>
<li>Code Hash - 合约账户的所执行的代码，一旦被初始化就是只读的。</li>
<li>Storage Root -
存储根，该值随着合约的存储区的增加、删除、改动而不断变更</li>
</ul>
<p>(译者注：后两项是合约账户拥有的数据段，普通账户并没有)</p>
<p>我们在之前以太坊体系结构图的这一段可以看到：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F0f0b898c-8fb1-469a-9fb1-0346ccbae601_409x57.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F0f0b898c-8fb1-469a-9fb1-0346ccbae601_409x57.png"
alt="img" /></a></p>
<p>现在我们去看看Geth的代码，找到对应的 <a
href="https://github.com/ethereum/go-ethereum/blob/b1e72f7ea998ad662166bcf23705ca59cf81e925/core/types/state_account.go#L27">state_account.go</a>
，这个StateAccount结构体就是“以太坊账户”。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F630df44e-bdab-41b9-8894-f09be4a09ea7_2122x574.png"><img
src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F630df44e-bdab-41b9-8894-f09be4a09ea7_2122x574.png"
alt="img" /></a>代码地址： <a
href="https://github.com/ethereum/go-ethereum/blob/b1e72f7ea998ad662166bcf23705ca59cf81e925/core/types/state_account.go">go-ethereum/core/types/state_account.go</a></p>
<p>可以看到代码里声明的变量与概念图对应上了。接下来我们需要探讨以太坊账户的存储根。</p>
<h3 id="存储根">存储根</h3>
<p>存储根(storage
root)很像状态根，在它的下面是另一棵MPT。区别就是这次的key是存储插槽，而value是插槽里的数据。</p>
<p><em>跟状态根一样，key其实是哈希值而value是RLP编码</em></p>
<p>以太坊体系结构图的这一部分正是代表了存储根的MRT。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F18d30b84-5853-4505-9466-a8c2804be40e_196x260.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F18d30b84-5853-4505-9466-a8c2804be40e_196x260.png"
alt="img" /></a></p>
<p>存储根是一个梅克尔根，任何合约存储区的数据的改变都会改变存储根的值，从而影响区块头的值。现在我们知道怎么从区块找到合约存储区了。下一步我们继续研究Geth的代码，看看存储区是怎么初始化的，以及调用SSTORE和SLOAD是会发生什么。这会帮助你找到底层opcode和solidity代码之间的联系。</p>
<h3 id="statedb-stateobject-stateaccount">StateDB → stateObject →
StateAccount</h3>
<p>我们需要一个全新的合约，全新的合约意味着StateAccount也是全新的。</p>
<p>开始之前我们看三个结构：</p>
<ul>
<li>StateAccount
<ul>
<li>StateAccount 是以太坊账户的一致化表达</li>
</ul></li>
<li>stateObject
<ul>
<li>stateObject 代表着尚未被修改的以太坊账户</li>
</ul></li>
<li>StateDB
<ul>
<li>StateDB
存储梅克尔树的所有数据，用于检索合约和以太坊账户的查询接口</li>
</ul></li>
</ul>
<p>我们看看这三个结构的内在关系：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fc0e579c8-adb2-4679-9744-03c4bd3c1182_2002x1572.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fc0e579c8-adb2-4679-9744-03c4bd3c1182_2002x1572.png"
alt="img" /></a>StateDB → stateObject → StateAccount</p>
<ol type="1">
<li><a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/statedb.go#L64">StateDB
struct</a>,
我们可以看到它有一个stateObjects字段，是地址到stateObject的映射集(牢记状态根的MPT是地址到以太坊账户的映射，而stateObject是尚未修改的以太坊账户)。</li>
<li><a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L66">stateObject
struct</a>,
我们可以看到它包含一个StateAccount字段，这是一个代码实现里的中间态。</li>
<li><a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/types/state_account.go#L29">StateAccount
struct</a>,
现在我们终于看到这个代表以太坊账户的结构了，它的Root字段就是我们之前讨论的存储根。</li>
</ol>
<p>现在一些令人疑惑的东西逐渐明晰了起来，我们看一看新的以太坊账户，或者说StateAccount是怎么初始化的。</p>
<h3 id="initalising-a-new-ethereum-account-stateaccount">Initalising A
New Ethereum Account (StateAccount)</h3>
<p>我们需要操作<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/statedb.go">statedb.go</a>以及它的StateDB结构体去创建新的StateAccount。StateDB有一个名为createObject的函数，它会创建一个新的stateObject然后放进去一个空的StateAccount。</p>
<p>下图是代码细节：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F5b2cc945-1634-4315-9adc-f5a2a147406e_3296x1104.png"><img
src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F5b2cc945-1634-4315-9adc-f5a2a147406e_3296x1104.png"
alt="img" /></a></p>
<ol type="1">
<li>StateDB有一个 <a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/statedb.go#L575">createObject
函数</a>
，传入一个地址返回一个stateObject。(重申stateObject是一个未修改的以太坊账户)。</li>
<li>这个createObject函数调用<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L102">newObject
函数</a>
，它传入stateDB，地址和一个空的StateAccount，返回一个stateObject。</li>
<li>在newObject函数的返回语句中，我们可以看到有许多字段与stateObject,
address, data, dirtyStorage等相关</li>
<li>tateObject的data映射到空的StateAccount，可以在103-111行看到从nil值转变为初始化空值的过程。</li>
<li>stateObject被成功创建并带着已经初始化完成的StateAccount(也就是data字段)返回了。</li>
</ol>
<p>现在我们有了一个空stateAccount，下一步我们存些数据吧，用SSTORE。</p>
<h2 id="sstore">SSTORE</h2>
<p>在深入了解SSTORE的Geth实现之前我们先回忆一下SSTORE是干什么的。</p>
<p>SSTORE会从栈上弹出两个值，一个32字节的key，一个32字节的value。key决定了value存在哪个插槽里。</p>
<p>下面就是Geth的SSTORE操作的源码，我们看看他做了什么：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F8b9e61f6-7a74-48db-9c07-b2a3717bd3b5_2882x1762.png"><img
src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F8b9e61f6-7a74-48db-9c07-b2a3717bd3b5_2882x1762.png"
alt="img" /></a></p>
<ol type="1">
<li>我们从 <a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/instructions.go#L524">instructions.go</a>开始看，它定义了所有的opcode，在这个文件里我们可以看到opSstore函数。</li>
<li>这个函数的入参包括合约上下文信息，例如栈，内存等，我们把两个值弹出栈，标记成loc(location)和val(value)。</li>
<li>这两个值被弹出来后作为入参和合约地址一起传进<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/statedb.go#L414">StateDB的SetState
函数</a>，SetState会用合约地址检验合约里是否有stateObject如果没有就创建一个。之后调用stateObject的SetState，传进StateDB，key和value。</li>
<li><a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L245">stateObject的SetState
函数</a>对fakeStorage做了检查，看看value是否被改变过，之后运行journal的append函数。</li>
<li>如果你阅读<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/journal.go#L38">journal
struct</a>的注释会看到journal是用来跟踪状态的改变(就是保存中间变量)，这样它们就可以在执行异常或撤销请求的情况下恢复。</li>
<li>journal更新之后，调用<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L245">stateObject的SetState
函数</a>。更新stateObject.dirtyStorage。</li>
</ol>
<p>现在我们已经更新了stateObject 的
dirtyStorage。而这究竟意味着什么呢？与我们学的东西有什么关系吗？</p>
<p>让我们看看定义dirtyStorage的代码</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe62db976-b29d-4803-af46-22bc577d5755_2210x1794.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe62db976-b29d-4803-af46-22bc577d5755_2210x1794.png"
alt="img" /></a>dirtyStorage → Storage → Hash → 32-byte</p>
<ol type="1">
<li>dirtyStorage是在<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L66">stateObject</a>里定义的，被描述为"在当前事务执行中被修改的存储项"。</li>
<li>dirtyStorage的类型<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L41">Storage
type</a>是一种从common.Hash到common.Hash的映射。</li>
<li><a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/common/types.go#L49">Hash
type</a> 就是一个长度为HashLength的字节数组</li>
<li><a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/common/types.go#L36">HashLength</a>是常量，值是32。</li>
</ol>
<p>32字节key到32字节value的映射对你来说应该很熟悉，这完全就是<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?utm_source=%2Fprofile%2F80455042-noxx&amp;utm_medium=reader2&amp;s=r">第三篇</a>我们提到过的合约存储区的概念。你现在可能注意到dirtyStorage字段上边的pendingStorage和originStorage了。他们是有相关性的，dirtyStorage在确定写入的过程中，会复制到pendingStorage，然后在MPT更新时复制到originStorage。MPT更新了之后，StateDB的commit过程中StateAccount的状态根也会更新。会将新的状态写进MPT的底层数据库。</p>
<p>下面轮到最后一个难点，SLOAD。</p>
<h2 id="sload">SLOAD</h2>
<p>我们快速回忆一下SLOAD是干什么的：它会把一个32字节的key从栈里弹出来，然后返回key对应的插槽里的值。下面看一下Geth实现SLOAD的代码：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F991e7cec-54bd-41b2-afe4-247144fea091_3430x1316.png"><img
src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F991e7cec-54bd-41b2-afe4-247144fea091_3430x1316.png"
alt="img" /></a></p>
<ol type="1">
<li>我们依然从<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/instructions.go#L516">instructions.go
file</a>
开始，找到opSload函数，我们从栈顶获取到了存储插槽。也就是临时变量loc。</li>
<li>调用<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/statedb.go#L308">StateDB的GetState函数</a>传入合约地址和存储位置，GetState获得了合约地址对应的stateObject，如果它不为空，则调用<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L172">stateObject的GetState函数</a>。</li>
<li><a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L172">stateObject的GetState函数</a>对fakeStorage和dirtyStorage做检查。</li>
<li>如果dirtyStorage存在，则返回key在dirtyStorage映射里的值(dirtyStorage代表着合约的最新状态，所以要最先返回它)。</li>
<li>否则将调用<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/state/state_object.go#L187">GetCommitedState
函数</a>里查询数据，再次检验fakeStorage。在这个函数里完成下面两步。</li>
<li>如果pendingStorage存在，则返回key在pendingStorage映射里的值。</li>
<li>如果上边的都没有，就检索originStorage里的值并返回。</li>
</ol>
<p>你会发现函数最先试图返回dirtyStorage，然后依次是pendingStorage和originStorage。这是合情合理的，在运行的过程中dirtyStorage是最新状态，紧接着是pendingStorage和originStorage。一个交易可能多次改变同一个插槽的数据所以我们必须保证拿到的是最新的值。</p>
<p>让我们设想在同一笔交易里，SLOAD之前在同一个插槽发生了SSTORE操作，在这种情况下dirtyStorage是被SSTORE更新过的，SLOAD返回的正应该是它。</p>
<p>现在您已经了解了Geth是如何实现SSTORE和SLOAD的。它们如何与状态和存储区交互，以及如何更新插槽与世界状态相关的知识。</p>
<p>这篇文章的强度很大但是你坚持下来了，我猜这篇文章会让你的问题比刚开始更多了，但这正是加密世界的乐趣不是吗？</p>
<p>只要功夫深，铁杵磨成针！</p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解EVM - Part 5 - 调用/委托调用的原理与实现</title>
    <url>/2022/06/30/Digging-Deep-EVM-Part5/</url>
    <content><![CDATA[<p>原文链接：https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-a5f
译者：<a href="alvan.coffee">Alvan's Blog</a></p>
<h1 id="深入理解evm---part-5---调用委托调用">深入理解EVM - Part 5 -
调用/委托调用</h1>
<p>今天我们详细解读一下 CALL 和 DELEGATECALL 两个操作，如果没看过<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?utm_source=%2Fprofile%2F80455042-noxx&amp;utm_medium=reader2&amp;s=r">第二篇</a>，<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?utm_source=%2Fprofile%2F80455042-noxx&amp;utm_medium=reader2&amp;s=r">第三篇</a>
和<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-5a5?utm_source=%2Fprofile%2F80455042-noxx&amp;utm_medium=reader2&amp;s=r">第四篇</a>的话，建议作为前置知识读一下。</p>
<p>我们将从solidity，EVM 和 Geth
三个层面解读这两个opcode，让你对它们有一个全面的认识。然而在深入理解他们之前，我们先确认一下合约执行上下文的概念：</p>
<h3 id="执行上下文">执行上下文</h3>
<p><em>当EVM运行合约时，会创造一个<a
href="https://www.evm.codes/about">上下文</a>，它包含以下几个部分：</em></p>
<ul>
<li>Code
<ul>
<li>存储在链上的合约的不可变代码。</li>
</ul></li>
<li>Call Stack
<ul>
<li>前文讲过的合约的调用栈，EVM运行合约时会初始化一个空的。</li>
</ul></li>
<li>Memory
<ul>
<li>合约的内存，EVM运行合约时会初始化一个空的。</li>
</ul></li>
<li>Storage
<ul>
<li>存储区在执行过程中持久化，链上存储，根据合约地址和插槽寻址。</li>
</ul></li>
<li>The Call Data
<ul>
<li>交易的传入数据</li>
</ul></li>
<li>The Return Data
<ul>
<li>合约调用的返回数据</li>
</ul></li>
</ul>
<p>在阅读下面内容时，时刻记着这几个点。我们先从<a
href="https://www.youtube.com/watch?v=uawCDnxFJ-0">Smart Contract
Programmer</a>的DELEGATECALL使用用例开始讲：</p>
<h3 id="solidity-样例">Solidity 样例</h3>
<p>下图是同一个合约中的两个调用，一个使用了DELEGATECALL，另一个使用了CALL。现在我们看一下他们之间的区别。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fbd68e45d-6238-483a-bf8f-393db30ac39c_2650x1572.png"><img
src="https://substackcdn.com/image/fetch/w_2400,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fbd68e45d-6238-483a-bf8f-393db30ac39c_2650x1572.png"
alt="img" /></a></p>
<p>下边是这次交互的一些信息(如果你在remix里自己执行的话，会是不一样的数据)：</p>
<p>我们有两个合约，即 Contract A 和 Contract B 还有一个 EOA：</p>
<ul>
<li>EOA 地址 = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</li>
<li>Contract A 地址 = 0x7b96aF9Bd211cBf6BA5b0dd53aa61Dc5806b6AcE</li>
<li>Contract B 地址 = 0x3328358128832A260C76A4141e19E2A943CD4B6D</li>
</ul>
<p>现在把 Contract B 的地址和一个uint值 12以及 1000000000000000000 Wei
传入，调用 Contract A 里的两个方法， setVarsDelegateCall 和
setVarsCall。</p>
<p><strong><em>Delegate Call</em></strong></p>
<ol type="1">
<li>一个 EOA 地址把 Contract B 的地址和一个uint值 12以及
1000000000000000000 Wei 传入，调用Contract
A的setVarsDelegateCall，这次是委托调用Contract
B执行setVars(uint256)，参数是12。</li>
<li>委托调用运行 Contract B 的 setVars(uint256) 但是更新的是 Contract A
的存储区，它运行时的存储区，msg.sender 和msg.value
也都和父调用一样。</li>
<li>Contract A的存储区写入数据：num=12，sender = EOA Address以及value =
1000000000000000000。尽管Contract A
调用的setVars(uint256)不带value，</li>
</ol>
<p>执行完这个方法之后我们检查Contract A 和Contract B的num， sender 和
value状态。我们可以看到Contract B没有被初始化，都设置在Contract
A里了。</p>
<p><strong><em>Call</em></strong></p>
<ol type="1">
<li>一个 EOA 地址把 Contract B 的地址和一个uint值 12以及
1000000000000000000 Wei 传入，调用 Contract A
的setVarsCall，这次是调用Contract B执行setVars(uint256)，参数是12。</li>
<li>调用运行 Contract B 的setVars(uint256)
，不改变(本合约的)存储区，msg.sender,和msg.value</li>
<li>Contract B的存储区写入数据：num=12，sender = Contract A Address
以及value = 0。(1000000000000000000 Wei被传进了父调用setVarsCall。)</li>
</ol>
<p>执行完这个方法之后我们检查Contract A 和Contract B的num， sender 和
value状态。我们可以看到Contract A没有被初始化，都设置在Contract
B里了。</p>
<p>“委托调用”就是允许你从别的合约里复制一个方法粘贴到你的合约里，运行起来就行在你的合约里执行的一样，使用本合约的存储区，msg.sender
和
msg.value。而“调用”是进入到另一个合约去执行方法，相当于发了一笔交易，有其自己的value值和sender(也就是调用call的合约)。</p>
<h3 id="delegate-call-storage-layout委托调用与内存布局">Delegate Call
&amp; Storage Layout委托调用与内存布局</h3>
<p>在上述例子里，你肯呢个注意到Contract B 第5行的注释<em>“NOTE: storage
layout must be the same as contract A”</em>。</p>
<p>合约里的每一个函数都会经过编译成为一个静态的字节码。当我们理解solidity变量的时候，是看见num，sender和value去理解的。但是字节码不知道这些，它只认存储插槽，而声明变量的时候就把插槽定下来了。</p>
<p>Contract B 的 setVars(uint256) 函数里，“num = _num”就是说要把 _num
存进插槽0。当我们看一个DELEGATECALL的时候不要去想num → num，sender →
sender的映射，因为在字节码的层面不是这样的，我们需要认识到这是slot 0 →
slot 0, slot 1 → slot 1的映射。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcf64c77b-f60f-4720-96bb-575dabef8917_1006x306.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fcf64c77b-f60f-4720-96bb-575dabef8917_1006x306.png"
alt="img" /></a></p>
<p>试想如果我们改变了声明变量的顺序会怎样。那么他们的插槽位置会改变，同时setVars(uint256)
的字节码也跟着变了。如果我们把 Contract B 的6行和8行互换位置，先声明
value 后声明 num 。那就意味着11行的“num = _num”意味着把
_num存进插槽2里，13行的“value = msg.value”意味着把msg.value
存进插槽0。这就用意味着两合约中，我们变量之间的映射和插槽之间的映射不匹配了</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F0f24b3ce-a2ed-4bbe-b87d-6d36b9148640_1006x306.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F0f24b3ce-a2ed-4bbe-b87d-6d36b9148640_1006x306.png"
alt="img" /></a></p>
<p>在这种情况下，当我们运行 DELEGATECALL
时，num变量会被存在插槽2，而这里在 Contract A 中映射到 value
变量。反过来也是一样的，两个变量就会存储进预想之外的地方。这就是DELEGATECALL比较危险的原因之一。我们意外地
value 值把 num 覆盖了，用 num 值把 value
覆盖了。但是黑客可不会意外，他们会有目的地攻击。</p>
<p>试想我们知道一个开放 delegatecall 的合约，我们知道那个合约存储
owner的插槽。现在我们可以做一个相同布局的合约，然后写一个更新owner的方法，这就意味着我们可以通过委托调用这个更新方法来改变该合约的owner。</p>
<p>如果你对这个黑客攻击感兴趣的话可以在这里深入了解一下：</p>
<ul>
<li><a
href="https://ethernaut.openzeppelin.com/level/0x9451961b7Aea1Df57bc20CC68D72f662241b5493">Ethernaut
Level 6 - Delegation</a></li>
<li><a
href="https://ethernaut.openzeppelin.com/level/0x97E982a15FbB1C28F6B8ee971BEc15C78b3d263F">Ethernaut
Level 16 - Preservation</a></li>
</ul>
<p>下面看一看opcode层面</p>
<h2 id="opcodes">Opcodes</h2>
<p>我们现在知道DELEGATECALL怎么工作了，那么深入一下，看看DELEGATECALL和CALL的操作码。</p>
<p>对于DELEGATECALL我们有以下输入变量</p>
<ul>
<li><code>gas</code>: 执行的gas费</li>
<li><code>address</code>: 执行上下文的account</li>
<li><code>argsOffset</code>: 输入数据(calldata)的偏移量</li>
<li><code>argsSize</code>: calldata的大小</li>
<li><code>retOffset</code>: 输出数据(returndata)的偏移量</li>
<li><code>retSize</code>: returndata的大小</li>
</ul>
<p>CALL比起上边的只多一个value，其它的都一样</p>
<ul>
<li><code>value</code>: 发送给account的以太币(CALL only)</li>
</ul>
<p>委托调用不需要value输入，它从父调用继承。我们的执行上下文有和父调用一样的存储区，msg.sender
和 msg.value。</p>
<p>他们都是有一个返回值布尔值"success"，为0则为执行失败，反之则为1。</p>
<blockquote>
<p><em>如果调用位置没有合约或者没有代码，Delegatecall会返回true。这会出现bug，因为它没执行，我们是希望返回False的</em></p>
</blockquote>
<h3
id="delegatecall-opcode-inspection-with-remix利用remix检验delegatecall">DELEGATECALL
Opcode Inspection With Remix利用Remix检验DELEGATECALL</h3>
<p>下边是Remix中调用DELEGATECALL操作码的截图。对应Solidity代码的24-26行。</p>
<p>我们可以看到栈和内存的条目以及它们是怎么传进DELEGATECALL的。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F39945796-94b6-4d6b-8bf6-52b29ac22559_3404x1334.png"><img
src="https://substackcdn.com/image/fetch/w_5760,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F39945796-94b6-4d6b-8bf6-52b29ac22559_3404x1334.png"
alt="img" /></a></p>
<p>我们按照这条路线理解：opcode → stack → memory → calldata</p>
<ol type="1">
<li>Solidity代码的24行，使用了delegatecall 调用 Contract B 的
setVars(unit256)，调用了DELEGATECALL操作码。</li>
<li>DELEGATECALL从栈上拿6个输入：
<ol type="1">
<li>Gas = 0x45eb</li>
<li>Address = 0x3328358128832A260C76A4141e19E2A943CD4B6D (Address for
Contract B)</li>
<li>ArgsOffset = 0xc4</li>
<li>ArgsSize = 0x24</li>
<li>RetOffset = 0xc4</li>
<li>RetSize = 0x00</li>
</ol></li>
<li>注意到 argsOffset 和 argsSize 两个代表了传入 Contract B 的
calldata。这两个变量让我们从内存位置0xc4开始，复制后边的 0x24
(十进制36)作为calldata。</li>
<li>我们因此拿到了0x6466414b000000000000000000000000000000000000000000000000000000000000000c，6466414b是setVars(uint256)
的函数签名，而000000000000000000000000000000000000000000000000000000000000000c是我们传入的数据
12。</li>
<li>这对应了Solidity代码的25行，abi.encodeWithSignature("setVars(uint256)",
_num)。</li>
</ol>
<p>因为setVars(uint256)不返回任何值，所以retSize置0。</p>
<p>如果有返回值的话，就是存在retOffset以后的retOffset以内。这应该让你对这个操作码的底层逻辑了解的深一点，也会和Solidity联系起来了。</p>
<p>现在我们看一下Geth里的实现。</p>
<h3 id="geth实现">Geth实现</h3>
<p>我们看一下Geth里写DELEGATECALL的部分。目标是展现DELEGATECALL和CALL在存储的层面的区别，以及是怎么联系上SLOAD的。</p>
<p>下边的图有点唬人，但是我们拆解开来一步一步做，在结束的时候你就会对DELEGATECALL和CALL有深刻的认识。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F60abd9bd-475f-4694-8bce-aa4c4b43fadd_4102x3874.png"><img
src="https://substackcdn.com/image/fetch/w_5760,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F60abd9bd-475f-4694-8bce-aa4c4b43fadd_4102x3874.png"
alt="img" /></a></p>
<p>We have the DELEGATECALL &amp; CALL opcodes labeled on the left-hand
side and the SLOAD opcode labeled bottom right. Let’s see how they’re
connected.</p>
<ol type="1">
<li>这图里有两个 [1]
号截图，分别对应DELEGATECALL和CALL操作码的代码，在<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/instructions.go">instructions.go</a>里。我们可以看到从栈里弹出的那几个变量，之后可以看到调用
interpreter.evm.DeleagteCall和 interpreter.evm.Call
这两个函数，传进去了栈里的变量，目标地址和现在的合约上下文</li>
<li>图里也有两个 [2] 号截图，分别对应 evm.DelegateCall 和 evm.Call
的代码的代码，在 <a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/evm.go">evm.go</a>里边。中间省略了一些校验和其它函数，我们主要关注执行调用NewContract方法新建上下文的代码，其它的可以忽略掉。</li>
<li>图里有两个 [3] 号截图。里边主要是evm.DelegateCall和evm.Call
调用NewContract。它们非常相似，以下两点除外：
<ol type="1">
<li>DelegateCall的value参数设为nil，它从之前的上下文继承，所以不写进这个参数里。</li>
<li>NewContract的第二个参数也不一样。evm.DelegateCall 里caller.Address(
) 用的是Contract A的地址。evm.Call
里addrCopy是复制的toAddr，也就是Contract
B的地址，这一点区别非常大。他俩都是AccountRef类型，这个很重要，后边会提到。</li>
</ol></li>
<li>DelegateCall’s的NewContract会返回一个Contract结构体。它又调用了AsDelegate()方法(在<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/contract.go">contract.go</a>里)(见图[4])，把msg.sender
和 msg.value设置成了父调用的样子，也就是EOA地址和1000000000000000000
Wei。这在Call的实现里是没有的。</li>
<li>evm.DelegateCall 和 evm.Call 都执行NewContract方法(在<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/contract.go">contract.go</a>里)，NewContract方法的第二个入参是“object
ContractRef”，对应着第三点里提到的AccountRef。</li>
<li>“object
ContractRef”和一些其他值被用来初始化合约，对应Contract结构体里的“self”</li>
<li>Contract结构体( 在<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/contract.go">contract.go</a>里)有一个“self”字段，你可以看到也有其他的字段与我们之前提到的执行上下文有关。</li>
<li>现在我们跳跃一下，去看看Geth里SLOAD(在<a
href="https://github.com/ethereum/go-ethereum/blob/d4d288e3f1cebb183fce9137829a76ddf7c6d12a/core/vm/instructions.go">instructions.go</a>里)的实现，它在调用GetState时用的参数就是scope.Contract.Address(
)。这里的“Contract”就是我们在第7条提到的结构体。</li>
<li>Contract结构体的Address( ) 返回的是self.Address。</li>
<li>Self是一个ContractRef类型，ContractRef必然有一个Address( )
方法。</li>
<li>ContractRef是一个接口，规定如果一个类型要做ContractRef，那必须有一个返回值类型是common.Address的Address(
)
函数。common.Address是一个长度20的字节数组，也就是以太坊地址的长度。</li>
<li>我们回到第3块看一下evm.DelegateCall和evm.Call
中AccountRef的区别。我们可以看到AccountRef就是一个有Address( )
函数的地址，那它也符合ContractRef接口的规则。</li>
<li>AccountRef 的 Address( ) 函数是把 AccountRef
转化成common.Address，也就是 evm.DelegateCall 里的 Contract A 地址和
evm.Call 里的Contract B 地址。这意味着第8部分讲的 SLOAD 会在
DELEGATECALL 时使用 Contract A 的存储区，在 CALL 时使用 Contract B
的存储区。</li>
</ol>
<p>通过学习Geth的实现你应该对DelegateCall的存储区，
msg.sender和msg.value的来龙去脉有了深刻了解，对DELEGATECALL也有了一定的认识，很棒！下次再见！</p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>入门Defi第一步，初识DEX,AMM与LP token</title>
    <url>/2022/06/13/Intro-DEX-AMM-LP-Token/</url>
    <content><![CDATA[<h2 id="dex是什么">DEX是什么？</h2>
<p>​ DEX(Decentralized
Exchange)，即去中心化交易所，不依赖券商、银行等金融机构提供金融工具，而是利用区块链上的智能合约就可以提供交易服务的交易所。例如Uniswap，Curve，Pancake等等。</p>
<h2 id="dex与传统交易所">DEX与传统交易所</h2>
<p>​
DEX和传统交易所的区别并不只在于数据存储的方式和所有权不同，在交易方式和原理上也有着本质的区别。我们以最常见的DEX框架即AMM模型与传统交易所挂单模型对比：</p>
<h3 id="两种交易所订单簿模型的区别">两种交易所订单簿模型的区别：</h3>
<p>中心化交易所：<img src="https://fintechruminations.com/wp-content/uploads/2021/07/Screenshot-2021-07-09-at-17.12.18-1024x887.png" alt="img" style="zoom:30%;" />DEX：<img src="https://fintechruminations.com/wp-content/uploads/2021/07/Screenshot-2021-07-09-at-17.12.24-1024x500.png" alt="img" style="zoom:33%;" />
中心化交易所的卖方在交易所挂单，买方通过交易所自动撮合下单购买。
DEX的不存在买方和卖方的差异，其本质也不是购兑换对方的资产，而是直接从流动性资产池中换取需要的资产。
<small>流动性资金池(liquidity
pools)：用户交易使用的资产池，其中的资金由用户提供，提供资金的行为被称为提供流动性(add
liquidity)。为了保证交易稳定、流动性充足，提供流动性的用户(liquidity
provider)可以从每笔交易的手续费里提取分成作为奖励。</small></p>
<h3 id="两种方案的优劣比较">两种方案的优劣比较：</h3>
<table>
<thead>
<tr class="header">
<th>中心化交易所</th>
<th>DEX</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>审查身份</td>
<td>不审查身份</td>
</tr>
<tr class="even">
<td>手续费只存在于执行交易时</td>
<td>每一步操作都需要手续费</td>
</tr>
<tr class="odd">
<td>数据中心化，放在服务器</td>
<td>数据去中心化，放在区块链</td>
</tr>
<tr class="even">
<td>交易迅速</td>
<td>交易缓慢</td>
</tr>
<tr class="odd">
<td>巨鲸操盘，交易所黑幕</td>
<td>套利机器人日夜巡逻</td>
</tr>
</tbody>
</table>
<p>​
<small>存在DEX像0x协议这样使用零知识证明原理，实现“链上+链下”结合的方式实现挂单模型，在下文中DEX特指使用AMM的去中心化交易所</small></p>
<h2 id="amm和lp-token是什么">AMM和LP token是什么？</h2>
<h3 id="amm">AMM:</h3>
<p>​ AMM即Automated Market
Maker，自动化做市商。AMM应用在DEX中，使得买方和卖方之间不需要任何信任关系以及第三方就可以安全完成交易。AMM用户的买/卖本质上是在对相应资产的流动性资金池做兑换，而非买卖双方的动作。所以AMM天生适合去中心化交易所使用，只要资金池和定价模式完全依托去中心化平台，就没有任何单独实体可以操纵这个系统，同时每个人都可以在这个基础上建立新的应用。</p>
<h3 id="lp-token">LP token:</h3>
<p>​ LP token即(Liquidity Provider Token)，对于AMM来说，x -
y两种资产的兑换需要一个x - y
的资金池，而x，y两种资产由用户提供。用户把x和y资产质押进流动性以获取流动性挖矿(yield
farming )奖励，而质押的凭证就是AMM给流动性提供者签发的一种新代币，称为LP
token。 ​ 在DeFi飞速发展的过程中，DeFi的术语也在不断。很多情况下LP
token具体叫什么是随着项目变化的。比如在Balancer中，通常被称为BPT或者pools
tokens；在Uniswap里被称为liquidity tokens或者pool
tokens，在Curve中被称为LP token。</p>
<h2 id="amm的原理">AMM的原理</h2>
<p>​
AMM发展至今已经落地在不少应用中，虽然具体实现方法和应用场景略有差别，但很多以简单模型为基础改进，本节将以其代表项目UniswapV2为例讲解。各种改进算法将不做讨论
AMM实现功能靠以下两个核心功能：</p>
<h3 id="swaps">Swaps:</h3>
<p>​ AMM的token交换基于流动性资金池和恒定乘积公式算法：<span
class="math inline">\(x \times y = k\)</span>，即交易发生在 （卖出资产-
买入资产）交易对的流动性资金池中，交易价格由恒定乘积公式决定。
x，y为资金池中两种资产的量：
<img src="https://lh3.googleusercontent.com/DlgPwa6IlYeRgPkAPdwHPY7P0UCGMSiiESzvhCpUUSFuJ0HhFWG3rV1FSxEb_RFyV1JfdBQ1MUjVkzO8yDmJQXf-O0Ym0UWj-CM5xla9hARaA0kY6D6tSDhsYVhVkhbDrOj2-WHv" alt="img" style="zoom:50%;" /></p>
<p>​ 例如在一个<span class="math inline">\(x = 200\)</span>, <span
class="math inline">\(y =
300\)</span>的资金池内想用100个y来兑换x，那么有<span
class="math inline">\((y+100)\times (x- \delta x) = x \times
y\)</span>，可解兑换出50个x资产。一个池子内，x越少，就可以用x换取更多的y，反之亦然，套利者会自发将两者价格与全链同步，这就是swap的基本原理。
​
那么K值是否能够改变呢？答案是肯定的，因为手续费和流动性的原因，几乎每一笔交易成功实际发生后，k都会改变。所谓的固定乘积，是交易发生前计算价格的方法。</p>
<h3 id="liquidity-pools">Liquidity Pools:</h3>
<p>​ AMM的用户不直接与另一个用户发生交易，他们的交易要通过liquidity
pools实现，而且因为在AMM的恒定乘积公式算法中，当流动性池内资金量少时，很容易出现x，y有一个非常小导致价格离谱的情况。
​流动性资金池由用户质押资产提供，用户质押资产进入liquidity
pools，然后获得质押凭证LP
token，而提供流动性的用户也会获得手续费收益，即LP
token分红和对应交易所的治理代币。用户也可以使用LP
token赎回其质押的资产，被称为移除流动性(remove liquidity)。</p>
<h2 id="流动性挖矿与lp-tokens">流动性挖矿与LP Tokens</h2>
<p>​ LP Tokens的一个很引人注目的应用领域就是流动性挖矿(Yield
Farming)，将他们两个结合起来，是一种向多个不同合约组合操作以达到收益最大化的挖矿方式，下面举一个Curve中的例子：</p>
<ol type="1">
<li>向Curve 的liquidity pool质押DAI</li>
<li>获得LP tokens</li>
<li>将LP tokens质押进Curve的质押池</li>
<li>获得Curve利息</li>
</ol>
<h2 id="引用">引用：</h2>
<p><a
href="https://fintechruminations.com/2021/07/09/uniswap-and-the-amm-model/">UNISWAP
AND THE AMM MODEL</a> <a
href="https://www.gemini.com/cryptopedia/liquidity-provider-amm-tokens">How
Liquidity Provider (LP) Tokens Work</a></p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解EVM - Part2 - 内存</title>
    <url>/2022/06/21/Digging-Deep-EVM-Part2/</url>
    <content><![CDATA[<p>原文链接：https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?s=r
译者博客: <a href="alvan.coffee">Alvan的Blog</a></p>
<p>本系列的第二篇文章，我们会继续学习基础知识，以期成为“shadowy super
coder”。如果没看过本系列的<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&amp;s=r">第一篇</a>的话，建议看一下，有些前置的知识。在<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&amp;s=r">第一篇</a>里，我们知道了EVM如何根据字节码找到调用的函数，对调用栈，calldata，函数签名和opcode有了一定了解。在第二篇我们学习一下合约的内存(memory)是怎么在EVM里工作的。</p>
<h2 id="a-trip-down-memory-lane">A Trip Down Memory Lane</h2>
<p><a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&amp;s=r">第一篇</a>出现的1_Storage.sol
contract又来营业了。</p>
<figure>
<img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3400bba6-f870-4b68-8ba8-118562b08aef_489x538.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>还是像上次一样，生成字节码然后把相关的截出来，在这篇里我们着重看一下前五字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6080604052</span><br><span class="line">60 80                       =   PUSH1 0x80</span><br><span class="line">60 40                       =   PUSH1 0x40</span><br><span class="line">52                          =   MSTORE </span><br></pre></td></tr></table></figure>
<p>这五个字节表示初始化“空闲内存指针”(free memory
pointer)。要想完全理解它的含义，我们必须先对管理合约内存的数据结构有一定了解。</p>
<h2 id="内存的数据结构">内存的数据结构</h2>
<p>合约的内存是一个很简单的字节数组，可以储存32字节或者1字节的数据块，也可以读取32字节的数据块。如下图所示：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F33d7994b-a4b5-4268-8d53-85f214944599_717x437.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F33d7994b-a4b5-4268-8d53-85f214944599_717x437.png"
alt="img" /></a> 来源:
https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf</p>
<p>这个功能是3个管理内存的opcode决定的</p>
<ul>
<li>MSTORE (x, y) - 以“x”处为起点，写入32字节的数据“y”</li>
<li>MLOAD (x) - 从“x”处取出32字节的数据加载到调用栈。</li>
<li>MSTORE8 (x, y) -
以“x”处为起点，写入1字节的数据“y”(调用栈的最低有效字节)</li>
</ul>
<p>你可以简单把内存位置理解成数组的索引，如果要读写超过1字节的数据，只需在下一个索引继续读写。</p>
<h2 id="evm-playground">EVM Playground</h2>
<p>这个 <a href="#evm-playground">EVM
playground</a>(https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code='Vg<em>(<em>I...1W0GJ</em>!!!!z00FK22WJQ0Y22z20F8K33W33Q1Y33z21F8d(v0Z0-Jq00Xd(vJZJ-64q20Xdv33Z33-65q21Xpp'~N
locatioCzG1_wppVv7o7hBcall stack from~uIIIIq( ofNzpbytegSTOREdw)</em>_
0xZ9BY9Chex}zXpM)
可以巩固理解这三个opcode和内存是怎么工作的。点击Run和右上角的弯箭头一步一步执行，可以看到调用栈和内存的变化(每一部分都有注释)。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe3e29126-2954-40e3-bc1b-7ca5e780fd1c_1500x850.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe3e29126-2954-40e3-bc1b-7ca5e780fd1c_1500x850.png"
alt="img" /></a></p>
<p>使用这个的时候你会发现一些奇怪的事情，首先当我们用MSTORE8把一个单字节数据0x22写进内存时，内存从这样</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F954d54e6-0bce-4de3-a61d-dd41fdae49c7_836x152.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F954d54e6-0bce-4de3-a61d-dd41fdae49c7_836x152.png"
alt="img" /></a></p>
<p>变成了这样</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F225fde5a-09bf-4a24-a702-88ad5010951e_836x176.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F225fde5a-09bf-4a24-a702-88ad5010951e_836x176.png"
alt="img" /></a></p>
<p>你可能会问，我只加了一字节，怎么补了这么多的0？</p>
<h3 id="内存扩展">内存扩展</h3>
<p>合约往内存里写数据是要根据数据大小付费的，如果要写在之前没写过的区域，还会收取首次使用的附加费用。没写过的区域是会按照32字节的增量增加的。</p>
<blockquote>
<p>前724字节，内存扩展的花费成线性增长，后边按照二次方增长</p>
</blockquote>
<p>因为我们刚刚初始化所以到处都是初始化为0的内存区域，又因为增量是32字节，就看到了内存被追加写入了2200000000000000000000000000000000000000000000000000000000000000</p>
<h3 id="牢记内存是个字节数组">牢记内存是个字节数组</h3>
<p>在33 (0x21)处跑MLOAD发现了第二件事，调用栈返回了这个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3300000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>
<p>牢记内存就是一个字节数组，我们可以在任何位置读写它，不一定是32的倍数，它记录线性的、字节级别的位置</p>
<blockquote>
<p>内存只能被函数创建。可以是复杂类型比如数组和结构体的实例化，也可能是从存储区(storage)复制过来的引用变量。</p>
</blockquote>
<p>了解了内存的数据结构之后我们老看一下空闲内存指针。</p>
<h2 id="空闲内存指针">空闲内存指针</h2>
<p>空闲内存指针就是一个简单的指向未使用内存开始处的指针，它可以确保智能合约可以记录哪些内存位置被写入了、哪些没被写入。这避免了合约用本应申请新内存的其他变量去覆盖老数据。当变量需要被写入内存时，合约会根据空闲内存指针确认数据应该写到哪里。</p>
<p>写入之后空闲内存指针会更新，根据写入数据大小确定新指针位置。像这样用一个简单的两数相加，算出新的空闲内存从哪开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">freeMemoryPointer + dataSizeBytes = newFreeMemoryPointer </span><br></pre></td></tr></table></figure>
<h3 id="字节码">字节码</h3>
<p>根据上文所题，空闲内存指针是在字节码最前边的五个opcode声明的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60 80                       =   PUSH1 0x80</span><br><span class="line">60 40                       =   PUSH1 0x40</span><br><span class="line">52                          =   MSTORE  </span><br></pre></td></tr></table></figure>
<p>这实际上是在说空闲内存指针在0x40(十进制64)位置上，有一个值0x80(十进制128)。那么0x40和0x80是怎么来的呢？我们可以在下边表格看到：</p>
<blockquote>
<p>Solidity的内存布局将前4个32字节的插槽保留:</p>
<ul>
<li><code>0x00</code> - <code>0x3f</code> (64 bytes): 暂存空间(Scratch
space)</li>
<li><code>0x40</code> - <code>0x5f</code> (32 bytes): 空闲内训指针</li>
<li><code>0x60</code> - <code>0x7f</code> (32 bytes): 插槽0</li>
</ul>
</blockquote>
<p>我们可以看到0x40是Solidity定下的空闲内存指针的位置，而紧接着这四个保留值的内存地址即为0x80。</p>
<p>我们快速过一遍这四个保留值分别是干什么的：</p>
<ul>
<li>暂存空间, 用来给hash方法和内联汇编使用。</li>
<li>空闲内存指针,
记录当前已分配的内存大小，空闲内存的起点，初始值0x80。</li>
<li>插槽0，用作动态内存数组的初始值，不会被写入。</li>
</ul>
<h3 id="合约里的内存">合约里的内存</h3>
<p>我们巩固一下上边学到的知识，从真实的Solidity代码中看一下内存和空闲内存指针是如何更新的。我故意创建了一个很简单的MemoryLane合约，只有一个函数，里边声明了长度分别为5和2的梁哥数组，然后把b[0]赋1，尽管很简单，在这三行代码运行时依然发生了很多事。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F45614789-b470-43be-9bb5-f7e0aabf35b5_393x276.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F45614789-b470-43be-9bb5-f7e0aabf35b5_393x276.png"
alt="img" /></a></p>
<p>我们把代码复制到remix里，看看这段solidity代码在EVM里的工作细节。复制之后，把它编译部署了，运行memoryLane()函数然后进debug模式，能看见这个合约的opcodes。</p>
<p>我把opcodes简化了一下，删除JUMP和其他与内存操作无关的代码。代码中添加了注释，以提供上下文。代码分为6个不同的部分。大家可以把这六部分合在一起，在EVM
Playground里跑一下。</p>
<h3
id="空闲内存指针初始化evm-playground-lines-1-15">空闲内存指针初始化(EVM
Playground Lines 1-15)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">////////////////////////////////////////</span><br><span class="line">// Free Memory Pointer Initialisation //</span><br><span class="line">////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// value to store for free memory pointer 0x80 = 128 in decimal</span><br><span class="line">PUSH1 0x80</span><br><span class="line">// location for free memory pointer 0x40 = 64 in decimal</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MSTORE</span><br><span class="line"></span><br><span class="line">// jump location (required to prevent stack underflow) </span><br><span class="line">PUSH2 0xffff</span><br></pre></td></tr></table></figure>
<p>首先，按照上边所讲的，初始化空闲内存指针，把0x80压进栈里，这是solidity内存布局规定的。在这段时间里，我们内存里什么都没有。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6437f902-7104-4009-8858-230d73a765a8_1066x198.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6437f902-7104-4009-8858-230d73a765a8_1066x198.png"
alt="img" /></a></p>
<p>然后我们再按照内存布局把空闲内存指针的地址0x40压栈。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F61258407-3f1c-44ff-a81f-982dc17a174e_1066x256.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F61258407-3f1c-44ff-a81f-982dc17a174e_1066x256.png"
alt="img" /></a></p>
<p>最后我们调用MSTORE把栈顶的0x40弹出来，0x40处的值为0x80，把它写入内存。</p>
<p>现在调用栈空了但是我们需要处理一些内存，这些内存是16进制，每一个字符对应4个比特位。现在我们有了192个16进制字符，也就是96字节(1字节=8位=2个十六进制字符)。</p>
<p>前边讲过前64字节是solidity布局规定的暂存空间，紧接着的32字节是空闲内存指针，正如下边所表示的这样：(译者注：这个Memory并不是显示MSTORE存进去什么，而是从头到位显示，直到后边全是未分配内存，所以把前边的暂存空间也显示出来了)</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F62ee6b98-6d06-4b91-a12a-45cc86a9ab5c_1066x304.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F62ee6b98-6d06-4b91-a12a-45cc86a9ab5c_1066x304.png"
alt="img" /></a></p>
<h3
id="变量-a-的内存分配和空闲内存指针更新-evm-playground-lines-16-34">变量
a 的内存分配和空闲内存指针更新 (EVM Playground Lines 16-34)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//////////////////////////////////////////////////////////////////</span><br><span class="line">// Memory Allocation Varibale “a” &amp; Free Memory Pointer Update ///</span><br><span class="line">//////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// load free memory pointer</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MLOAD</span><br><span class="line"></span><br><span class="line">// duplicate free memory pointer</span><br><span class="line">DUP1</span><br><span class="line">// 0xa0 = 160 in decimal, 32 * 5 = 160 first array is length 5</span><br><span class="line">PUSH1 0xa0</span><br><span class="line">// free memory pointer (0x80) + space for array (0xa0) = new free memory pointer</span><br><span class="line">ADD</span><br><span class="line">// Save this new value 0x120 to the free memory location</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MSTORE</span><br></pre></td></tr></table></figure>
<p>剩下的部分，在剩下的部分中，我们将跳过到每个部分的结束状态，并简要地说一下发生了什么。单独的opcode步骤可以在
<a href="https://www.evm.codes/playground">EVM
playground</a>里自行探索。下一个分配内存的是“a”
<code>(bytes32[5])</code>
，空闲内存指针也更新了。编译器会根据数组大小和元素大小决定分配多大的内存。</p>
<blockquote>
<p>牢记内存数组中的元素永远是32字节的倍数(bytes1[]也一样，但是bytes和string不是)。</p>
</blockquote>
<p>32字节倍数大小的数组会告诉我们需要分配多少内存。</p>
<p>那在这里就是5 * 32
也就是160或者说0xa0。我们可以看到它被压入堆栈并添加到当前空闲内存指针0x80(十进制为128)以获得新的空闲内存指针值。本来空闲内存指针在0x80(十进制128)，加上160后等于288，也就是16进制0x120，已经写到Memory上了。</p>
<p>调用栈里有变量a的内存起始地址0x80，以后可能会用到，0xffff是一个JuNP地址，跟内存操作无关可以忽略。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdf90605a-11c5-4d15-a055-b45dc6f93d9f_1066x378.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdf90605a-11c5-4d15-a055-b45dc6f93d9f_1066x378.png"
alt="img" /></a></p>
<h3 id="变量-a-的内存初始化-evm-playground-lines-35-95">变量 a
的内存初始化 (EVM Playground Lines 35-95)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/////////////////////////////////////////</span><br><span class="line">// Memory Initialisation Varaible “a” ///</span><br><span class="line">/////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// duplicate 0x80</span><br><span class="line">DUP1</span><br><span class="line">// push 0x05 = 5 in decimal (array length)</span><br><span class="line">PUSH1 0x05</span><br><span class="line">// Swap the top 2 items on the stack in this case 0x05 and 0x80</span><br><span class="line">SWAP1</span><br><span class="line">// push 0x20 = 32 in decimal (array item size)</span><br><span class="line">PUSH1 0x20</span><br><span class="line">// Duplicate the 3rd item on the stack in this case 0x05 to the top of the stack</span><br><span class="line">DUP3</span><br><span class="line">// 0x05 * 0x20 = 5 * 32 in decmial = 160 on top of the stack (size of array in bytes)</span><br><span class="line">MUL</span><br><span class="line">// Duplicate 0xa0 = 160 in decimal</span><br><span class="line">DUP1</span><br><span class="line">// Returns size of calldata in bytes currently just function signature = 0x04 or 4 in decmial</span><br><span class="line">CALLDATASIZE</span><br><span class="line">// duplicate 4th item on stack (0x80)</span><br><span class="line">DUP4</span><br><span class="line">// 0x80 (byte offset in the memory where the result will be copied.), 0x04 (byte offset in the calldata to copy.), 0xa0 (byte size to copy.)</span><br><span class="line"></span><br><span class="line">// this offsets the 4 bytes in our call data with a size of 0xa0 which yeild a 160 bit set of 0&#x27;s to be stored at the free memory pointer location</span><br><span class="line"></span><br><span class="line">// this effectively initialises our array in memory </span><br><span class="line">CALLDATACOPY</span><br><span class="line"></span><br><span class="line">// The remaining lines in this section manipulate the stack to ensure we have the memory location of variable &quot;a&quot; and removes any items that are no longer needed</span><br><span class="line"></span><br><span class="line">// duplicate 0xa0</span><br><span class="line">DUP1</span><br><span class="line">// duplicate 0x80</span><br><span class="line">DUP3</span><br><span class="line">// new free memory pointer as before</span><br><span class="line">ADD</span><br><span class="line">// swap 1st (0x120) item on the stack and 3rd (0x80)</span><br><span class="line">SWAP2</span><br><span class="line">// pop top item off stack (0x80)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0xa0)</span><br><span class="line">POP</span><br><span class="line">// Swap top 2 items 0x120 &amp; 0x05</span><br><span class="line">SWAP1</span><br><span class="line">// pop top item off stack (0x05)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0x120)</span><br><span class="line">POP</span><br><span class="line">// swap top 2 items 0x80 &amp; 0xb6 (jump location)</span><br><span class="line">SWAP1</span><br><span class="line">// simulating a JUMP remove the top item off stack with POP</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// Simulated jump location</span><br><span class="line">PUSH2 0xffff</span><br><span class="line">// Simulated jump location</span><br><span class="line">PUSH2 0xffff</span><br><span class="line">// simulating a JUMP, remove the top item off stack with POP</span><br><span class="line">POP</span><br></pre></td></tr></table></figure>
<p>现在内存已经被分配了，空闲内存指针也更新了，我们需要初始化变量a的内存空间。变量只是声明却没被赋值，会被初始化为0。</p>
<p>为此EVM使用CALLDATACOPY，有三个参数：</p>
<ul>
<li>memoryOffset (数据拷贝的目标地址)</li>
<li>calldataOffset (待拷贝数据在calldata里的偏移量)</li>
<li>size (需要复制的大小)</li>
</ul>
<p>在这个例子里，memoryOffset是变量 a
的内存位置0x80。calldataOffset是待复制数据在calldata中的起点，因为我们反正不想复制任何calldata，就用0值初始化。最后size就是0xa0(十进制160)。</p>
<p>我们可以看到内存已经扩展到288字节了，调用栈又拿到了a的内存位置，还有一个无关痛痒的JUMP地址。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F77921922-6699-4ef7-a248-5b96667ac1cc_1066x548.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F77921922-6699-4ef7-a248-5b96667ac1cc_1066x548.png"
alt="img" /></a></p>
<h3
id="变量-b-的内存分配和空闲内存指针更新-evm-playground-lines-96-112">变量
b 的内存分配和空闲内存指针更新 (EVM Playground Lines 96-112)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/////////////////////////////////////////////////////////////////</span><br><span class="line">// Memory Allocation Varibale “b” &amp; Free Memory Pointer Update //</span><br><span class="line">/////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// free memory pointer load in </span><br><span class="line">PUSH1 0x40</span><br><span class="line">MLOAD</span><br><span class="line">// duplicate free memory pointer (0x120)</span><br><span class="line">DUP1</span><br><span class="line">// 0x40 = 64 in decimal, 32 * 2 = 64 second array is length 2</span><br><span class="line">PUSH1 0x40</span><br><span class="line">// free memory pointer (0x120) + space for array (0x40) = new free memory pointer</span><br><span class="line">ADD</span><br><span class="line">// save new free memory pointer value at free memory location 0x40</span><br><span class="line">PUSH1 0x40</span><br><span class="line">MSTORE</span><br></pre></td></tr></table></figure>
<p>和 a
一样，对<code>“bytes32[2] memory b”</code>也要做内存申请和更新空闲内存指针。空闲内存指针更新到0x160(即十进制的352
= 288 + 2 * 32)。内存里显示空白内存指针已更新，栈上也有了变量 b
的内存地址0x120。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6d38d4d0-f02f-4f85-a16e-11a3687ae095_1066x610.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F6d38d4d0-f02f-4f85-a16e-11a3687ae095_1066x610.png"
alt="img" /></a></p>
<h3 id="变量-b-的内存初始化-evm-playground-lines-113-162">变量 b
的内存初始化 (EVM Playground Lines 113-162)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">////////////////////////////////////////</span><br><span class="line">// Memory Initialisation Variable “b” //</span><br><span class="line">////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// duplicate 0x120 (memory start location for variable &quot;b&quot;)</span><br><span class="line">DUP1</span><br><span class="line">// 0x02 = 2 in decimal = array length</span><br><span class="line">PUSH1 0x02</span><br><span class="line">// swap top 2 items 0x02 &amp; 0x120</span><br><span class="line">SWAP1</span><br><span class="line">// 0x20 = 32 in decimal (array item size in bytes)</span><br><span class="line">PUSH1 0x20</span><br><span class="line">// duplicate 3rd item on the stack 0x02</span><br><span class="line">DUP3</span><br><span class="line">// 0x02 * 0x20 = 0x40 = 64 (amount of bytes in memory to initialise)</span><br><span class="line">MUL</span><br><span class="line">// duplicate 0x40 (free memory pointer location)</span><br><span class="line">DUP1</span><br><span class="line">// same as before 4 bytes for function signature 0x04</span><br><span class="line">CALLDATASIZE</span><br><span class="line">// duplicate 4th item on the stack = 0x120</span><br><span class="line">DUP4</span><br><span class="line">// 0x120 (byte offset in the memory where the result will be copied.), 0x04 (byte offset in the calldata to copy.), 0x40 (byte size to copy.)</span><br><span class="line">CALLDATACOPY</span><br><span class="line"></span><br><span class="line">// The remaining lines in this section manipulate the stack to ensure we have the memory location of variable &quot;a&quot; and removes any items that are no longer needed</span><br><span class="line"></span><br><span class="line">//duplicate the top of the stack 0x40</span><br><span class="line">DUP1</span><br><span class="line">// duplicate 3rd item on the stack 0x120</span><br><span class="line">DUP3</span><br><span class="line">// add together yields free memory pointer value</span><br><span class="line">ADD</span><br><span class="line">// swap 0x160 &amp; 0x120</span><br><span class="line">SWAP2</span><br><span class="line">// pop top item off stack (0x120)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0x40)</span><br><span class="line">POP</span><br><span class="line">// swap 0x160 &amp; 0x02</span><br><span class="line">SWAP1</span><br><span class="line">// pop top item off stack (0x02)</span><br><span class="line">POP</span><br><span class="line">// pop top item off stack (0x160)</span><br><span class="line">POP</span><br><span class="line">// jump location to top of the stack 0xbe</span><br><span class="line">SWAP1</span><br><span class="line">// simulate jump pop jump location off stack</span><br><span class="line">POP</span><br></pre></td></tr></table></figure>
<p>和变量 a
的初始化一样，现在内存已经扩展到352字节，栈里保存着两个变量的内存地址。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff45435da-8528-4e99-8a43-bab75decbf06_1066x630.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff45435da-8528-4e99-8a43-bab75decbf06_1066x630.png"
alt="img" /></a></p>
<h3 id="b0赋值-evm-playground-lines-163-207">b[0]赋值 (EVM Playground
Lines 163-207)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//////////////////////////</span><br><span class="line">// Assign Value to b[0] //</span><br><span class="line">//////////////////////////</span><br><span class="line"></span><br><span class="line">// push 0x01, value to add b[0]</span><br><span class="line">PUSH1 0x01</span><br><span class="line">// push 0x00</span><br><span class="line">PUSH1 0x00</span><br><span class="line">// left shift operation no shift, first input is 0 </span><br><span class="line">SHL</span><br><span class="line">// duplicate 2nd item on stack (0x120)</span><br><span class="line">DUP2</span><br><span class="line">// push 0x00 = [0] where in the array should this item go</span><br><span class="line">PUSH1 0x00</span><br><span class="line">// push 0x20 = 64 bytes the length of the array </span><br><span class="line">PUSH1 0x02</span><br><span class="line">// duplicate 2nd item on stack (0x00)</span><br><span class="line">DUP2</span><br><span class="line">// 0x00 &lt; 0x20 =  true = 0x01 (check the user is not trying to store a value at a location that doesn&#x27;t exist in the array)</span><br><span class="line">LT</span><br><span class="line">// jump location</span><br><span class="line">PUSH2 0x00d7</span><br><span class="line">// 2 POPs since this is a JUMPI (checking if LT returned true or false)</span><br><span class="line">// simulate JUMPI </span><br><span class="line">POP</span><br><span class="line">// simulate JUMPI </span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// push 0x20 (32 bytes aray item size)</span><br><span class="line">PUSH1 0x20</span><br><span class="line">// 0x20 * 0x00 = 0x00 = 0 in decimal (array item size * index to determine byte offset)</span><br><span class="line">MUL</span><br><span class="line">// 0x00 + 0x120</span><br><span class="line">ADD</span><br><span class="line">// duplicate 2nd on stack 0x01 (value for b[0])</span><br><span class="line">DUP2</span><br><span class="line">// duplicate 2nd on stack 0x120 (memory location for b[])</span><br><span class="line">DUP2</span><br><span class="line">// store 0x01 at memory location 0x120</span><br><span class="line">MSTORE</span><br><span class="line">// clean up stack</span><br><span class="line">POP</span><br><span class="line">POP</span><br><span class="line">POP</span><br><span class="line">POP</span><br></pre></td></tr></table></figure>
<p>最后一步我们需要给数组 b 的索引0处赋值，代码显示b[0] =
1。那么0x01压栈，紧接着一个左移opcode，但是参数是0，相当于没移。</p>
<p>接下来数组索引0也就是0x00会被压入栈中，然后检查这个值是否比数组长度0x02小，如果不是的话会跳到异常处理的部分。MUL和ADD可以根据数组的索引算出写入内存的位置，一个元素32，索引为0，则在0x00的偏移量开写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x20 (32 in decimal) * 0x00 (0 in decimal) = 0x00</span><br></pre></td></tr></table></figure>
<p>偏移量加上起始位置，最终算出来该值应该在0x120被写入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00 + 0x120 = 0x120 (288 in decimal)</span><br></pre></td></tr></table></figure>
<p>最后，我们把0x01写进0x120。</p>
<p>下图展示了这个函数执行完成后的状态，栈被弹空了。</p>
<p><strong><em>实际上在用remix中调用栈上还是会有一些条目，一个跳转地址和函数签名，但是与内存操作无关，就被EVM省略了</em></strong></p>
<p>我们的内存被更新成了b[0]=1，在倒数第三行。你也可以验证一下数据位置是否正确，b[0]应该在0x120
- 0x13f (289-320字节)。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fa5516282-632f-4af3-8e0f-40b07497a9d7_1066x578.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fa5516282-632f-4af3-8e0f-40b07497a9d7_1066x578.png"
alt="img" /></a></p>
<p>成了！这里信息量很大但我们现在理解已经很深刻了，下次写代码的时候也会有不小的帮助！以前挨行跑opcode的时候经常看见内存不断弹出0x40，现在知道为什么了。</p>
<p>这个系列的下一篇，我们会<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?s=r">揭开存储插槽的神秘面纱</a>。</p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>AAVE v3 技术说明</title>
    <url>/2022/07/09/aave-v3-techpaper/</url>
    <content><![CDATA[<h2 id="简介">1.简介</h2>
<p>2020年Aave协议于DeFi生态横空出世，前端开源并托管在IPFS上，在Aave治理模式的控制下，现在已经成为了最大的DeFi协议之一，巅峰流动性达到300亿美金。Aave的的很多关键feature(比如aToken，可选稳定利率与可变利率，信贷授权等等)都成为了行业标准，成为了DeFi协议的基础设施。但是跟所有的技术一样，Aave协议也会随着持续的研究、市场数据分析和社区反馈在一些方面进行迭代升级。</p>
<p>这次的提升在以下四个领域： 1. 资本效率 2. 协议安全 3. 去中心化 3.
用户体验</p>
<p>Aave
V3的设计实现了上述四类增强，改善了用户体验，在不牺牲安全性的前提下提高了资本效率。</p>
<p>在介绍V3新特性之前，我们在下一节中介绍一下这些四方面需要改进的原因。</p>
<h3 id="资本效率">1.1 资本效率</h3>
<p><strong>为流动性提供者创造更多收益</strong>
Aave协议在多个网络上的总流动性已经接近200亿美元，其中大多数都躺在合约里不动，仅仅从收到借款收益。尽管这笔收益稳定安逸，但是它完全可以给用户提供新的功能，在不增加风险的同时重新利用起来。(这并不包括把资金注入其它协议运作去流动性挖矿--
这会造成很大的风险，也不适合作为DeFi协议layer 0的Aave)</p>
<p><strong>优化借款能力</strong>
在以往的迭代中，由于在资产池模型中任何质押物都可以用来借入资产，借款人面临着最大化借款能力的挑战。也正因如此，借款交易的风险参数被设定的相当保守。</p>
<p><strong>低效的底层网络</strong>
Aave上的大多数资产都放在以太坊L1网络上。这个饱和的网络导致交易费比较高，也是用户的痛点。网络的低效率也会放映在预言机在短时间内提交准确价格的能力上。</p>
<p><strong>聚合流动性方法</strong>
在Aave协议里，用户的总质押量是所有质押物换算成某种基础货币(通常是eth)的量，总抵押量被用来计算平均借贷能力，即每种资产的借贷能力的加权平均值。总质押量和总借款量都是波动的，因此风控参数设置的比较保守。这在很多情况下限制了借款者的借贷能力，比如一个人质押稳定币去借稳定币，无论是借款还是质押的波动都是很小的，它理应有更强的担保能力。</p>
<p><strong>降低流动性隔离</strong>
新的流动性协议寻求提高担保能力，同时通过启用隔离的质押池或交易对来降低风险。尽管这会提高某些资产的担保能力，这实际上会使流动性隔离增加(流动性提供者必须要质押资产到不同池子/交易对里，才能满足其风险策略)和用户体验的问题(借款人可能被迫将抵押品分配到不同的池/对，才能借到他们需要的东西)。第二节会详细说明闲的的处理方案和提升。</p>
<h3 id="协议安全">1.2 协议安全</h3>
<p>风险管理是流动性协议的头等大事，它要降低智能合约风险和流动性风险。对于管理智能合约风险来说，代码review和每次代码更新、治理提案的审计都是必要的。这是一个链下/协调的问题，管理这种风险涉及到代码更新时的“mission-critical(关键业务)”文化。管理流动性风险更细致，包括市场调研，调整配置参数，以及社区对资产上市建议进行适当的尽职调查(Aave社区开发并维护了Aave风险框架)。</p>
<p>不幸的是，当前Aave协议迭代中的风险配置有限。尽管可以随时调整借贷能力(LTV)和维持保证金(清算阈值)，但如果增加对特定可能的打击(如无限铸币或预言机操纵)的防御措施，协议也会更加受益。</p>
<h3 id="去中心化">1.3 去中心化</h3>
<p>协议被AAVE持有者(“Aave
governance”)控制，是完全去中心化的，他们在协议配置上充当守门员的角色(比如加入新资产)，尽管这对保证协议安全很重要，但这希望往增加新资产的团队和项目来说是一种限制。</p>
<h3 id="用户体验">1.4 用户体验</h3>
<p>在多链世界里，允许流动性在不同链上无缝流动越来越重要了。尽管现在Aave协议也部署在过个网络里，但是用户还是不能从一个Aave到另一个网络的Aave传递流动性。</p>
<h2 id="目前的解决方案">2.目前的解决方案</h2>
<p>现在的某些流动性协议使用一些替代方案尤其是隔离交易对和隔离流动性池来解决这些问题。这些解决方案都寻求解决加入新资产时的权限问题和与之而来的风险，尽管他们的方法很有效果，但也反衬出了Aave
V优化这些模型带来的优越性。</p>
<h3 id="隔离交易对">2.1 隔离交易对</h3>
<p>这种方案通常被称为"隔离对"，因为借款者只能通过质押某种特定资产才能借到对应的某种资产，跟Aave
V2的聚合池方案相比有以下一些优点：</p>
<p><em>降低gas费</em>
通常情况下，隔离对方案因为不需要每次遍历所有资产，状态管理变少，导致了gas费降低</p>
<p><em>对新增资产限制降低</em> 只要风险系数调高任何资产都可以添加</p>
<p>然而这种设计对协议的可扩展性有影响。</p>
<p><strong>流动性的极端隔离</strong>
现在流动性被每种质押资产分隔开了，这意味着质押这需要把资产拆开分配到不同池子才能谋求最大收益。虽然这可以通过上层协议去聚合，但是也会降低用户对风险配置微调的能力，丧失了一部分优势。这也意味着每加入一个新交易对，都需要给它建立一次流动性，才能让用户借到这个资产。</p>
<p><strong>借款者糟糕的体验</strong>
在Aave协议里，借出资产可以简单理解为质押 +
借款，用户用起来很简单：只要质押量够，借款人可以直接接触任何资产，只需要管理一个状态(资债情况)。但是在隔离交易对方案里，如果借款人想借多种资产，它必须和很多交易对交互，甚至有时候只借一种资产也是这样，结果就是协议需要同时维护很多状态。这当然也可以通过上层协议去自动聚合来缓解，但是也降低了这种解决方案的优势(gas费)。流动性隔离通常也意味着更高的借款利率。</p>
<p><strong>倾向于高风险资产</strong>
一般而言，与较安全的资产相比，使用高风险资产作为抵押品的借款人(在其他流动性协议中)愿意支付更高的价格。这样的用户行为可能会允许某些潜在的攻击，新增某种没有债务上限的资产。
例如，用户可能会把稳定币冲进一个新创建的不稳定的池子来借出这个资产，这增加了对质押者的吸引力。</p>
<h3 id="隔离流动性池">2.2 隔离流动性池</h3>
<p>隔离流动性池的架构本质是Aave模式和隔离交易对模式的混合体，例如使用特定资产和自定义风险管理配置实例化独立市场的无权限协议。这种方法类似于Aave在2020年开创的以Uniswap
V1
LP资产为抵押的首个Uniswap池。拥有多个市场让用户能够在资产集群中分散风险，减少对潜在投资失败的影响，而不牺牲用户体验，并在流动性隔离方面做出一些妥协。</p>
<p>鉴于其独特的架构，也会和隔离交易对一样产生一些问题。尽管没有那么严重，流动性隔离仍然很重要——许多资金池难以吸引流动性。TVL通常也倾向于高风险资产。</p>
<h2 id="aave-v3-概述">3.Aave V3 概述</h2>
<p>Aave
V3脱胎于对协议与其生态演化的分析，特性的增强可以引起用户和开发者的创新浪潮。Aave
V3在上述四个方面都做了改进，同时提供新的方法增强rollup能力和生态在L1网络中的竞争力。</p>
<h3 id="资本效率和用户体验的提高">3.1 资本效率和用户体验的提高</h3>
<p><strong>传送门</strong>
传送门代表着一系列核心特性，他们可以允许Aave的资产在不同的网络中无缝流通，如果站在顶层设计来看的话原理很简单：aToken在源网络burn掉，然后在目标链上mint。这提供了一种以延迟方式提供资产的方法，其中底层的加密资产在通过规范链桥后被提供给Aave协议。关于设计的更多细节可以在4.5节中看到。</p>
<p><strong>E-Model</strong> 高效模式(High Efficiency Mode,
E-Model)允许借款人从他们的质押物中提取最高的借贷能力。现在可以对资产进行分类，每个类别都有以下风险管理参数:</p>
<ul>
<li>LTV(其实就是借款能力，有些合约称为质押系数)</li>
<li>清算阈值</li>
<li>清算激励系数</li>
<li>定制价格预言机(可选)</li>
</ul>
<p>E-Mode允许借款人限制自己只借入属于某一类的资产(比如稳定币)。当这种情况发生时，如果用户提供同类别的资产作为抵押品，LTV和清算阈值将被E-Mode配置覆盖，赋以更高的资金效率。详见图1的说明。</p>
<p>在V3里，Aave协议支持最多255种E-Mode类别，可以开启一波新用例的浪潮，比如：</p>
<ul>
<li>高效的流动性挖矿</li>
<li>多样化的风险管理</li>
</ul>
<p><strong>例子</strong> Aave协议把E-Mode第一类(稳定币)定义为：
97%的LTV，98%的清算阈值和2%的清算激励，没有定制预言机。</p>
<p><img src="figure1.jpg" title="图一" /></p>
<ol type="1">
<li>用户选择E- Mode的分类一，即稳定币</li>
<li>用户质押DAI(正常情况下的LTV为75%)</li>
<li>现在如果借E-Mode分类一里的资产就可以使用E-Mode的系数，即98%，资产利用率提高了23%。这些DAI依然可以作为质押物去借其他资产，但是只有在同一个E-Model里的资产能享受到更优惠的参数。</li>
</ol>
<p><strong>隔离模型</strong>
需要加强的最相关领域之一是风险的复杂性。当治理团队在Aave协议上新增一项资产时，使用它作为抵押品的借款人立即可以获得整个协议的流动性。这使得新资产的上市变得复杂，并降低了借款人的资本效率。因此，V3引入了隔离模式，其灵感来自于用于公开管理的MakerDAO方法。</p>
<p>现在资产可以以“隔离”的方式上市(在通过治理团队表决之后)。借款者质押了“隔离”的资产作为抵押物的同时不能把“非隔离”的资产作为质押物去借款(尽管可以冲进池子里拿收益)，隔离模式下只能借出由goverance指定的稳定币。</p>
<p>图2中有一个例子，用户提供 TOKEN2 作为抵押品。TOKEN2
是一种隔离资产，最高债务上限为 1000 万美元，USDT、DAI 和 USDC
作为「可借用」资产。在提供 TOKEN2 作为抵押品后，用户将能够借入高达 1000
万美元的 USDT、DAI 和 USDC。即使用户提供另一种资产，假设是 ETH，V3
智能合约也不会允许用户以这些资产为抵押借款。尽管用户仍将通过提供的 ETH
赚取收益。如果用户希望将所有资产用作抵押品并退出隔离模式，其只需进行交易以禁用
TOKEN2
作为抵押品（受智能合约中有关抵押品比率、清算等的所有通常限制）。</p>
<p><img src="figure2.jpg" title="图二" /></p>
<h3 id="风险管理">3.2 风险管理</h3>
<p>Aave
V3有更加精细的风控参数和特性去支撑协议的高安全性，以对抗破产风险。</p>
<p><em>存款与借款限额：</em>
治理团队现在可以设置存款和借款限额，借款限额和其它流动性合约一样，就是协议能调配某种资产的借款最大值。存款限额可以限制每种资产存进Aave协议的最大值，这有助于减少对某一资产的敞口，并降低无限铸币或预言机操纵等风险。</p>
<p><em>精细借款能力控制</em>
现在的流动性协议没法在不执行清算的情况下降低某种资产的借款能力，当某一资产的风险状况发生变化时，这种方法的局限性就很大。在Aave
V3中，通过精细借款能力控制，治理团队可以在不影响现有借款人的情况下，将任何资产的借贷能力降低至0%(尽管仍有可能在必要时清算现有用户)。</p>
<p><em>风控管理员</em> Aave
V3里治理团队创建实体并且移交权限，它可以越过投票修改风险系数，这个实体可以是DAO(例如RiskDAO)或者一个自动代理，可以在某些量被打破时自动做出反应。</p>
<p><em>价格预言机哨兵</em><br />
预言机哨兵特性是为了L2设计的，目的是处理排序器的最终停机时间（也可扩展到L1上以处理其他事件）。它引入了清算宽限期，并在特定情况下禁止借贷。</p>
<p><em>可变的清算关闭因子
（清算关闭因子就是允许一次清算掉被清算人质押物的比例）</em> 在Aave
V2里，每次只能清算头寸的一半，这在很多情况下是低效的，特别是高交易费或者小头寸的清算。在V3里，这一机制得到改进，可以在临近破产时完全平仓(HF&lt;0.95)。</p>
<h3 id="去中心化-1">3.3 去中心化</h3>
<p>Aave
V3引入了资产列表管理员的概念，治理团队可以创建并向任何实体（甚至是智能合约）授权，以实施新策略以将资产添加到Aave协议，而不是通过链上投票。这将允许构建者创建自定义资产列表策略，可以设计为带来真正的无权限资产列表。</p>
<h3 id="其它特性">3.4 其它特性</h3>
<ul>
<li>所有设计token转移的业务(质押，还债)都支持EIP 2612的permit函数</li>
<li>信用委托将支持EIP-712签名</li>
<li>用户可以使用aTokens代替原来借入的底层资产来偿还借入的头寸</li>
<li>治理团队可以让实体获得即时流动性</li>
<li>治理团队可以可以重新配置提供给 Aave DAO
财政部的清算或即时流动性交易的任何费用</li>
<li>新的 flashloanSimple() 减少了高达 20% 的 gas
消耗(标准的、功能齐全的功能仍然可用)</li>
<li>重写了价格预言机的逻辑，使基础资产的计算普遍化</li>
<li>尽管有了这些新功能，但所有功能的gas费都下降了约20 - 25%</li>
<li>代码重构后更加模块化</li>
<li>智能合约的代码变小了--最多能运行100K的<a
href="https://www.osgeo.cn/solidity/internals/optimizer.html">优化器</a></li>
<li>优化稳定利率计算的新策略，实现可以看这里：
https://governance.aave.com/t/base-stable-rate-oracle-update-and-improvements-in-aave-v2/1879，4.4也会深入探讨</li>
</ul>
<h2 id="特性说明">4.特性说明</h2>
<h3 id="e---mode">4.1 E - Mode</h3>
<p>当质押物和借出资产在价格上有相关性，甚至是同一种底层资产的衍生物时，E-Mode应运而生，它会最大化资本效率。稳定币通常与底层资产(比如USD)挂钩，剧烈脱钩事件发生的概率不大。ETH的衍生物如stETH,
sETH, alETH
等等，跟ETH脱钩的概率也不大，这样赋予它们互相之间高质押系数就很合理了。</p>
<p>在Aave协议以往的设计里，借款和质押物的价值是要换算成某种底层资产(如USD和ETH)来记录的，很难实现前文说的某种质押物对应某种借款，从而提升资本效率。</p>
<p>E-Mode引入了资产分类取代Aave协议的资产列表，在同一个分类里的资产通常在价格上有很强的相关性。分类不是在链上强制执行的，需要实体进行管理(比如governance)。</p>
<p>用户可以选择只借特定分类里的资产，当使用相同分类的质押物时就可以享受到高质押系数。</p>
<p>E-Mode
让每一个分类下的资产都可以使用特定的预言机。例如某一个分类里只有renBTC和WBTC，那么就可以给使用同一个
BTC/USD
预言机，可以消除预言机异步造成的不必要清算(在BTC价格大幅下跌的情况下，由于WBTC/USD和renBTC/USD是异步的，所以它们的更新时间可能略有不同，这可能会导致不必要的清算)。特定类别的预言机为协议带来了更多的风险，如果其中一项资产维持价格(例如，由于协议被黑客攻击或特定衍生品的潜在问题)，它可能会导致破产。
Aave治理需要在每个资产和每个类别的基础上仔细评估是否使用特定类别的预言机。基于以上原因，E-Mode适合更快的网络(尤其是rollup)，在这种网络中，预言机可以更高效，而且不会因为高交易成本而招致清算。</p>
<p><em>Category 0</em>
分类0是一个默认值，并不是E-Mode分类。所有的资产默认分类都是它。</p>
<p><em>Enter E-Mode</em>
如果用户所有借款都在某个分类里，它就可以进入这个分类的E-Mode
（分类0除外）</p>
<p><em>Exit E-Mode</em>
当头寸的HF&gt;=1即不存在清算风险时，用户才能退出E-Mode(设置分类为0)</p>
<p><em>User borrowing</em>
在E-Mode中的用户只能借当前分类的资产，他们可以使用其他分类的资产作抵押，但是只有同分类下的质押物享有高质押系数</p>
<p><em>Asset addition</em>
只有当E-Mode的LTV和清算阈值高于该资产默认的非E-Mode风险参数时，才可以通过授权实体(风险管理员或资金池管理员)将资产加入E-Mode</p>
<p><em>Asset removal</em>
资产可以通过授权实体(风险或池管理)从E-Mode中移除。这可能使一些用户的偿付能力陷入不必要的清算(见第4.7节)。根据设计，用户在E-Mode下借出资产，而该资产随后被从E-Mode类别中移除不受影响。在移除后，仍在E-Mode的用户将不能再借出该资产。</p>
<h3 id="隔离模式">4.2 隔离模式</h3>
<p>在包括Aave
V2在内的这一代流动性协议中，如果新增了一种资产，整个流动性池子都会对其暴露，这意味着用户可以用这个新资产作抵押借到整个流动性池子里的任意资产，这限制了Aave新增资产的自由度，因为这是一个风险很大的操作，隔离模式就是为了解决此问题诞生的。</p>
<p>隔离模式允许协议以“隔离”的方式加入新资产，隔离资产有一个特有的债务上限(debt
ceiling)，代表着可借的最大USD金额，精度为小数点后两位。使用隔离资产作为抵押的借款人只能使用该特定资产作为抵押，不能启用任何其他资产(包括其他隔离资产)。使用隔离资产的用户仍然可以通过其他资产的存款(supply)来产生收益。</p>
<p>可以在隔离模式借出的资产用BORROWABLE_IN_ISOLATION这个flag标记，尽管设计上可以选择任何资产，但还是应该选择USD的稳定币。可在隔离模式借入的资产必须属于同一类别，否则债务上限(debt
ceiling)的计算就会不一致。这种一致性不能在智能合约级别实现，治理团队在设置
BORROWABLE_IN_ISOLATION时应该小心。</p>
<p><em>Isolated assets</em><br />
任何一个债务上限(debt
ceiling)大于0的都是隔离资产(和borrowcap不同，borrowcap是所有token都有的)</p>
<p><em>Adding isolated asset</em><br />
资产只能在没有人质押的时候才能设置为隔离资产（由checkNoSuppliers()执行检查）</p>
<p><em>Isolated collateral</em>
使用隔离资产作为抵押品的用户将只被允许使用该资产作为抵押品</p>
<p><em>Supplying isolated</em>
提供其他资产并将其用作抵押品的用户，仍然可以提供隔离资产以产生收益。当用户已经提供了其他非隔离资产并启用了这些资产作为抵押时，应该永远不可能启用隔离资产作为抵押</p>
<p><em>Exit isolation mode</em>
用户可以通过禁用隔离资产作为抵押品来退出隔离模式。考虑到隔离资产的性质，只有当用户没有借款时才会发生这种情况</p>
<p><em>Removing asset from isolation mode</em>
授权实体可以随时把资产从隔离模式中移除</p>
<p><em>Debt ceiling</em>
如果达到隔离资产的债务上限，用户应被禁止借款(债务上限不包括随着时间的推移累积的利息，只包括借款的本金)</p>
<h3 id="精细借款能力控制">4.3 精细借款能力控制</h3>
<p>精细借款能力控制设计包括常规流动性协议采用的方法，即把质押能力分割为LTV和清算阈值。在Aave
V2里这个特性已经实现了，但是更倾向于是一种对抗借款者资不抵债的软性防护。</p>
<p>举个例子：</p>
<p>Alice
想用一个LTV=0，清算阈值&gt;0的资产来借款。这本应是不可能的，但是Alice可以这样做：</p>
<ol type="1">
<li>存一个LTV&gt;0的资产</li>
<li>存一个LTV=0的资产</li>
<li>借款</li>
<li>赎回LTV&gt;0的资产</li>
</ol>
<p>这就会留下一个LTV=0质押物的头寸(这一点我没理解，第4步应该会有undercollatealized判断，业务上不应该让它赎回的)</p>
<p>Aave
V3引入了更严格的LTV规则，所以现在可以强制执行实际的0借贷能力，同时防止上述情况的发生。这种保护要求借款人使用多个资产作为抵押——其中一个资产的LTV
== 0，要求借款人首先赎回这些资产，因此不能在那之前赎回LTV &gt;
0的资产。在上面的例子中，在V3中，Alice将被允许执行最后一步，但要先取出LTV
==
0的资产。因此V3完全避免了这种情况。一般来说，这种精细借款能力控制强制执行以下规则：</p>
<ul>
<li>用户可以抵押任何LTV &gt;0, 清算阈值&gt;0资产进行借款</li>
<li>如果某个资产的LTV被重置为0，那么用户就不能再以该资产为抵押借款了。</li>
<li>使用多种资产作为抵押的借款人，如果希望赎回，必须在赎回任何其他资产之前提取所有LTV=0的资产。取款和转账都是如此。不过，对于LTV不为0的资产，仍允许进行清算。</li>
<li>对于希望提高借贷能力(接近清算阈值)的借款人来说，使用上述例子中解释的程序仍然是可以接受的。<span
class="math inline">\(\Delta
LTV\)</span>↔︎清算阈值对借款人是一种软保护，是一种平均降低清算风险的方法，但对该协议而言，清算阈值仍被认为是安全的。</li>
</ul>
<h3 id="移除稳定利率预言机">4.4 移除稳定利率预言机</h3>
<p>正如治理论坛上讨论的那样，新的利率策略实现了一种管理稳定利率(stable)的算法。</p>
<p>在现在的实现里移除了稳定利率预言机转而使用利率策略，把最小的稳定欠款APR设置为
<span class="math inline">\(slope_{v,1}+offset_{base}\)</span>。
例如，对于一个stable offset =
2%的资产，在其最优利用率为90%时，其可变利率达到4%，那么其最小稳定利率将为6%。然后使用<span
class="math inline">\(slope_{s,1}\)</span>和<span
class="math inline">\(slope_{s,2}\)</span>计算利率，如果<span
class="math inline">\(O_{ratio}\)</span>在最佳范围外的话还要使用<span
class="math inline">\(offset_{excess}\)</span> 为计算稳定利率，设<span
class="math inline">\(O_{util}\)</span>和<span
class="math inline">\(O_{ratio}\)</span>分别为总负债率常数的最优利用率和最优稳定借款比例，则计算稳定利率公式如下:</p>
<p><img src="figure3.jpg" title="图三" /></p>
<h3 id="传送门">4.5 传送门</h3>
<p>传送门代表了一组核心功能，让Aave上的资产可以在不同链上自由转移，在顶层逻辑上很好理解：</p>
<p>Aave协议利用aToken的独特设计在源网络上燃烧aTokens，同时在目标网络上铸造aTokens。然后，基础资产可以以一种延迟的方式提供给目标网络上的Aave，即在其通过跨链桥后将其传递给流动性池。但是这对计算利率和目标网络上的市场安全有许多影响。</p>
<p>由于巧妙的设计，在协议层面实现这个只需要一个简单的方法。我们需要在协议加上三个特性：</p>
<ol type="1">
<li>铸造 “无担保(unbacked)”aToken</li>
<li>“无担保(unbacked)”aToken扶正为正常aToken</li>
<li>为想要使用这些特性的合同提供白名单机制。</li>
</ol>
<p>除了这些特性，还需要增加与无支持aToken相关的利率计算和储备金计算。</p>
<p>注意，铸造无担保aToken不会影响借款人的util(市场利用率，通常用于描述池子里借款与存款的比例，用来计算利率)，因为这一部分aToken没有加在流动性上(因为<span
class="math inline">\(util_{v2} =
util_{borrow}\)</span>)。但是它会加在存款者的uilt上，因为无担保aToken也是要生息的，这两部分的计算方法如下所示：</p>
<p><img src="figure4.jpg" title="图四" /></p>
<p>如公式6所示，增加无担保aToken将降低supply利用率，从而降低流动性提供者赚取的利息，因为它们被铸造的代币稀释了。为了抵消这种利息稀释，无担保aToken对应的资产会通过增加liquidity
index的方式提供一些费用支持。这个费用应该能覆盖铸造aToken产生的利息，所以为了让它满足弥补利息，应该满足以下条件：</p>
<p><img src="figure5.jpg" title="图五" /></p>
<p>虽然利率计算在核心协议里，但是上述部分的计算是在核心协议以外实现的。由于延迟供应和这部分费用计算没有在协议里强制执行，就需要治理者对传送门的授权慎之又慎。为了避免无限铸造无担保aToken产生的风险，会给每一个资产加一个标记“unbackedMintCap”。</p>
<h3 id="价格预言机哨兵">4.6 价格预言机哨兵</h3>
<p>如3.2小节所述，Aave V3引入了一个价格预言机哨兵(Price Oracle
Sentinel)来缓解在layer 2中可能出现的一些用户体验问题。</p>
<p><strong>浅谈Layer2</strong></p>
<p>目前的Layer2都是使用一个中心化的序列器产生块，然后用去中心化的方式验证(欺诈和有效性的证明)，以提高区块链的吞吐率。这种体系支持两种交易pending的队列，一种在链上，一种在链下，由sequencer操作。尽管sequencer可以使用两个队列的交易来出块，但是L1的pending事务通常可以推迟到某个截止日期，在此之后，用户可以强制执行一个操作，无论是zk-sync的包含模式还是退出模式。当sequencer遭遇停机的时候，这个“网络”就不会再更新状态了，没有新区块产生了。虽然仍然有可能将交易发送到pending的交易队列，但也没有什么会立即发生，链下的事务甚至可能被拒绝或删除，这取决于sequencer架构和停机的性质。</p>
<p>对于Aave和其他使用预言机喂价机制的系统，这意味着在sequencer停机的时候无法更新数据。只要sequencer停机，整个价格体系里都会出问题。这种不确定性和“慢速缓存崩溃”的可能性，以及L2交易直接在L1排队的情况是大多数正常用户遇不到的，致使Aave
V3在这些特定的情况下引入了清盘的宽限期。只要这个头寸没有严重的资不抵债(0.95
&lt; HF &lt;
1)，都会被设置一个宽限期。如果HF&lt;0.95，就可以完全按照L1进行平仓。注意，这个宽限期只有在sequencer已经停机的情况下才会被激活。在宽限期内，用户也不允许借款。</p>
<h3 id="系统身份与风险模式">4.7 系统身份与风险模式</h3>
<p>Aave协议实现了一个访问控制列表，以区别每个身份的权利与收益。这些身份在ACLManager合约中进行管理。ACLManager跟踪各个身份和身份的持有者，并允许身份管理员管理身份。身份管理员本身是一个由DEFAULT_ADMIN_ROLE管理的身份。</p>
<p>PoolAddressesProvider合约管理协议的各种组件(包括ACLManager和Pool)。PoolAddressesProvider跟踪各种协议模块，并有能力更新指针(例如更新ACLManager合约)或更新代理合约的实现(例如更新Pool的实现)。</p>
<p>PoolAddressesProvider由Aave
Governance拥有，并指定DEFAULT_ADMIN_ROLE的初始持有者。在以太坊以外的网络中，使用跨链桥(https://github.com/aave/governance-crosschain-bridges)，或者使用社区多签来管理PoolAddressesProvider。</p>
<p><big><big><strong>身份权责</strong></big></big></p>
<p>下面我们将概述这些身份的权责。FLASH_BORROWER和BRIDGE的直接责任很少，主要可以访问协议的特定特性，而管理员类型的身份有处理风险或配置参数的权力和责任。</p>
<p><em>FLASH BORROWER</em> 拥有这个身份的人将会免除闪电贷的保费</p>
<p><em>BRIDGE</em> 拥有这个身份的人可以执行 mintUnbacked()
和backUnbacked()</p>
<p><em>ASSET LISTING ADMIN</em> 拥有这个身份的人可以:
1.更新和回退资产的预言机源，2.给Aave市场增加新资产</p>
<p><em>RISK ADMIN</em> 拥有这个身份的人可以:
1.更新预言机哨兵的宽限期；2.更新储备金参数，如保留金因子，上限，E-Mode类别，借款，冻结/解冻，LTV，清算阈值，清算激励(不能暂停/恢复或激活/停用储备金)。3.创建新E-Mode类别或者更新E-Mode(除了分类0)。4.更新无担保猪鼻新航线与流动性池fee率。</p>
<p><em>ACL ADMIN</em> 拥有这个身份的人可以管理ACLManager里的身份。</p>
<p><em>EMERGENCY ADMIN</em>
拥有这个身份的人可以暂停和恢复资金池或者单个储备金。</p>
<p><em>POOL ADMIN</em>
拥有这个身份的人可以更新token的实现，移除，暂停/恢复储备金以及<em>RISK
ADMIN</em>和<em>ASSET LISTING ADMIN</em> 的所有权限</p>
<p><big><big>风险模式</big></big></p>
<p>下面概述潜在危害。由作恶的参与者引起，假如该参与者拥有这些身份之一：</p>
<p><em>ORACLES</em>
恶意的预言机可能会提供一个无效的价格，允许它借更多的钱，或者根据无效的价格进行清算。</p>
<p><em>SEQUENCER</em></p>
<p><em>FLASH BORROWER</em>
如果这个地址是一个proxy，任何人都可以通过它来申请闪电贷，从而免除所有费用。这将导致闪电贷不会给流动性提供者带来手续费。</p>
<p><em>BRIDGE</em>
如果拥有这一身份的合约/地址变得恶意(或有缺陷)，它可能会累积到无担保上限，并且永远不会扶正它，从而实际上允许它从流动性提供者那里窃取利益。</p>
<p><em>ASSET LISTING ADMIN</em>
攻击者可以更新预言机源，使协议处于与恶意预言机相同的状态。或者攻击者可以列出具有恶意aToken(或debt
token)实现的资产，允许他们取出用这些资产质押所借出的任何资金。</p>
<p><em>RISK ADMIN</em>
攻击者可以将清算阈值降为0并清算用户。这可以在同一个交易里中自动完成。</p>
<p><em>EMERGENCY ADMIN</em>
攻击者可以暂停安全的池子，也可以恢复不安全的池子。在市场崩溃的时候，攻击者可以关闭池自，然后自动执行顺序(打开-清算-关闭)，让他成为唯一的清算人。</p>
<p><em>POOL ADMIN</em> 这个攻击者可以实现<em>RISK ADMIN</em>和<em>ASSET
LISTING ADMIN</em>的所有攻击方式，或者可以更改一个token的实现方式。</p>
<p><em>ACL ADMIN</em> 这个人可能给自己任意其它身份进行攻击</p>
<p><em>ADDRESSES PROVIDER</em> 要是这个身份是恶意的那就彻底玩完了</p>
<p>Aave
governance会对控制这些潜在攻击，当治理团队将身份赋予特定的参与者时，它应该使用中间件合约来限制参与者的权限操作。例如，对于ASSET
LISTING ADMIN拒绝更改现有oracle，只允许添加。</p>
]]></content>
      <categories>
        <category>DeFi</category>
      </categories>
      <tags>
        <tag>DeFi</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解EVM - Part3 - 存储区</title>
    <url>/2022/06/22/Digging-Deep-EVM-Part3/</url>
    <content><![CDATA[<p>原文链接：https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea?s=
译者：<a href="alvan.coffe">Alvan's Blog</a></p>
<p>这是“深入理解EVM”系列的第三篇文章，需要<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?utm_source=url&amp;s=r">第一篇</a>
和<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b?s=r">第二篇</a>的前置知识，因此如果您没读过的话建议先读一下。在这一篇里，我们会仔细研究合约存储区是怎么工作的，提供一些有助于理解插槽包装(slot
packing)的思维方式，如果对装填插槽很陌生也不必担心，插槽包装的知识对EVM的骇客们至关重要，你也可以在本文结束时深刻了解它。</p>
<p>如果你玩过<a href="https://ethernaut.openzeppelin.com/">Ethernaut
Solidity Wargame Series</a>
或者其他Solidity的CTF赛事，就会知道装填插槽的知识经常是解决难题的关键。(译者注:
CTF全称Capture The
Flag，中文名夺旗赛，一般指网络安全领域的技术竞赛)。</p>
<h2 id="基础知识">基础知识</h2>
<p>在<a
href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/">“Program
the Blockchain”</a>
里对合约存储基础知识有一个相当完整的概述，我将回顾一下这篇文章里的关键知识点，当然也很推荐看一下这个全文。</p>
<h3 id="数据结构">数据结构</h3>
<p>我们先从合约存储的数据结构说起，这是我们理解其他知识的坚实基础。</p>
<p>合约存储就是一个简单的 k-v
map结构。32字节的key，32字节的value。key有32字节让我们可以拿到0到(2^256)-1的key值。</p>
<p>所有的value都会初始化为0，0不会显式写入。还挺有道理的，可观测宇宙里也是有
2^256 个原子。没有计算机能存储这个多的数据。存储区 value 置 0
返还gas，因为节点不用存储这些数据了。</p>
<p>你可以把存储区视为一个宇宙级的大数组，二进制 0 对应的 key
代表数组的第 0 个元素，二进制1对应的 key
代表数组的第一个元素，以此类推。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F13728261-0af4-4581-b03f-04057bdbb5dc_744x370.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F13728261-0af4-4581-b03f-04057bdbb5dc_744x370.png"
alt="img" /></a></p>
<h2 id="定长变量">定长变量</h2>
<p>声明为存储(storage)的的合约变量分为两种，定长变量和不定长变量。我们着重研究一下前者，看看EVM是怎么把定长便利那个装进32字节的插槽里的。关于不定长变量可以看一下<a
href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/">“Program
the Blockchain”</a> 这篇文章。</p>
<p>现在我们知道存储区是一个map，那么下一个问题就是怎么给key分配value。假设我们有以下代码。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F211a6f5d-9a81-41b9-9643-e31c141d0827_335x298.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F211a6f5d-9a81-41b9-9643-e31c141d0827_335x298.png"
alt="img" /></a></p>
<p>给定的变量都是定长的，EVM可以从 0 开始挨个装填，装完 0 装 1，装完 1
装
2，以此类推。排列顺序基于合约里变量声明的顺序，第一个被声明的变量会在0插槽。在这个例子里插槽0存储
value1，value2 是一个长度为 2 的数组，所以存在插槽1 和插槽2，value3
存储在插槽3，如下图所示：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F46352903-1395-49d0-a3a8-36b1bf5a3000_744x288.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F46352903-1395-49d0-a3a8-36b1bf5a3000_744x288.png"
alt="img" /></a></p>
<p>现在我们看一个类似的合约，猜下是怎么存的。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F48a5cb06-c390-4b92-8a20-39053f40d54c_335x316.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F48a5cb06-c390-4b92-8a20-39053f40d54c_335x316.png"
alt="img" /></a>注意变量类型不是 uint256</p>
<p>根据上一个例子你可能猜测我们会占用 0 到 3
插槽，因为有4个变量。但其实这个例子只占用了插槽0。这是变量类型不同造成的，之前我们用的都是
uint256 类型也就是32字节，在这里我们用的是 uint32，uint64 和
uint128，分别代表4字节，8字节和16字节的数据。</p>
<p>这就是插槽包装一词的由来。Solidity编译器知道一个插槽能装
32字节的数据， uint32 value1
装填在插槽0里只占用了4字节，等读到下一个可以装填的变量时，就会装进这个插槽。</p>
<p>(译者注：不知道你记不记得上一篇文章里有一个无法写入的0值插槽，它和插槽0是两个不同的东西，前者英文写作
zero slot，后者是 slot[0]，具体可见官方文档)</p>
<p>根据上边的例子我们开始从插槽0开始装填：</p>
<ul>
<li>value1 装进插槽0，占用4字节</li>
<li>插槽0剩余28字节</li>
<li>value2长4字节，小于等于28，装进插槽0</li>
<li>插槽0剩余24字节</li>
<li>value3长8字节，小于等于24，装进插槽0</li>
<li>插槽0剩余16字节</li>
<li>value4长16字节，小于等于16，装进插槽0</li>
<li>插槽0剩余0字节</li>
</ul>
<blockquote>
<p><em>注意uint8是solidity的最小类型，因此包装不能小于1字节(8位)</em></p>
</blockquote>
<p>下图展示了插槽0里存放的共32字节的4个变量。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdeb707da-60db-465d-a7c2-e45befefe3ff_744x434.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fdeb707da-60db-465d-a7c2-e45befefe3ff_744x434.png"
alt="img" /></a></p>
<h2 id="evm-storage-opcodes">EVM Storage Opcodes</h2>
<p>了解了存储区数据结构和插槽包装的原理只有我们看两个相关的opcode，SSTORE
和 SLOAD。</p>
<h3 id="sstore">SSTORE</h3>
<p>SSTORE 从调用栈取两个值，一个是32字节的 key，一个是32字节的
value。然后把 value 存在 key 值对应的插槽上，可以在<a
href="https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code=&#39;z1uFFv1%200w~z2uy8965w&#39;~\nz%2F%2F%20Example%20yv2%20w~SSTORE~v~PUSHuy0xFFuvwyz~_">这里</a>看到他是怎么工作的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Example 1</span><br><span class="line">PUSH2 0xFFFF</span><br><span class="line">PUSH1 0</span><br><span class="line">SSTORE</span><br><span class="line"></span><br><span class="line">//Example 2</span><br><span class="line">PUSH2 0xFF</span><br><span class="line">PUSH2 8965</span><br><span class="line">SSTORE</span><br></pre></td></tr></table></figure>
<h3 id="sload">SLOAD</h3>
<p>SLOAD 从调用栈拿32字节的 key 值，然后把 key 值插槽的 value
拿出来压到调用栈上，可以在<a
href="https://www.evm.codes/playground?unit=Wei&amp;codeType=Mnemonic&amp;code=&#39;wSet%20up%20thrstatez46z0~SSTOREy1z0vy2z1v~&#39;~\nz~PUSH1%20y~~wExamplrw%2F%2F%20v~SLOADre%20rvwyz~_">这里</a>看到他是怎么工作的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Set up the state</span><br><span class="line">PUSH1 46</span><br><span class="line">PUSH1 0</span><br><span class="line">SSTORE</span><br><span class="line"></span><br><span class="line">// Example 1</span><br><span class="line">PUSH1 0</span><br><span class="line">SLOAD</span><br><span class="line"></span><br><span class="line">//Example 2</span><br><span class="line">PUSH1 1</span><br><span class="line">SLOAD</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这时候你就要问了，如果 SSTORE 和 SLOAD
都是处理32字节的数据，那不足32字节被包装进插槽的怎么办呢？那上边的例子来说，我们
SLOAD 插槽0之后，拿到32字节数据，里边有 value1 到 value4
四个变量，EVM怎么知道要返回什么呢？SSTORE
也有同样的问题，如果我们每次都写32字节，那怎么确保 value2 不会覆盖
value1 呢，怎么确保 value3 不会覆盖 value2
呢？接下来我们将找出答案：</p>
<h2 id="存取被包装slot-packing的变量">存取被包装(slot
packing)的变量</h2>
<p>下边是一个仿照上个例子的合约，加上了一个方法，功能是存储然后读一个值去做算术操作。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F53bfa82f-b889-40c8-a407-3157f2e31385_457x452.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F53bfa82f-b889-40c8-a407-3157f2e31385_457x452.png"
alt="img" /></a></p>
<p>这个store()函数将会执行上边那些我们有疑问的操作：在不覆盖原有数据的情况下，将多个变量写进同一插槽，以及从插槽的32字节数据中取出我们想要的那个变量。</p>
<p>让我们看一看执行结束后，插槽0的最终状态，牢记十六进制数被机器识别为二进制码，它会在slot
packing中作为位运算的操作数。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3ce409fd-b942-42d7-b7ea-02c18c4a8993_782x338.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F3ce409fd-b942-42d7-b7ea-02c18c4a8993_782x338.png"
alt="img" /></a></p>
<p>记下 0x115c 为十进制 444，0x14d 为十进制 333，0x16 为十进制
22，0x01为十进制 1，与代码里的赋值相符，一个插槽持有 4 个变量。</p>
<h3 id="位运算">位运算</h3>
<p>Slot packing使用 AND，OR 和 NOT 三个位运算，对应 EVM 的 opcode
与之同名。让我们快速过一遍。</p>
<h4 id="and">AND</h4>
<p>下看下边的两个 8 位二进制数，AND
操作第一个数的第一位和第二个数的第一位，如果都是 1 的话结果的第一位就是
1 。否则为 0。之后算两个操作数的第二位，以此类推。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F50496d7f-3e74-404c-b71c-472cf2440c2c_466x302.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F50496d7f-3e74-404c-b71c-472cf2440c2c_466x302.png"
alt="img" /></a></p>
<h4 id="or">OR</h4>
<p>OR就是两个操作数中，每位只要有一个 1 值，结果的对应位就是 1，否则为
0。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F42a806e1-3da7-4a11-901d-47d40a85ba3f_466x302.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F42a806e1-3da7-4a11-901d-47d40a85ba3f_466x302.png"
alt="img" /></a></p>
<h4 id="not">NOT</h4>
<p>NOT 有些不一样，因为他只有一个操作数，效果就是对着每一位取反。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fed511be0-14bd-4f0e-adf5-e464e8cd7b4d_466x276.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fed511be0-14bd-4f0e-adf5-e464e8cd7b4d_466x276.png"
alt="img" /></a></p>
<p>现在看看他们是怎么应用于上边solidity例子里的。</p>
<h3 id="插槽操作存储包装变量sstore">插槽操作：存储包装变量SSTORE</h3>
<p>看一下solidity代码第18行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value2 = 22;</span><br></pre></td></tr></table></figure>
<p>在这时 value1
已经存进插槽0了，现在我们需要pack一些额外数据放进这个插槽。value3 和
value4
存储的时候也是一样的逻辑。我们来看一下理论上是怎么做的，也会提供一个EVM
playground强化理解。</p>
<p>我们从以下变量开始讲起</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F4fdcbc53-b6a6-4d10-892e-ff2d3b159f53_778x244.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F4fdcbc53-b6a6-4d10-892e-ff2d3b159f53_778x244.png"
alt="img" /></a></p>
<p>注意0xffffffff 是二进制 11111111111111111111111111111111。</p>
<p>EVM干的第一件事就是用 EXP
，输入一个基数一个指数返回计算结果。我们现在使用 0x100
作为基数，代表一个字节的偏移量，之后指数为 0x04，代表 value2
的起始位置。下图展示了这个返回值的作用：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff33571de-7414-4e29-9681-d2f9f5693550_1058x284.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff33571de-7414-4e29-9681-d2f9f5693550_1058x284.png"
alt="img" /></a></p>
<p>我们得到了EXP函数的返回值，现在可以把0x16写在正确的位置上，即4字节的位置。
(译者注：0x100 的 0x04 次幂，算出来是2 ^
8，也就是0x100000000，插槽从右往左装填，相当于从右到左偏移八位)</p>
<p>我们现在还不能写进去，因为已经存储的 value1
会被覆盖，这时候掩码就发挥作用了。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F71f004c0-6d1d-40b9-a83c-3355832e3138_1058x706.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F71f004c0-6d1d-40b9-a83c-3355832e3138_1058x706.png"
alt="img" /></a></p>
<p>上图展示了掩码是怎么发挥作用的，怎么拿数据可以把待写入那个区域单独无视，其他部分正常提取。在这个情况下
value2 想占用的区域已经都置零了，如果没置零，我们将看到数据被清除。</p>
<p>(译者注：掩码的原理很简单，就是用AND命令制造一个某区域为0，其它区域数值不变的方法，比如给定一个数
0x1010，我想把从左到右第三位隐藏，那么我可以制造一个数
0x1101，即待隐藏位置为 0 其它为 1，那么由于 0 和任何数and都是0，1
和任何数and结果都与该数一致，用0x1101 AND
0x1010，我们得到了一个0x1000，第三位被抹去了，其它位数不变。用在这里就是为了抹去对应位的原值)</p>
<p>这有另一个例子是我们把4个变量全部存进去的情况下把 value2 值从 22 改成
99。看到0x016 值被清除了。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F5c1522f7-9467-4116-9c3a-a076d0bc0fcd_1058x414.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F5c1522f7-9467-4116-9c3a-a076d0bc0fcd_1058x414.png"
alt="img" /></a></p>
<p>你可能正在想 OR 是怎么用上的，这张图会展示下一个步骤：</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fb9ff9609-0488-4684-848b-5d4245b0d966_1058x880.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fb9ff9609-0488-4684-848b-5d4245b0d966_1058x880.png"
alt="img" /></a></p>
<p>(译者注：就是把第一步计算的“只有
value2”的32字节数据与第二步计算的“隐藏了value2位置的32位数据”做OR操作，即可得到最终结果)</p>
<p>我们现在可以把包含 value1 和 value2 的
32字节数据写入插槽0了，他们都在正确的位置。</p>
<h3
id="插槽操作取出被包装的变量sload">插槽操作：取出被包装的变量SLOAD</h3>
<p>关于提取我们看一下solidity带么的22行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint96 value5 = value3 + uint32(666)</span><br></pre></td></tr></table></figure>
<p>我们只关心 value3
是怎么拿出来的，对它的算术计算不感兴趣。下面就是取出 value3
需要的数据，跟上边的不太一样。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fc8dffd1d-bcd2-461d-90c7-97287d7f0d2e_1148x204.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fc8dffd1d-bcd2-461d-90c7-97287d7f0d2e_1148x204.png"
alt="img" /></a></p>
<p>经过了一些修改，他们将会用于检索。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff55711ab-e05f-46a3-9291-c472409a7276_1058x672.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Ff55711ab-e05f-46a3-9291-c472409a7276_1058x672.png"
alt="img" /></a></p>
<p>我们现在从插槽0 里提取出了 value3，0x14d也就是十进制
333，跟solidity里看到的一样。
(译者注：就是和存储反过来了，先取出slot，再根据除法把待取一直右移到插槽最低位，最后用掩码把其它数据匿藏)</p>
<p>再次使用掩码和位操作和以帮助我们从32字节的插槽里准确提取数据，现在它放在栈上，可以执行
“value3 + uint32(666)” 了。</p>
<h2 id="evm-playground">EVM Playground</h2>
<p>这是store()的所有opcode了，你可以把它放在 <a
href="https://www.evm.codes/playground">EVM
playground</a>里跑一跑交互一下，会有一个直观的感受，可以看到调用栈和合约存储在你一步一步执行的时候是怎么变化的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// --------------------------------</span><br><span class="line">// Solidity Line 17 - &quot;value1 = 1;&quot;</span><br><span class="line">// --------------------------------</span><br><span class="line"></span><br><span class="line">PUSH1 0x01</span><br><span class="line">PUSH1 0x00</span><br><span class="line">DUP1</span><br><span class="line">PUSH2 0x0100</span><br><span class="line">EXP</span><br><span class="line">DUP2</span><br><span class="line">SLOAD</span><br><span class="line">DUP2</span><br><span class="line">PUSH4 0xffffffff</span><br><span class="line">MUL</span><br><span class="line">NOT</span><br><span class="line">AND</span><br><span class="line">SWAP1</span><br><span class="line">DUP4</span><br><span class="line">PUSH4 0xffffffff</span><br><span class="line">AND</span><br><span class="line">MUL</span><br><span class="line">OR</span><br><span class="line">SWAP1</span><br><span class="line">SSTORE</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// ---------------------------------</span><br><span class="line">// Solidity Line 18 - &quot;value2 = 22;&quot;</span><br><span class="line">// ---------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUSH1 0x16 // value2 = 22 decimal = 0x16 in hex</span><br><span class="line"></span><br><span class="line">PUSH1 0x00 // slot 0 - storage location for &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">PUSH1 0x04 // 4 bytes in - start position for &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">PUSH2 0x0100 // 0x100 in hex = 256 in decimal, 256 bits in 1 byte </span><br><span class="line"></span><br><span class="line">EXP // exponent of 0x0100 &amp; 0x04 = 0x100000000       </span><br><span class="line">    </span><br><span class="line">DUP2 // duplicate 0x00 to top of stack</span><br><span class="line"></span><br><span class="line">SLOAD // load data at slot 0</span><br><span class="line"></span><br><span class="line">DUP2 // duplicate exponent of 0x0100 &amp; 0x04 = 0x100000000</span><br><span class="line"></span><br><span class="line">PUSH4 0xffffffff // bitmask 4 bytes length      </span><br><span class="line"></span><br><span class="line">MUL // multiply to get bitmask for the 8 bytes assigned to &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">NOT // NOT operation to get bitmask for all bytes except the 8 bytes assigned to &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">AND // AND of bitmask and slot 0 value to zero out values in the 8 bytes assigned to &quot;value2&quot; and retain all other values</span><br><span class="line"></span><br><span class="line">SWAP1 // bring 0x100000000 to top of the stack</span><br><span class="line"></span><br><span class="line">DUP4 // duplicate value2 value = 22 = 0x16</span><br><span class="line"></span><br><span class="line">PUSH4 0xffffffff // bitmask 4 bytes length </span><br><span class="line"></span><br><span class="line">AND // AND to ensure the value is no more than 4 bytes in length</span><br><span class="line"></span><br><span class="line">MUL // returns value2 at the correct position - 4 bytes in</span><br><span class="line"></span><br><span class="line">OR // OR with previous value and the value AND yielded on line 38 gives us the 32 bytes that need to be stored</span><br><span class="line"></span><br><span class="line">SWAP1 // slot 0 to top of the stack</span><br><span class="line"></span><br><span class="line">SSTORE // store the 32 byte value at slot 0</span><br><span class="line"></span><br><span class="line">POP // pop 0x16 off the stack</span><br><span class="line"></span><br><span class="line">// ----------------------------------</span><br><span class="line">// Solidity Line 19 - &quot;value3 = 333;&quot;</span><br><span class="line">// ----------------------------------</span><br><span class="line"></span><br><span class="line">PUSH2 0x014d</span><br><span class="line">PUSH1 0x00</span><br><span class="line">PUSH1 0x08</span><br><span class="line">PUSH2 0x0100</span><br><span class="line">EXP</span><br><span class="line">DUP2</span><br><span class="line">SLOAD</span><br><span class="line">DUP2</span><br><span class="line">PUSH8 0xffffffffffffffff</span><br><span class="line">MUL</span><br><span class="line">NOT</span><br><span class="line">AND</span><br><span class="line">SWAP1</span><br><span class="line">DUP4</span><br><span class="line">PUSH8 0xffffffffffffffff</span><br><span class="line">AND</span><br><span class="line">MUL</span><br><span class="line">OR</span><br><span class="line">SWAP1</span><br><span class="line">SSTORE</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// -----------------------------------</span><br><span class="line">// Solidity Line 20 - &quot;value4 = 4444;&quot;</span><br><span class="line">// -----------------------------------</span><br><span class="line"></span><br><span class="line">PUSH2 0x115c</span><br><span class="line">PUSH1 0x00</span><br><span class="line">PUSH1 0x10</span><br><span class="line">PUSH2 0x0100</span><br><span class="line">EXP</span><br><span class="line">DUP2</span><br><span class="line">SLOAD</span><br><span class="line">DUP2</span><br><span class="line">PUSH16 0xffffffffffffffffffffffffffffffff</span><br><span class="line">MUL</span><br><span class="line">NOT</span><br><span class="line">AND</span><br><span class="line">SWAP1</span><br><span class="line">DUP4</span><br><span class="line">PUSH16 0xffffffffffffffffffffffffffffffff</span><br><span class="line">AND</span><br><span class="line">MUL</span><br><span class="line">OR</span><br><span class="line">SWAP1</span><br><span class="line">SSTORE</span><br><span class="line">POP</span><br><span class="line"></span><br><span class="line">// ----------------------------------------------------------</span><br><span class="line">// Solidity Line 22 - &quot;uint64 value5 = value3 + uint32(666);&quot;</span><br><span class="line">// ----------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUSH1 0x00</span><br><span class="line"></span><br><span class="line">PUSH2 0x029a // uint32(666)</span><br><span class="line"></span><br><span class="line">PUSH4 0xffffffff // bitmask 4 bytes length</span><br><span class="line"></span><br><span class="line">AND // ensure uint32(666) does not exceed 8 bytes, trim if it does </span><br><span class="line"></span><br><span class="line">PUSH1 0x00 // slot 0 - location of value3</span><br><span class="line"></span><br><span class="line">PUSH1 0x08 // 8 bytes in - start position for &quot;value3&quot;</span><br><span class="line"></span><br><span class="line">SWAP1 // bring 0x00 to top of stack for SLOAD of slot 0</span><br><span class="line"></span><br><span class="line">SLOAD // load data at slot 0</span><br><span class="line"></span><br><span class="line">SWAP1 // bring 0x08 to top of stack for EXP</span><br><span class="line"></span><br><span class="line">PUSH2 0x0100 // 256 bits in 1 byte </span><br><span class="line"></span><br><span class="line">EXP // exponent of 0x0100 &amp; 0x08 = 0x10000000000000000</span><br><span class="line"></span><br><span class="line">SWAP1 // get slot 0 value to top of stack</span><br><span class="line"></span><br><span class="line">DIV // DIV of slot 0 value with 0x10000000000000000 remove bottom 8 bytes  </span><br><span class="line"></span><br><span class="line">PUSH8 0xffffffffffffffff // bitmask 8 bytes length </span><br><span class="line"></span><br><span class="line">AND // Zero out bytes outside of the 8 byte mask to return variable &quot;value3&quot;</span><br><span class="line"></span><br><span class="line">// To see the rest of the opcodes for this calculation recreate the contract in remix and enter debugging mode</span><br></pre></td></tr></table></figure>
<p>在我们文章里提到的两个部分(solidity18行和22行)写了注释，强烈建议把这份代码拍一遍加深理解。</p>
<p><a
href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F2f0f0e5d-fd10-41d6-ad63-aa2b719f98d5_1497x847.png"><img
src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F2f0f0e5d-fd10-41d6-ad63-aa2b719f98d5_1497x847.png"
alt="img" /></a></p>
<p>你现在应该对存储插槽的工作原理和EVM存取插槽内特定位置数据有一定了解了，尽管SLOAD
和 SSTORE
两个opcode只能操作32字节数据，但是我们可以使用掩码和位运算存取想要的数据。</p>
<p>在这个系列的<a
href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-5a5?s=r">第四篇</a>，我们会学习Geth是怎么实现
SSTORE 和 SLOAD 操作码的。</p>
<p>希望对您有帮助！</p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>金融特化，现金交易，浅析新公链Aptos与Move语言</title>
    <url>/2022/08/29/aptos-and-move/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>Aptos 的 AIT3
注册快结束了，Alvan搞完节点也终于空出时间来整理一个关于Aptos和Move的分享，这篇文章会讲一下Aptos和Move的优势和特性，以及觉得它们中很有意思的地方。</p>
<h2 id="aptos的前世今生">Aptos的前世今生</h2>
<p>2019年有一个Libra项目后来改名diem，运营不善后diem项目组秽土转生出了分裂成了两个项目，aptos和sui，他们从diem继承的共同遗产就是move语言。</p>
<p>这两个是一个专注于高性能高安全,不兼容evm的layer1，pos机制。一个承袭了老项目多一点，一个自由发挥多一点。
aptos目前还处于测试阶段，根据项目方透露今年万圣节之前可以主网上线。</p>
<p>目前已经有四十多个项目已经宣布加入aptos生态，钱包和nft市场以及开发者工具之类项目量大管饱，但是目前真正完成并上线测试网并且开源的很少。一方面是由于现在版本迭代太快，不太稳定，另一方面就是很多solidity的团队需要时间去学习使用Move投入生产。</p>
<h2 id="aptos有哪些特性呢">Aptos有哪些特性呢</h2>
<p>Aptos其实写的很明白，它和其他传统区块链的最大区别就是高效(存疑)和安全。</p>
<p>第一点是使用了流水线模式，增强了并行程度，根据开发团队声称tps可以到十万，但是测试网明显没有压榨出最大的效率，究竟能达到什么程度持保留意见，毕竟以太坊升级之后的理想状态也是超过十万的。</p>
<p>第二点，我觉得这是它与以太坊差异最大的的设计，就像下图所示，</p>
<figure>
<img src="aptos分享稿.004.png" alt="aptos分享稿.004" />
<figcaption aria-hidden="true">aptos分享稿.004</figcaption>
</figure>
<p>以太坊的storage，是合约账户拥有的一块存储区，里边每个合约存储着不同人的账户信息，
aptos里的信息被称为resource资源，存在每一个外部账户的存储区里。
这有什么区别呢，要实现一个A token的记账，以太坊的做法是在A
token合约里存一个map，key是账户地址，value是账户余额，要空投币就是在合约内部去找key改value。而aptos的做法是在A
token合约里声明一个叫coin的resoure，然后把resource发送给用户，这样A
token就到了用户的存储区。如果对应现实世界的话，一种是记账模式，一种是现金模式。这个之后我们再讲。</p>
<h2 id="move语言又是何方神圣">Move语言又是何方神圣</h2>
<p>讲完aptos链本身，现在我们开始看看时薪1200刀的Move语言，它并不是一个新玩意了,Libra(Diem)时期就已经投产的语言，也被Sui和aptos继承了，现在最全的Move文档依然在Diem的网站下边挂着。</p>
<p>它脱胎于rust,很多设计和概念都有相似。Move声称对solidity的优势是安全高效，实际上rust对Cpp和GC语言的优势也分别是安全和高效,也就会围绕着这两点介绍move的特性。可能会涉及到一些概念没接触过也不要紧，我会简单说明一下，并不会耽误理解。</p>
<p>首先我们从安全说起，在我们编程的时候肯定会遇到一个重要的问题，如果它不是你编程时遇到的问题，那一定也是面试的时候一定会遇到问题，就是申请和回收内存。</p>
<p>C++在处理变量或者指针时，需要全程手动，所以C++程序员的心智负担很重，他也不知道哪里出现一个悬垂指针哪里有一个内存泄漏，软件的可靠性就会极度依赖开发者的水平。</p>
<p>Java和Go使用了GC机制，在运行的时候有一个GC程序监控记录引用情况，在变量失效时清除，这让程序员的日子好过不少，但是意味着一定会造成额外的性能开销。</p>
<p>那么有没有既不增加开销还能自动管理内存的方案呢？答案是肯定的，Rust或者说Move的
生命周期+所有权
是一个用语法规范内存操作的方案，可以把内存安全检测放在编译期解决。</p>
<p>简单来说像这段rust代码一样</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">timelife_and_ownership</span>()<span class="punctuation">-&gt;</span><span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> :<span class="type">String</span> = <span class="string">&quot;hello aptos&quot;</span>.<span class="title function_ invoke__">to_string</span>();<span class="comment">//x的生命周期开始，开辟内存</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y</span> :<span class="type">String</span> = <span class="string">&quot;hello move&quot;</span>.<span class="title function_ invoke__">to_string</span>();<span class="comment">//y的生命周期开始，开辟内存</span></span><br><span class="line">    &#125;<span class="comment">//y的生命周期结束，回收内存</span></span><br><span class="line">    <span class="comment">//println!(&quot;&#123;&#125;&quot;,y); error:cannot find value `y` in this scope</span></span><br><span class="line">    x</span><br><span class="line">&#125;<span class="comment">//x的生命周期结束，回收内存</span></span><br></pre></td></tr></table></figure>
<p>每一个变量有一个作用域，也就是一个大括号代码块。
当程序运行出代码块时，就把这块里声明的内存清理掉了。这样在编译期就能解决指针乱飞的问题，也不会造成额外开销，同时是把它变得高效的根本原因。</p>
<p>所有权又是什么呢？
在rust里，每一个变量都有一个所有者，其他变量想要使用它需要复制或者借用/引用。而move把这个思路用在了处理资源上，资源其实就是我们存储区上的数据，比如我们刚才说的A
token。</p>
<p>每一个资源有四个可选ability：Copy，Drop，Store，Key。Copy表示可以被复制，Drop的意思是可以销毁该资源，store表示可以存进全局也就是区块链，key表示该资源可以被检索。</p>
<p>他们之间也有一定耦合，比如一个拥有key的结构体，它里边的资源肯定是store的，这是不言自明的。使用的时候就是在声明变量的后边加上"has
copy"，‘has key’。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MessageHolder</span> has key &#123;</span><br><span class="line">        message: string::<span class="type">String</span>,</span><br><span class="line">        message_change_events: event::EventHandle&lt;MessageChangeEvent&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MessageChangeEvent</span> has drop, store &#123;</span><br><span class="line">        from_message: string::<span class="type">String</span>,</span><br><span class="line">        to_message: string::<span class="type">String</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们完全可以按照写程序的思维去理解它的顶层设计。上文提到了所有权和借用，当一个借用是不可变借用的时候它当然是安全的，如果是可变借用，那必须只有一个，不然这段代码就很难安全(最重要的是不知道什么时候释放)，尤其是在异步程序里。</p>
<p>在move里可变引用和不可变引用分别是borrow_global 和
borrow_global_mut</p>
<p>aptos官方的coin设计里是这样的</p>
<figure>
<img src="aptos分享稿.011.png" alt="aptos分享稿.011" />
<figcaption aria-hidden="true">aptos分享稿.011</figcaption>
</figure>
<p>某人持有的资金是存在自己存储区下的一个resource，我们暂且把它称为Coin，实现持有就是把amount放进一个没有copy和drop的资源Coin里，转账的时候是切割/合并Coin资源来实现。这样资源相当于被实体化了，在同一时间里想要有可变的Coin资源只能被一个所有者修改，避免了很多安全问题。跟以太坊的账户转账相比一个是账本模式一种现金模式。感觉有点UTXO的味道。</p>
<p>标准库代码：</p>
<p>这是标准coin的transfer函数，可以看到分为两步，发送方withdraw，接收方deposit。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Transfers `amount` of coins `CoinType` from `from` to `to`.</span></span><br><span class="line">    public entry fun transfer&lt;CoinType&gt;(</span><br><span class="line">        from: &amp;signer,</span><br><span class="line">        to: address,</span><br><span class="line">        amount: <span class="type">u64</span>,</span><br><span class="line">    ) acquires CoinStore &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">coin</span> = withdraw&lt;CoinType&gt;(from, amount);</span><br><span class="line">        <span class="title function_ invoke__">deposit</span>(to, coin);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>withdraw与extract函数，请看注释</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Withdraw specifed `amount` of coin `CoinType` from the signing account.</span></span><br><span class="line">    public fun withdraw&lt;CoinType&gt;(</span><br><span class="line">        account: &amp;signer,</span><br><span class="line">        amount: <span class="type">u64</span>,</span><br><span class="line">    ): Coin&lt;CoinType&gt; acquires CoinStore &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">account_addr</span> = signer::<span class="title function_ invoke__">address_of</span>(account);</span><br><span class="line">        <span class="built_in">assert!</span>(</span><br><span class="line">            is_account_registered&lt;CoinType&gt;(account_addr),</span><br><span class="line">            error::<span class="title function_ invoke__">not_found</span>(ECOIN_STORE_NOT_PUBLISHED),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//先用变量coin_store拿到account_addr中coin资源的所有权</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">coin_store</span> = borrow_global_mut&lt;CoinStore&lt;CoinType&gt;&gt;(account_addr);</span><br><span class="line"></span><br><span class="line">        event::emit_event&lt;WithdrawEvent&gt;(</span><br><span class="line">            &amp;<span class="keyword">mut</span> coin_store.withdraw_events,</span><br><span class="line">            WithdrawEvent &#123; amount &#125;,</span><br><span class="line">        );</span><br><span class="line">				<span class="comment">//分割coin，并返回一个coin</span></span><br><span class="line">        <span class="title function_ invoke__">extract</span>(&amp;<span class="keyword">mut</span> coin_store.coin, amount)</span><br><span class="line">    &#125;</span><br><span class="line">    public fun extract&lt;CoinType&gt;(coin: &amp;<span class="keyword">mut</span> Coin&lt;CoinType&gt;, amount: <span class="type">u64</span>): Coin&lt;CoinType&gt; &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(coin.value &gt;= amount, error::<span class="title function_ invoke__">invalid_argument</span>(EINSUFFICIENT_BALANCE));</span><br><span class="line">        <span class="comment">//修改传入coin的值</span></span><br><span class="line">        coin.value = coin.value - amount;</span><br><span class="line">        <span class="comment">//创建一个新coin并返回</span></span><br><span class="line">        Coin &#123; value: amount &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接收方的deposit就是上述操作的逆操作而已。我们可以在上述代码中看到所有权的流动。</p>
<p>我们再往下想从这个方面来讲，aptos里就没有了token和CryptoCurrency的高低贵贱之分，在以往以太坊里边eth是一等公民，erc20是二等公民，在aptos里所有的coin理论上都是同等地位，因为他们都是resource，也不用在写合约的时候把e
th和erc20每一个都写一个分支逻辑了。</p>
<p>从存储区的角度来说，一切信息存在用户处，合约反而成了一个纯粹的lib，这也使得合约的逻辑和存储天然分离，更有助于智能合约的去中心化。</p>
<h2 id="结语">结语</h2>
<p>Aptos的业务模型和Move合约的设计远远比高性能更让人拍案叫绝，在学习的时候忍不住把它们和rust联系起来(因为真的很像)，一点粗浅理解，还望诸君包涵！</p>
]]></content>
      <categories>
        <category>Aptos</category>
      </categories>
      <tags>
        <tag>Move</tag>
        <tag>Aptos</tag>
      </tags>
  </entry>
  <entry>
    <title>aptos初体验</title>
    <url>/2022/07/30/aptos-tutorial/</url>
    <content><![CDATA[<p>Aptos作为有背景有技术的新公链最近可谓吸满了投资，赚足了眼球。其从Libra和Diem继承来的技术又支持其超高tps和高安全高稳定的合约机制，官网上明晃晃的"Building
the safest and most scalable Layer 1
blockchain."彰显着这群前FB工程师的野心。我们今天便浅尝一下这个技术和资本共同的宠儿，Aptos和Move语言。</p>
<p>Aptos是一条不兼容evm的Layer1公链，其特点是高安全性，高稳定性，高扩展性以及高达100k+的恐怖tps。独特的存储模型使其可能在NFT和GameFi领域大展身手。合约语言为Move，是一个基于Rust的内存安全型合约语言，在Libra时期便已经成型，目前Sui和Aptos都在使用它构造"有史以来最高性能的公链"。据社交媒体透露，现在Move语言开发者的工资时薪已经高达$1200，这让我不禁留下了悔恨的口水，哦不是，泪水。</p>
<p>这篇文章将从头到尾体验一下在Aptos链上发起交易和编写合约，不需要编写代码。通过运行，测试aptos官方事例，阅读
move代码，感受这个号称最安全Layer1链的魅力。官方事例给出了TypeScript，Rust，和Python三种语言的代码，考虑到aptos-core本身是由Rust编写而且其合约语言Move又与Rust极度相似，本文使用Rust事例进行讲解。</p>
<h2 id="准备工作">0.准备工作</h2>
<p>安装rust，不多做介绍</p>
<p>下载aptos-core代码库
<code>git clone https://github.com/aptos-labs/aptos-core.git</code></p>
<p>进入代码库<code>cd aptos-core</code></p>
<p>切换分支<code>git checkout --track origin/devnet</code></p>
<p>运行启动脚本，构建开发环境<code>./scripts/dev_setup.sh</code></p>
<p>下载Aptos Commandline
tool命令行工具<code>cargo install --git https://github.com/aptos-labs/aptos-core.git aptos</code></p>
<h2 id="发起交易">1.发起交易</h2>
<p>这一部分代码在<code>aptos-core/developer-docs-site/static/examples/rust/first_transaction</code>里：</p>
<h3 id="创建账户">1.1 创建账户</h3>
<p>关于aptos的账户系统详情可以看官方文档:
https://aptos.dev/concepts/basics-accounts</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    signing_key: SecretKey,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">/// Represents an account as well as the private, public key-pair for the Aptos blockchain.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(priv_key_bytes: <span class="type">Option</span>&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">signing_key</span> = <span class="keyword">match</span> priv_key_bytes &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(key) =&gt; SecretKey::<span class="title function_ invoke__">from_bytes</span>(&amp;key).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rng</span> = rand::rngs::StdRng::<span class="title function_ invoke__">from_seed</span>(OsRng.<span class="title function_ invoke__">gen</span>());</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bytes</span> = [<span class="number">0</span>; <span class="number">32</span>];</span><br><span class="line">                rng.<span class="title function_ invoke__">fill_bytes</span>(&amp;<span class="keyword">mut</span> bytes);</span><br><span class="line">                SecretKey::<span class="title function_ invoke__">from_bytes</span>(&amp;bytes).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Account &#123; signing_key &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Returns the address associated with the given account</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">address</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">auth_key</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Returns the auth_key for the associated account</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">auth_key</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sha3</span> = Sha3::<span class="title function_ invoke__">v256</span>();</span><br><span class="line">        sha3.<span class="title function_ invoke__">update</span>(PublicKey::<span class="title function_ invoke__">from</span>(&amp;<span class="keyword">self</span>.signing_key).<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">        sha3.<span class="title function_ invoke__">update</span>(&amp;<span class="built_in">vec!</span>[<span class="number">0u8</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">output</span> = [<span class="number">0u8</span>; <span class="number">32</span>];</span><br><span class="line">        sha3.<span class="title function_ invoke__">finalize</span>(&amp;<span class="keyword">mut</span> output);</span><br><span class="line">        hex::<span class="title function_ invoke__">encode</span>(output)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Returns the public key for the associated account</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">pub_key</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        hex::<span class="title function_ invoke__">encode</span>(PublicKey::<span class="title function_ invoke__">from</span>(&amp;<span class="keyword">self</span>.signing_key).<span class="title function_ invoke__">as_bytes</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="准备一个rest接口包装器">1.2 准备一个REST接口包装器</h3>
<p>​ 构造一个RestClient，并连接测试网
https://fullnode.devnet.aptoslabs.com</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RestClient</span> &#123;</span><br><span class="line">    url: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///RestClient中的方法</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">RestClient</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//从url初始化client</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(url: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; url &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///Rest请求的具体实现,下边详细讲解</span></span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h4 id="读取账户信息">1.2.1 读取账户信息</h4>
<p>以下代码是通过账户地址读取账户信息的接口实现</p>
<p>值得注意的是account_resource接口，aptos的任何账户都有data存储，可以用来储存货币/NFT等等，这些信息被称为resource。</p>
<p>如果我们要查询某个账户的AptosCoin余额，就要定位到0x1::coin::CoinStore&lt;0x1::aptos_coin::AptosCoin，查询对应的resource数据，在1.2.3中account_balance就是复用了该接口。</p>
<p>这里的0x1实际上是一个account地址，因为AptosCoin是root账户0x1发行的，所以会出现0x1这种写法，类似写法在下文也会出现。而coin::CoinStore&lt;&gt;是aptos对代币的resource的一种特殊处理，以提供安全性。这样的话可以理解为查询该账户下，由0x1发行的AptosCoin的数目。</p>
<p>详情见aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 返回账户的私钥和序列码sequence_number，详情见https://aptos.dev/concepts/basics-accounts</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">account</span>(&amp;<span class="keyword">self</span>, account_address: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> serde_json::Value &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> =</span><br><span class="line">        reqwest::blocking::<span class="title function_ invoke__">get</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;/accounts/&#123;&#125;&quot;</span>, <span class="keyword">self</span>.url, account_address)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.<span class="title function_ invoke__">status</span>() != <span class="number">200</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            res.<span class="title function_ invoke__">status</span>(),</span><br><span class="line">            <span class="number">200</span>,</span><br><span class="line">            <span class="string">&quot;&#123;&#125; - &#123;&#125;&quot;</span>,</span><br><span class="line">            res.<span class="title function_ invoke__">text</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">            account_address,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_ invoke__">json</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 返回账户所有相关信息</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">account_resource</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    account_address: &amp;<span class="type">str</span>,</span><br><span class="line">    resource_type: &amp;<span class="type">str</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;serde_json::Value&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(<span class="built_in">format!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;&#125;/accounts/&#123;&#125;/resource/&#123;&#125;&quot;</span>,</span><br><span class="line">        <span class="keyword">self</span>.url, account_address, resource_type,</span><br><span class="line">    ))</span><br><span class="line">    .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.<span class="title function_ invoke__">status</span>() == <span class="number">404</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> res.<span class="title function_ invoke__">status</span>() != <span class="number">200</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            res.<span class="title function_ invoke__">status</span>(),</span><br><span class="line">            <span class="number">200</span>,</span><br><span class="line">            <span class="string">&quot;&#123;&#125; - &#123;&#125;&quot;</span>,</span><br><span class="line">            res.<span class="title function_ invoke__">text</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">            account_address,</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">unreachable!</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(res.<span class="title function_ invoke__">json</span>().<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="交易相关操作生成签名提交">1.2.2
交易相关操作(生成，签名，提交)</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Generates a transaction request that can be submitted to produce a raw transaction that can be signed, which upon being signed can be submitted to the blockchain.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">generate_transaction</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    sender: &amp;<span class="type">str</span>,</span><br><span class="line">    payload: serde_json::Value,</span><br><span class="line">) <span class="punctuation">-&gt;</span> serde_json::Value &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_res</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">account</span>(sender);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">seq_num</span> = account_res</span><br><span class="line">        .<span class="title function_ invoke__">get</span>(<span class="string">&quot;sequence_number&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">as_str</span>()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .parse::&lt;<span class="type">u64</span>&gt;()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unix timestamp, in seconds + 10 minutes</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expiration_time_secs</span> = SystemTime::<span class="title function_ invoke__">now</span>()</span><br><span class="line">        .<span class="title function_ invoke__">duration_since</span>(UNIX_EPOCH)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Time went backwards&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">as_secs</span>()</span><br><span class="line">        + <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line">    serde_json::json!(&#123;</span><br><span class="line">        <span class="string">&quot;sender&quot;</span>: <span class="built_in">format!</span>(<span class="string">&quot;0x&#123;&#125;&quot;</span>, sender),</span><br><span class="line">        <span class="string">&quot;sequence_number&quot;</span>: seq_num.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="string">&quot;max_gas_amount&quot;</span>: <span class="string">&quot;1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gas_unit_price&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gas_currency_code&quot;</span>: <span class="string">&quot;XUS&quot;</span>,</span><br><span class="line">        <span class="string">&quot;expiration_timestamp_secs&quot;</span>: expiration_time_secs.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        <span class="string">&quot;payload&quot;</span>: payload,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Converts a transaction request produced by `generate_transaction` into a properly signed transaction, which can then be submitted to the blockchain.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sign_transaction</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    account_from: &amp;<span class="keyword">mut</span> Account,</span><br><span class="line">    <span class="keyword">mut</span> txn_request: serde_json::Value,</span><br><span class="line">) <span class="punctuation">-&gt;</span> serde_json::Value &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::Client::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">post</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;/transactions/signing_message&quot;</span>, <span class="keyword">self</span>.url))</span><br><span class="line">        .<span class="title function_ invoke__">body</span>(txn_request.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">        .<span class="title function_ invoke__">send</span>()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.<span class="title function_ invoke__">status</span>() != <span class="number">200</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            res.<span class="title function_ invoke__">status</span>(),</span><br><span class="line">            <span class="number">200</span>,</span><br><span class="line">            <span class="string">&quot;&#123;&#125; - &#123;&#125;&quot;</span>,</span><br><span class="line">            res.<span class="title function_ invoke__">text</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">            txn_request.<span class="title function_ invoke__">as_str</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">body</span>: serde_json::Value = res.<span class="title function_ invoke__">json</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">to_sign_hex</span> = Box::<span class="title function_ invoke__">new</span>(body.<span class="title function_ invoke__">get</span>(<span class="string">&quot;message&quot;</span>).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_str</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">to_sign</span> = hex::<span class="title function_ invoke__">decode</span>(&amp;to_sign_hex[<span class="number">2</span>..]).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">signature</span>: <span class="type">String</span> = ExpandedSecretKey::<span class="title function_ invoke__">from</span>(&amp;account_from.signing_key)</span><br><span class="line">        .<span class="title function_ invoke__">sign</span>(&amp;to_sign, &amp;PublicKey::<span class="title function_ invoke__">from</span>(&amp;account_from.signing_key))</span><br><span class="line">        .<span class="title function_ invoke__">encode_hex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">signature_payload</span> = serde_json::json!(&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;ed25519_signature&quot;</span>,</span><br><span class="line">        <span class="string">&quot;public_key&quot;</span>: <span class="built_in">format!</span>(<span class="string">&quot;0x&#123;&#125;&quot;</span>, account_from.<span class="title function_ invoke__">pub_key</span>()),</span><br><span class="line">        <span class="string">&quot;signature&quot;</span>: <span class="built_in">format!</span>(<span class="string">&quot;0x&#123;&#125;&quot;</span>, signature),</span><br><span class="line">    &#125;);</span><br><span class="line">    txn_request</span><br><span class="line">        .<span class="title function_ invoke__">as_object_mut</span>()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">insert</span>(<span class="string">&quot;signature&quot;</span>.<span class="title function_ invoke__">to_string</span>(), signature_payload);</span><br><span class="line">    txn_request</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Submits a signed transaction to the blockchain.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">submit_transaction</span>(&amp;<span class="keyword">self</span>, txn_request: &amp;serde_json::Value) <span class="punctuation">-&gt;</span> serde_json::Value &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::Client::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">post</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;/transactions&quot;</span>, <span class="keyword">self</span>.url))</span><br><span class="line">        .<span class="title function_ invoke__">body</span>(txn_request.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">        .<span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">send</span>()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.<span class="title function_ invoke__">status</span>() != <span class="number">202</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            res.<span class="title function_ invoke__">status</span>(),</span><br><span class="line">            <span class="number">202</span>,</span><br><span class="line">            <span class="string">&quot;&#123;&#125; - &#123;&#125;&quot;</span>,</span><br><span class="line">            res.<span class="title function_ invoke__">text</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">            txn_request.<span class="title function_ invoke__">as_str</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_ invoke__">json</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Submits a signed transaction to the blockchain.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execution_transaction_with_payload</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    account_from: &amp;<span class="keyword">mut</span> Account,</span><br><span class="line">    payload: serde_json::Value,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">txn_request</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">generate_transaction</span>(&amp;account_from.<span class="title function_ invoke__">address</span>(), payload);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">signed_txn</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">sign_transaction</span>(account_from, txn_request);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">submit_transaction</span>(&amp;signed_txn);</span><br><span class="line">    res.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hash&quot;</span>).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_str</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">transaction_pending</span>(&amp;<span class="keyword">self</span>, transaction_hash: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;/transactions/&#123;&#125;&quot;</span>, <span class="keyword">self</span>.url, transaction_hash))</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.<span class="title function_ invoke__">status</span>() == <span class="number">404</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.<span class="title function_ invoke__">status</span>() != <span class="number">200</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            res.<span class="title function_ invoke__">status</span>(),</span><br><span class="line">            <span class="number">200</span>,</span><br><span class="line">            <span class="string">&quot;&#123;&#125; - &#123;&#125;&quot;</span>,</span><br><span class="line">            res.<span class="title function_ invoke__">text</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">            transaction_hash,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.json::&lt;serde_json::Value&gt;()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">get</span>(<span class="string">&quot;type&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">as_str</span>()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        == <span class="string">&quot;pending_transaction&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Waits up to 10 seconds for a transaction to move past pending state.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wait_for_transaction</span>(&amp;<span class="keyword">self</span>, txn_hash: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">self</span>.<span class="title function_ invoke__">transaction_pending</span>(txn_hash) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(count &lt; <span class="number">10</span>, <span class="string">&quot;transaction &#123;&#125; timed out&quot;</span>, txn_hash);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="构造交易逻辑">1.2.3 构造交易逻辑</h4>
<p>一个是account_balance，使用account_resource调用AptosCoin资源查询
另一个是transfer，使用的是0x1::coin::transfer也就是coin共有方法transfer</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/// Returns the test coin balance associated with the account</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">account_balance</span>(&amp;<span class="keyword">self</span>, account_address: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u64</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">account_resource</span>(</span><br><span class="line">            account_address,</span><br><span class="line">            <span class="string">&quot;0x1::coin::CoinStore&lt;0x1::aptos_coin::AptosCoin&gt;&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;coin&quot;</span>][<span class="string">&quot;value&quot;</span>]</span><br><span class="line">            .<span class="title function_ invoke__">as_str</span>()</span><br><span class="line">            .<span class="title function_ invoke__">and_then</span>(|s| s.parse::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">ok</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Transfer a given coin amount from a given Account to the recipient&#x27;s account address.</span></span><br><span class="line">    <span class="comment">/// Returns the sequence number of the transaction used to transfer</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">transfer</span>(&amp;<span class="keyword">self</span>, account_from: &amp;<span class="keyword">mut</span> Account, recipient: &amp;<span class="type">str</span>, amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">payload</span> = serde_json::json!(&#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;script_function_payload&quot;</span>,</span><br><span class="line">            <span class="string">&quot;function&quot;</span>: <span class="string">&quot;0x1::coin::transfer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type_arguments&quot;</span>: [<span class="string">&quot;0x1::aptos_coin::AptosCoin&quot;</span>],</span><br><span class="line">            <span class="string">&quot;arguments&quot;</span>: [<span class="built_in">format!</span>(<span class="string">&quot;0x&#123;&#125;&quot;</span>, recipient), amount.<span class="title function_ invoke__">to_string</span>()]</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">txn_request</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">generate_transaction</span>(&amp;account_from.<span class="title function_ invoke__">address</span>(), payload);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">signed_txn</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">sign_transaction</span>(account_from, txn_request);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">submit_transaction</span>(&amp;signed_txn);</span><br><span class="line"></span><br><span class="line">        res.<span class="title function_ invoke__">get</span>(<span class="string">&quot;hash&quot;</span>).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_str</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="准备一个水龙头接口包装器">1.3 准备一个水龙头接口包装器</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">FaucetClient</span> &#123;</span><br><span class="line">    url: <span class="type">String</span>,</span><br><span class="line">    rest_client: RestClient,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FaucetClient</span> &#123;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/// 水龙头可以创建账户并给其分配资产，这是一个包装器</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(url: <span class="type">String</span>, rest_client: RestClient) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; url, rest_client &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 给传入用户铸币</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fund_account</span>(&amp;<span class="keyword">self</span>, auth_key: &amp;<span class="type">str</span>, amount: <span class="type">u64</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::Client::<span class="title function_ invoke__">new</span>()</span><br><span class="line">            .<span class="title function_ invoke__">post</span>(<span class="built_in">format!</span>(</span><br><span class="line">                <span class="string">&quot;&#123;&#125;/mint?amount=&#123;&#125;&amp;auth_key=&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">self</span>.url, amount, auth_key</span><br><span class="line">            ))</span><br><span class="line">            .<span class="title function_ invoke__">send</span>()</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res.<span class="title function_ invoke__">status</span>() != <span class="number">200</span> &#123;</span><br><span class="line">            <span class="built_in">assert_eq!</span>(</span><br><span class="line">                res.<span class="title function_ invoke__">status</span>(),</span><br><span class="line">                <span class="number">200</span>,</span><br><span class="line">                <span class="string">&quot;&#123;&#125;&quot;</span>,</span><br><span class="line">                res.<span class="title function_ invoke__">text</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">txn_hash</span> <span class="keyword">in</span> res.json::&lt;serde_json::Value&gt;().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_array</span>().<span class="title function_ invoke__">unwrap</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.rest_client</span><br><span class="line">                .<span class="title function_ invoke__">wait_for_transaction</span>(txn_hash.<span class="title function_ invoke__">as_str</span>().<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行测试">1.4 运行测试</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rest_client</span> = RestClient::<span class="title function_ invoke__">new</span>(TESTNET_URL.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">faucet_client</span> = FaucetClient::<span class="title function_ invoke__">new</span>(FAUCET_URL.<span class="title function_ invoke__">to_string</span>(), rest_client.<span class="title function_ invoke__">clone</span>());</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//创建两个账户Alice和Bob，并用水龙头给Alice赚一笔账</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">alice</span> = Account::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bob</span> = Account::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n=== Addresses ===&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Alice: 0x&#123;&#125;&quot;</span>, alice.<span class="title function_ invoke__">address</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Bob: 0x&#123;&#125;&quot;</span>, bob.<span class="title function_ invoke__">address</span>());</span><br><span class="line"></span><br><span class="line">    faucet_client.<span class="title function_ invoke__">fund_account</span>(&amp;alice.<span class="title function_ invoke__">auth_key</span>().<span class="title function_ invoke__">as_str</span>(), <span class="number">1_000_000</span>);</span><br><span class="line">    faucet_client.<span class="title function_ invoke__">fund_account</span>(&amp;bob.<span class="title function_ invoke__">auth_key</span>().<span class="title function_ invoke__">as_str</span>(), <span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//调用account_balance查询账户余额</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n=== Initial Balances ===&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Alice: &#123;:?&#125;&quot;</span>, rest_client.<span class="title function_ invoke__">account_balance</span>(&amp;alice.<span class="title function_ invoke__">address</span>()));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Bob: &#123;:?&#125;&quot;</span>, rest_client.<span class="title function_ invoke__">account_balance</span>(&amp;bob.<span class="title function_ invoke__">address</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Alice构造一笔向bob转账1000的交易并提交等待完成</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx_hash</span> = rest_client.<span class="title function_ invoke__">transfer</span>(&amp;<span class="keyword">mut</span> alice, &amp;bob.<span class="title function_ invoke__">address</span>(), <span class="number">1_000</span>);</span><br><span class="line">    rest_client.<span class="title function_ invoke__">wait_for_transaction</span>(&amp;tx_hash);</span><br><span class="line">	  </span><br><span class="line">  	<span class="comment">//调用account_balance查询账户余额</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n=== Final Balances ===&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Alice: &#123;:?&#125;&quot;</span>, rest_client.<span class="title function_ invoke__">account_balance</span>(&amp;alice.<span class="title function_ invoke__">address</span>()));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Bob: &#123;:?&#125;&quot;</span>, rest_client.<span class="title function_ invoke__">account_balance</span>(&amp;bob.<span class="title function_ invoke__">address</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>cargo run --bin first-transaction</code>(运行前确保您在<code>aptos-core/developer-docs-site/static/examples/rust</code>目录下)</p>
<h3 id="输出">1.5 输出</h3>
<p>可以看到转账成功后Alice和Bob的余额(去掉gas费)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">=== Addresses ===</span><br><span class="line">Alice: e26d69b8d3ff12874358da6a4082a2ac</span><br><span class="line">Bob: c8585f009c8a90f22c6b603f28b9ed8c</span><br><span class="line"></span><br><span class="line">=== Initial Balances ===</span><br><span class="line">Alice: <span class="number">1000000000</span></span><br><span class="line">Bob: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">=== Final Balances ===</span><br><span class="line">Alice: <span class="number">999998957</span></span><br><span class="line">Bob: <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h2 id="玩转合约">2.玩转合约</h2>
<p>aptos链使用Move语言编写合约，其特点是安全稳定，语法上与Rust很像。</p>
<p>我们现在构建一个新的合约，在aptos的世界里称为module。</p>
<p>需要完成以下几个步骤：</p>
<p>1.编写，编译，测试module 2.部署module
3.与module的资源(存储区)交互</p>
<h3 id="阅读合约代码">2.1 阅读合约代码</h3>
<p>我们先进到<code>aptos-move/move-examples/hello_blockchain</code>目录里，我们暂且称其为“Move目录”，方便之后切换目录指称。</p>
<p>在这个目录里我们可以看到这个<code>sources/HelloBlockchain.move</code>文件，这个module可以让账户可以创建并修改一个String类型的资源，每个用户都只能操作自己的资源。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module HelloBlockchain::Message &#123;</span><br><span class="line">    <span class="keyword">use</span> std::string;</span><br><span class="line">    <span class="keyword">use</span> std::error;</span><br><span class="line">    <span class="keyword">use</span> std::signer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MessageHolder</span> has key &#123;</span><br><span class="line">        message: string::<span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">set_message</span>(account: signer, message_bytes: vector&lt;<span class="type">u8</span>&gt;)</span><br><span class="line">    acquires MessageHolder &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">message</span> = string::<span class="title function_ invoke__">utf8</span>(message_bytes);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">account_addr</span> = signer::<span class="title function_ invoke__">address_of</span>(&amp;account);</span><br><span class="line">        <span class="title function_ invoke__">if</span> (!exists&lt;MessageHolder&gt;(account_addr)) &#123;</span><br><span class="line">            <span class="title function_ invoke__">move_to</span>(&amp;account, MessageHolder &#123;</span><br><span class="line">                message,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">old_message_holder</span> = borrow_global_mut&lt;MessageHolder&gt;(account_addr);</span><br><span class="line">            old_message_holder.message = message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中有两个关键，一个是结构体<code>MessageHolder</code>
一个是函数 <code>set_message</code>。 <code>set_message</code>
是一个script函数，允许被交易直接调用，调用它之后函数会确认账户是否有<code>MessageHolder</code>
资源，没有的话就创建一个并把信息写入，有的话就覆盖掉。</p>
<h3 id="测试合约">2.2测试合约</h3>
<p>Move测试可以直接写在合约里，我们加上了一个sender_can_set_message测试函数，用cargo
test进行测试。</p>
<p>运行
<code>cargo test test_hello_blockchain -p move-examples -- --exact</code>
即可。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#[test(account = @0x1)]</span></span><br><span class="line"><span class="title function_ invoke__">public</span>(script) fun <span class="title function_ invoke__">sender_can_set_message</span>(account: signer) acquires MessageHolder &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">addr</span> = Signer::<span class="title function_ invoke__">address_of</span>(&amp;account);</span><br><span class="line">    <span class="title function_ invoke__">set_message</span>(account,  <span class="string">b&quot;Hello, Blockchain&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(</span><br><span class="line">      <span class="title function_ invoke__">get_message</span>(addr) == string::<span class="title function_ invoke__">utf8</span>(<span class="string">b&quot;Hello, Blockchain&quot;</span>),</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="部署合约">2.3部署合约</h3>
<p>现在我们回到之前transaction样例的同级目录，找到<code>developer-docs-site/static/examples/rust/hello_blockchain</code>查看部署和交互module的代码。这会复用一些上一节的函数。这一节我们只讨论新功能，比如部署module，<code>set_message</code>交易，以及读取<code>MessageHolder::message</code>资源，部署module和提交交易的区别就只有payload，我们开始看吧：</p>
<h4 id="部署module">2.3.1 部署module</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HelloBlockchainClient</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> rest_client: RestClient,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">HelloBlockchainClient</span> &#123;</span><br><span class="line">    <span class="comment">/// Represents an account as well as the private, public key-pair for the Aptos blockchain.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(url: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            rest_client: RestClient::<span class="title function_ invoke__">new</span>(url),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Publish a new module to the blockchain within the specified account</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">publish_module</span>(&amp;<span class="keyword">self</span>, account_from: &amp;<span class="keyword">mut</span> Account, module_hex: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">payload</span> = serde_json::json!(&#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module_bundle_payload&quot;</span>,</span><br><span class="line">            <span class="string">&quot;modules&quot;</span>: [&#123;<span class="string">&quot;bytecode&quot;</span>: <span class="built_in">format!</span>(<span class="string">&quot;0x&#123;&#125;&quot;</span>, module_hex)&#125;],</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">self</span>.rest_client</span><br><span class="line">            .<span class="title function_ invoke__">execution_transaction_with_payload</span>(account_from, payload)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h4 id="读取资源">2.3.2 读取资源</h4>
<p>Module 发布在一个地址上，就是下边的
<code>contract_address</code>。上一节转移Coin时候的0x1也是发布地址。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/// Retrieve the resource Message::MessageHolder::message</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_message</span>(&amp;<span class="keyword">self</span>, contract_address: &amp;<span class="type">str</span>, account_address: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">module_type</span> = <span class="built_in">format!</span>(<span class="string">&quot;0x&#123;&#125;::Message::MessageHolder&quot;</span>, contract_address);</span><br><span class="line">        <span class="keyword">self</span>.rest_client</span><br><span class="line">            .<span class="title function_ invoke__">account_resource</span>(account_address, &amp;module_type)</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|value| value[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;message&quot;</span>].<span class="title function_ invoke__">as_str</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="修改资源">2.3.3 修改资源</h4>
<p>Module必须暴露出script函数才能初始化和修改资源，script可以被交易调用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Potentially initialize and set the resource Message::MessageHolder::message</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_message</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    contract_address: &amp;<span class="type">str</span>,</span><br><span class="line">    account_from: &amp;<span class="keyword">mut</span> Account,</span><br><span class="line">    message: &amp;<span class="type">str</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message_hex</span> = hex::<span class="title function_ invoke__">encode</span>(message.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">payload</span> = serde_json::json!(&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;script_function_payload&quot;</span>,</span><br><span class="line">        <span class="string">&quot;function&quot;</span>: <span class="built_in">format!</span>(<span class="string">&quot;0x&#123;&#125;::Message::set_message&quot;</span>, contract_address),</span><br><span class="line">        <span class="string">&quot;type_arguments&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;arguments&quot;</span>: [message_hex]</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">self</span>.rest_client</span><br><span class="line">        .<span class="title function_ invoke__">execution_transaction_with_payload</span>(account_from, payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="初始化并交互">2.4 初始化并交互</h3>
<p>进入
<code>developer-docs-site/static/examples/rust</code>，我们姑且称为"App
目录"</p>
<p>运行 <code>cargo run --bin hello-blockchain -- Message.mv</code></p>
<p>过了一会，控制台会输出Alice与Bob的账户信息并显示<code>Update the module with Alice's address, build, copy to the provided path, and press enter.</code>，记录下Alice的地址，不要关闭</p>
<p>这时我们另起一个控制台，进入"Move目录"，将<code>hello_blockchain/move.toml</code>中的
<code>HelloBlockChain='_'</code>配置为Alice地址。</p>
<p>运行<code>aptos move compile --package-dir . --named-addresses HelloBlockchain=0x&#123;Alice的地址&#125;</code></p>
<p>Module编译成功，将<code>build/Examples/bytecode_modules/Message.mv</code>复制一份到<code>developer-docs-site/static/examples/rust</code></p>
<p>在"App 目录"的控制台输入回车让它继续运行</p>
<p>输出如果类似这样就是成功了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=== Addresses ===</span><br><span class="line">Alice: 11c32982d04fbcc79b694647edff88c5b5d5b1a99c9d2854039175facbeefb40</span><br><span class="line">Bob: 7ec8f962139943bc41c17a72e782b7729b1625cf65ed7812152a5677364a4f88</span><br><span class="line"></span><br><span class="line">=== Initial Balances ===</span><br><span class="line">Alice: 10000000</span><br><span class="line">Bob: 10000000</span><br><span class="line"></span><br><span class="line">Update the module with Alice&#x27;s address, build, copy to the provided path, and press enter.</span><br><span class="line"></span><br><span class="line">=== Testing Alice ===</span><br><span class="line">Publishing...</span><br><span class="line">Initial value: None</span><br><span class="line">Setting the message to &quot;Hello, Blockchain&quot;</span><br><span class="line">New value: Hello, Blockchain</span><br><span class="line"></span><br><span class="line">=== Testing Bob ===</span><br><span class="line">Initial value: None</span><br><span class="line">Setting the message to &quot;Hello, Blockchain&quot;</span><br><span class="line">New value: Hello, Blockchain</span><br></pre></td></tr></table></figure>
<p>证明了Alice和Bob都新创建了Message资源并置为"Hello, Blockchain"</p>
<h2 id="相关资料">3.相关资料</h2>
<p>Aptos 官方文档：https://aptos.dev
Move手册：https://move-language.github.io/move/
区块链浏览器：https://explorer.devnet.aptos.dev
api文档：https://fullnode.devnet.aptoslabs.com/spec.html#/</p>
]]></content>
      <categories>
        <category>Aptos</category>
      </categories>
      <tags>
        <tag>Aptos</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>基于bls12-381生成秘密随机点</title>
    <url>/2022/07/05/bls12-381-mpc/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>作者在搬groth16上链的项目里需要用到一些椭圆曲线上的秘密随机点(自然也可以把它当作root生成随机数)，需要用到MPC计算生成。记录一下算法和思路，加密部分使用bls12-381加密库。</p>
<h2 id="概述">概述</h2>
<p>因为在Groth16中需要使用到一系列的随机点进行掩藏数据，产生这些随机数的参数绝不能泄漏，比如bls12-381上的一个<span
class="math inline">\(\alpha\)</span>点来源<span
class="math inline">\(g_1\times
a\)</span>，由于陷门函数的特性，我们无法通过<span
class="math inline">\(\alpha\)</span>来推导出<span
class="math inline">\(a\)</span>，但是一旦<span
class="math inline">\(a\)</span>遭到泄漏，就可以直接计算出<span
class="math inline">\(\alpha\)</span>。</p>
<p>那么我们就需要一种在运算过程中不可能泄露<span
class="math inline">\(a\)</span>的方法去生成<span
class="math inline">\(\alpha\)</span>，这就可以转换成一个多方协同计算的问题：</p>
<p>假设有n个参与生成计算的节点参与，它们会依次提供<span
class="math inline">\(a_1，a_2，a_3...a_n\)</span>这n个随机数计算出<span
class="math inline">\(\alpha_1，\alpha_2...\alpha_n\)</span>，如果先计算<span
class="math inline">\(a\)</span>再进行隐藏：<span
class="math inline">\(\alpha=(\prod_{i=1}^n a_i)\times
g_1\)</span>，那么<span
class="math inline">\(a\)</span>和传输过程中的<span
class="math inline">\(a_i\)</span>都有可能泄露。</p>
<p>要将中间变量加密变成<span class="math inline">\(E(\prod_{i=1}^n
a_i)\)</span>和<span
class="math inline">\(E(a_i)\)</span>，才能在运行过程中不泄漏任何一个人提供的信息<span
class="math inline">\(a_i\)</span>，就可以保证每一个参与提供随机数的节点都不可能的知道最终的<span
class="math inline">\(a\)</span>，所有人拿到的只有加密后中间值。</p>
<h2 id="基本思路">基本思路</h2>
<p>可以预见的一点就是在依次计算的过程中，我们需要防止有人作恶，篡改之前的结果。如果第3个节点收到了加密数据<span
class="math inline">\(E(a_1\times
a_2)\)</span>，但是它传给下一个人的却是<span
class="math inline">\(E(a_3\times a_3 \times
a_3)\)</span>——擅自修改了内容，我们需要如何验证呢？</p>
<p>如果我们没有使用加密数据<span class="math inline">\(E(a_1\times
a_2)\)</span>和<span class="math inline">\(E(a_3\times a_3 \times
a_3)\)</span>，而是直接存储了<span class="math inline">\(a_1\times
a_2\)</span>，接受第三个节点的<span class="math inline">\(a_3\times a_3
\times a_3\)</span>和他自己的<span
class="math inline">\(a_3\)</span>，那么我们只需要验证上一次的结果<span
class="math inline">\(a_1\times a_2\)</span>与新节点提供的随机数<span
class="math inline">\(a_3\)</span>乘积是否等于它传给下一个人的<span
class="math inline">\(a_3\times a_3 \times a_3\)</span>，就可以了。</p>
<p>但是<strong>所有人拿到的只有加密后中间值</strong>，我们只要保证中间值的运算结果符合数字运算的规律，也就是“同态”即可。</p>
<p><strong>如果加密函数E(x)满足以下特性,则认为有同态性</strong> <span
class="math display">\[ 加法同态:E(a+b)=E(a)+E(b)  \\
乘法同态:E(ka)=kE(a)
\\双线性映射:假设有两个群G_1,G_2,G_1*G_1=G_2,g是G_1的生成元,e(g,g)是G_2的生成元,则
e(g^a,g^b)=e(g,g)^{ab}=e(g^b,g^a)\]</span></p>
<p>我们的bls12-381中也符条件，既 加法同态：<span
class="math inline">\((a_1+a_2)\times g_1 = a_1\times g_1 + a_2\times
g_1\)</span> 乘法同态：<span class="math inline">\(k \times (a_1\times
g_1) = (k\times a_1)\times g_1\)</span></p>
<p>双线性映射：<span class="math inline">\(pairing(a_1\times g_1 ,
a_2\times g_2) = pairing((a_1\times a_2)\times g_1，g_2)\)</span></p>
<h2 id="实现方法">实现方法</h2>
<p>我使用双线性映射来进行验证，第i个节点传输的数据为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone, Copy)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ParameterPair</span>&lt;E: Engine&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> g1_result: <span class="type">Option</span>&lt;E::G1Affine&gt;,<span class="comment">//传给下一个节点的数据,g1上的点,既(a1*a2*..ai * g1)</span></span><br><span class="line">    <span class="keyword">pub</span> g2_result: <span class="type">Option</span>&lt;E::G2Affine&gt;,<span class="comment">//传给下一个节点的数据,g2上的点,既(a1*a2*..ai * g2)</span></span><br><span class="line">    <span class="keyword">pub</span> g1_mine: <span class="type">Option</span>&lt;E::G1Affine&gt;,<span class="comment">//该节点新加入的数据,g1上的点,既(ai * g1)</span></span><br><span class="line">    <span class="keyword">pub</span> g2_mine: <span class="type">Option</span>&lt;E::G2Affine&gt;,<span class="comment">//该节点新加入的数据,g1上的点,既(ai * g2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证端保存着之前<span
class="math inline">\(i-1\)</span>个节点传输数据的列表：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="type">Vec</span>&lt;ParameterPair&lt;E&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>需要通过这个列表 的最新数据和节点自己的随机数更新信息：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mpc_common_paramters_custom</span>&lt;E&gt;(</span><br><span class="line">    paramter_last: &amp;ParameterPair&lt;E&gt;,</span><br><span class="line">    num: E::Fr,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;ParameterPair&lt;E&gt;, SynthesisError&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    E: Engine,</span><br><span class="line">    E::G1: WnafGroup,</span><br><span class="line">    E::G2: WnafGroup,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g1</span> = E::G1::<span class="title function_ invoke__">generator</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g2</span> = E::G2::<span class="title function_ invoke__">generator</span>();<span class="comment">//g1,g2是两个群上的元，类似于自然数中的1。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g1_before</span> = paramter_last.g1_result.<span class="title function_ invoke__">unwrap</span>();<span class="comment">//之前列表的最新值：a1*a2*...a(n-1) * g1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g1_after</span> = (g1_before * num).<span class="title function_ invoke__">to_affine</span>();<span class="comment">//预期中更新之后的值：a1*a2*...a(n-1)*a(n) * g1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g2_before</span> = paramter_last.g2_result.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g2_after</span> = (g2_before * num).<span class="title function_ invoke__">to_affine</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g1_mine</span> = (g1 * num).<span class="title function_ invoke__">to_affine</span>();<span class="comment">//a(n)*g1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g2_mine</span> = (g2 * num).<span class="title function_ invoke__">to_affine</span>();<span class="comment">//a(n)*g2</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = ParameterPair &#123;</span><br><span class="line">        g1_result: <span class="title function_ invoke__">Some</span>(g1_after),</span><br><span class="line">        g2_result: <span class="title function_ invoke__">Some</span>(g2_after),</span><br><span class="line">        g1_mine: <span class="title function_ invoke__">Some</span>(g1_mine),</span><br><span class="line">        g2_mine: <span class="title function_ invoke__">Some</span>(g2_mine),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在新增数据之前，可以通过该列表和新节点传入数据验证：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">verify_mpc_g1</span>&lt;E&gt;(new_paramter: &amp;ParameterPair&lt;E&gt;, paramters: &amp;<span class="type">Vec</span>&lt;ParameterPair&lt;E&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">bool</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    E: Engine,</span><br><span class="line">    E::G1: WnafGroup,</span><br><span class="line">    E::G2: WnafGroup,</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	*g1,g2是两个群上的元，类似于自然数中的1。</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g1</span> = E::G1::<span class="title function_ invoke__">generator</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g2</span> = E::G2::<span class="title function_ invoke__">generator</span>();</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	*这一步验证传来的结构体里g1,g2上的点是一一对应而非假造的，验证方法为：</span></span><br><span class="line"><span class="comment">		* pairing(g1_mine, g2)== E::pairing(g1, g2_mine);</span></span><br><span class="line"><span class="comment">		* pairing(g1_result, g2)== E::pairing(g1, g2_result);</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = E::<span class="title function_ invoke__">pairing</span>(&amp;new_paramter.g1_mine.<span class="title function_ invoke__">unwrap</span>(), &amp;g2.<span class="title function_ invoke__">to_affine</span>())</span><br><span class="line">        == E::<span class="title function_ invoke__">pairing</span>(&amp;g1.<span class="title function_ invoke__">to_affine</span>(), &amp;new_paramter.g2_mine.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">  	result = E::<span class="title function_ invoke__">pairing</span>(&amp;new_paramter.g1_result.<span class="title function_ invoke__">unwrap</span>(), &amp;g2.<span class="title function_ invoke__">to_affine</span>())</span><br><span class="line">        == E::<span class="title function_ invoke__">pairing</span>(&amp;g1.<span class="title function_ invoke__">to_affine</span>(), &amp;new_paramter.g2_result.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span> = paramters.<span class="title function_ invoke__">len</span>();</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		* 这一步用来验证第i个节点是否篡改了原来的数据：拿出一个进故宫验证的节点i-1的数据list[i-1]</span></span><br><span class="line"><span class="comment">		* 那么应该有：pairing(list[i-1].g1_result,new_paramter.g2_mine)==pairing(new_paramter.g1_result,g2)</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    <span class="title function_ invoke__">if</span> (index &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">paramter_last</span> = new_paramter.g1_result.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">paramter_part2</span> = new_paramter.g2_mine.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">paramter_part1</span> = paramters[index - <span class="number">1</span>].g1_result.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        result = result</span><br><span class="line">            &amp;&amp; E::<span class="title function_ invoke__">pairing</span>(&amp;paramter_last, &amp;g2.<span class="title function_ invoke__">to_affine</span>())</span><br><span class="line">                == E::<span class="title function_ invoke__">pairing</span>(&amp;paramter_part1, &amp;paramter_part2);</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果验证通过，再将该节点的信息加入进列表，进行下一轮计算。</p>
<p>最后拿到的g1_result和g2_result就是<span
class="math inline">\((\prod_{i=1}^n a_i)\times g_1\)</span>和<span
class="math inline">\((\prod_{i=1}^n a_i)\times
g_2\)</span>了，这同时我们确实没有泄露任何一个<span
class="math inline">\(a\)</span>，也避免了作恶。</p>
<h2 id="一些总结和延伸">一些总结和延伸</h2>
<p>大家应该可以看出这个实例也可以用同态加法或乘法来做，比如每个人传<span
class="math inline">\(a_i\times g_1\)</span>，然后维护一个<span
class="math inline">\((a_1+a_2+...+a_i)\times
g_1\)</span>来使用和验证即可。或者说任何一个同态加密方法都可以依照此法进行多方计算。</p>
<p>同态加密也可以用于验证信息，比如同一组信息分成几个碎片，通过这吸热碎片验证这个集体对某物的所有权，我们可以通过同态加密计算，每一个人的私钥碎片是<span
class="math inline">\(k_1,k_2...k_n\)</span>，私钥为<span
class="math inline">\(K=(\prod_{i=1}^n
k_i)\)</span>如何在不互通私钥信息的情况下一起生成一个私钥呢？可以把每一个私钥同态隐藏起来<span
class="math inline">\(E(k_i)\)</span>，计算<span
class="math inline">\(E(\prod_{i=1}^n k_i) = \prod_{i=1}^n
E(k_i)\)</span>来进行验证。</p>
<p>感谢您的观看，作者也是刚刚接触，如有错漏请诸君斧正。</p>
<p><a href="alvan.coffee">作者博客: alvan.coffee</a></p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>centos搭建rust环境的几个坑</title>
    <url>/2022/08/25/centos-update-clang/</url>
    <content><![CDATA[<p>这两天搭aptos测试网节点，本来以为像喝汤一样简单，对着手册突突突突弄下去就行了。没在新服务器上干过活，啥都要从头装，遇到了几个坑，记录一下</p>
<h2
id="clang版本太低centos是默认安装3.4版本rust要求至少3.9">1.clang版本太低，centos是默认安装3.4版本，rust要求至少3.9</h2>
<p>解决方法：</p>
<p>安装<code>llvm-toolset-7</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install centos-release-scl</span><br><span class="line">$ sudo yum install llvm-toolset-7</span><br></pre></td></tr></table></figure>
<p>开启 <code>llvm-toolset-7</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scl <span class="built_in">enable</span> llvm-toolset-7 bash</span><br></pre></td></tr></table></figure>
<p>检查一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ clang --version</span><br></pre></td></tr></table></figure>
<h2
id="gcc版本不匹配有些程序需要c17的特性centos用yum默认下载的版本也不对">2.gcc版本不匹配，有些程序需要C++17的特性，centos用yum默认下载的版本也不对</h2>
<p>解决方法：</p>
<p>安装 <code>devtoolset-8</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install centos-release-scl</span><br><span class="line">$ sudo yum install devtoolset-8</span><br></pre></td></tr></table></figure>
<p>开启 <code>devtoolset-8</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scl <span class="built_in">enable</span> devtoolset-8 bash</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello</title>
    <url>/2022/06/09/hello-world/</url>
    <content><![CDATA[<p>你好呀，我是张钰Alvan，主业是区块链/智能合约开发，了解一些defi项目，喜欢芥川龙之介和卡夫卡，希望能和更多的人交朋友！qq1541115709</p>
]]></content>
  </entry>
  <entry>
    <title>Move Prover 入门</title>
    <url>/2022/09/18/move-prover-guide/</url>
    <content><![CDATA[<figure>
<img
src="https://osec.io/blog/assets/posts/move-prover/move-prover-title.png"
alt="The Move Prover: A Practical Guide" />
<figcaption aria-hidden="true">The Move Prover: A Practical
Guide</figcaption>
</figure>
<p><em>形式化验证</em> -
一种验证程序正确性的强力工具。但它是如何工作的呢？这篇博客会介绍一些Move
Prover的使用技巧，充分利用其潜力，并探讨如何在一个实际例子中使用形式化验证去保证合约安全。</p>
<p>从上层看，形式化验证可以为程序提供规范，程序的符号输入会根据规范进行校验，并要求证明所有可能的输入都符合该规范。</p>
<h2 id="move-prover">Move Prover</h2>
<p>Move Prover是一个对Move语言智能合约形式化验证的自动化工具。</p>
<p>Move在设计上就是便于自动化验证的，更有趣的是Move
Prover也是操作MoveVM的字节码本身，这就避免了潜在的编译器错误影响证明程序的正确性。</p>
<p>Move Prover由多个组件构成，如下图所示：</p>
<figure>
<img src="https://i.imgur.com/ti4vkTu.png" alt="Move Prover arch" />
<figcaption aria-hidden="true">Move Prover arch</figcaption>
</figure>
<p>首先，Move Prover
接收一个Move源文件作为输入，该文件中需要设置程序输入规范。之后 Move
Parser 会在源码中把规范提取出来。Move
编译器将源文件编译为字节码，和规范系统(specification)共同转化为验证者对象模型(Prover
Object Model)。</p>
<p>这个模型会被翻译成一种名为<a
href="https://www.microsoft.com/en-us/research/project/boogie-an-intermediate-verification-language/">Boogie</a>的中间语言。这段
Boogie 代码会被传入 Boogie 验证系统，该系统对输入进行“验证条件生成”(<a
href="https://en.wikipedia.org/wiki/Verification_condition_generator">verification
condition generation</a>)。该验证条件(VC)会被传入一个名为 Z3
的自动理论验证器(<a
href="https://en.wikipedia.org/wiki/Automated_theorem_proving">automated
theorem prove</a>)中。</p>
<p>VC 被传进 Z3 程序后，该验证器会检查 SMT公式
是否是不可满足的。如果是这样，这意味着规范是成立的。否则，将生成一个满足条件的模型，并将其转换回Boogie格式，以便发布诊断报告。然后将诊断报告还原为与标准编译器错误类似的源码级错误。</p>
<p><em>译者注：SMT是形式语言与自动机的相关知识，有兴趣的读者可以搜索 SAT
与 SMT
进一步了解，大致意思就是SMT/SAT是一个公式，可满足性是指是否存在一组输入使其为真。</em></p>
<h2 id="move-specification-language">Move Specification Language</h2>
<p>MSL是Move语言的子集，它引入了对静态描述有关程序正确性的行为的支持，而不影响生产。</p>
<p>为了更好地理解使用MSL的方法，我们将使用<a
href="https://github.com/pontem-network/u256">Pontem’s U256
library</a>作为教学案例，这是一个实现U256的Move开源库。</p>
<p>U256是由一个包含4个u64的结构体实现的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">U256</span> has copy, drop, store &#123;</span><br><span class="line">    v0: <span class="type">u64</span>,</span><br><span class="line">    v1: <span class="type">u64</span>,</span><br><span class="line">    v2: <span class="type">u64</span>,</span><br><span class="line">    v3: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们聚焦到函数<code>add(a: U256, b: U256): U256</code>上。为了保证这样一个函数的正确性，验证一些群论的公理可能会有用处，比如交换律和结合律。</p>
<p>规范(specifications)被声明在“规范代码块”(specification
block，下均称spec代码块)中，它可能在Move
Module的函数中，也可能作为一个单独的规范module文件。</p>
<p>例如，如果你的文件是<code>sources/u256.move</code>,那你可以把规范放在<code>sources/u256.spec.move</code>里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spec add &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>放置在spec代码块中的规范被视为<em>表达式</em>。</p>
<h2 id="表达式">表达式</h2>
<p>我们先看一些通用表达式吧。</p>
<p><code>aborts_if</code>定义了函数应该何时终止(abort)。这在智能合约开发中非常有用，在合约里一个abort就可以导致整个交易回滚。</p>
<p>举个例子：当且仅当U256加法溢出的时候<code>add</code>函数abort。让我们把这句话变成表达式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> P64: <span class="type">u128</span> = <span class="number">0x10000000000000000</span>;</span><br><span class="line"></span><br><span class="line">spec fun <span class="title function_ invoke__">value_of_U256</span>(a: U256): num &#123;</span><br><span class="line">    a.v0 + </span><br><span class="line">    a.v1 * P64 + </span><br><span class="line">    a.v2 * P64 * P64 + </span><br><span class="line">    a.v3 * P64 * P64 * P64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spec add &#123;</span><br><span class="line">    aborts_if <span class="title function_ invoke__">value_of_U256</span>(a) + <span class="title function_ invoke__">value_of_U256</span>(b) &gt;= P64 * P64 * P64 * P64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在上边的代码片段中可以看到在spec代码块中可以调用函数。但是被调用者必须是一个MSL函数或者一个纯Move函数。纯Move函数就是不修改全局变量或者其使用的语句和特性均被MSL支持。</p>
<p><code>aborts_if</code> 的一个常见写法是
<code>aborts_if false</code>，它可以让一个函数验证永不abort。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spec critical_function &#123;</span><br><span class="line">    aborts_if false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个我们经常使用的表达式是
<code>ensures</code>，顾名思义，就是保证在函数运行的结尾确认一个状态。</p>
<p>在<code>add</code>函数的例子里我们希望确认返回值是两个参数之和。⚠️注意，因为MSL使用无界数，我们可以清楚这个表达式是不会溢出的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spec add &#123;</span><br><span class="line">    aborts_if value_of_U256(a) + value_of_U256(b) &gt;= P64 * P64 * P64 * P64;</span><br><span class="line">    ensures value_of_U256(result) == value_of_U256(a) + value_of_U256(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Move规范函数是用MSL写的，所以在这里不存在溢出风险。</p>
<p>让我们试着用上面的规范来验证这个库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ move prove</span><br></pre></td></tr></table></figure>
<p>报出以下错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[...]</span><br><span class="line"></span><br><span class="line">error: abort not covered by any of the `aborts_if` clauses</span><br><span class="line">╭     spec add &#123; </span><br><span class="line">|         aborts_if value_of_U256(a) + value_of_U256(b) &gt;= P64 * P64 * P64 * P64;</span><br><span class="line">|         ensures value_of_U256(result) == value_of_U256(a) + value_of_U256(b);</span><br><span class="line">|     &#125;</span><br><span class="line">╰─────^</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"> at ./sources/u256.move:316: add</span><br><span class="line"> enter loop, variable(s) carry, i, ret havocked and reassigned</span><br><span class="line">     carry = 54</span><br><span class="line">     i = 3792</span><br><span class="line">     ret = u256.U256&#123;v0 = 26418, v1 = 27938, v2 = 6900, v3 = 1999&#125;</span><br><span class="line"> at ./sources/u256.move:346: add</span><br><span class="line">     ABORTED</span><br><span class="line">     </span><br><span class="line">FAILURE proving 1 modules from package `u256` in 9.143s</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Error&quot;: &quot;Move Prover failed: exiting with verification errors&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证器说这个abort没有被abort_if覆盖到所以验证失败了，但是我们明明已经做到了全覆盖不是吗？</p>
<p>让我们继续看错误信息，会遇到一个意义不明的信息：<code>ret havocked and reassigned</code>.</p>
<p>这是什么意思？</p>
<p>深入理解Move Prover源码后，我们找到了一个<a
href="https://github.com/move-language/move/blob/e0dafc5cf3efe4c4e61411f10cdf0f379a36673c/language/move-prover/bytecode/src/loop_analysis.rs#L94">可能性怀疑</a>。验证器试图用归纳法证明所有的循环！</p>
<p>严格来说，它会把循环分解为两个关键步骤，遵循经典的归纳法证明</p>
<p>1.基本情况：对循环开始时的循环不变量进行断言
2.归纳：假设不变量，执行循环体，并断言不变量成立</p>
<p><em>译者注：此处和下面的 不变量，均为 invariant 和 invariants
的翻译，与 const常量 不同，不变量
并不是一个值，而代表一个状态，例如在某个循环中，a 永远小于 b，那么 a
&lt; b 是一个 循环不变量，其他 不变量 也类似。</em></p>
<p>循环证明程序还会把循环内的所有变量破坏和随机赋值。回到日志消息，这意味着变量<code>carry</code>，
<code>ret</code>和
<code>i</code>已经被破坏，或被分配了随机值。这也解释了为什么<code>add</code>的输入输出不灵了。</p>
<p>更具体地说，循环分析转换为以下步骤：</p>
<ol type="1">
<li>断言循环不变量</li>
<li>破坏所有修改过的变量</li>
<li>假设循环不变量</li>
<li>假设循环保护(while条件里的代码)</li>
<li>执行循环体</li>
<li>断言循环不变量</li>
</ol>
<p>这里有两种处理循环的解决方案</p>
<p>第一个是指定循环不变量。</p>
<p>为了指定循环不变量我们需要用到一些特殊的语法，在<a
href="https://osec.io/blog/tutorials/2022-09-06-move-introduction/">之前的一篇文章里</a>简单介绍过。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">while</span> (&#123;</span><br><span class="line">    spec &#123;</span><br><span class="line">        invariant <span class="title function_ invoke__">len</span>(amounts_times_coins) == i;</span><br><span class="line">        invariant i &lt;= n_coins;</span><br><span class="line">        invariant forall j <span class="keyword">in</span> <span class="number">0</span>..i: amounts_times_coins[j] == input[j] * n_coins;</span><br><span class="line">    &#125;;</span><br><span class="line">    (i &lt; n_coins)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    vector::<span class="title function_ invoke__">push_back</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> amounts_times_coins,</span><br><span class="line">        (*vector::<span class="title function_ invoke__">borrow</span>(&amp;input, (i <span class="keyword">as</span> <span class="type">u64</span>)) <span class="keyword">as</span> <span class="type">u128</span>) * (n_coins <span class="keyword">as</span> <span class="type">u128</span>)</span><br><span class="line">    );</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子里，括号中指明了<code>while</code>
循环中的循环不变量，请注意，由于循环不变量实在循环保护之后执行的，所以我们需要一个额外的步骤<code>i &lt;= n_coins</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (&#123;</span><br><span class="line">    spec &#123;</span><br><span class="line">        invariant len(amounts_times_coins) == i;</span><br><span class="line">        invariant i &lt;= n_coins;</span><br><span class="line">        invariant forall j in 0..i: amounts_times_coins[j] == input[j] * n_coins;</span><br><span class="line">    &#125;;</span><br><span class="line">    (i &lt; n_coins)</span><br><span class="line">&#125;) &#123;</span><br></pre></td></tr></table></figure>
<p>循环不变量通常情况下很难写，尤其是重要循环体</p>
<p>第二个处理循环的解决方案是展开循环。这种技术在某些特定情况下是有效的，就如我们所看到那样，<code>add</code>函数内的循环恰好循环4次。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Total words in `U256` (64 * 4 = 256).</span></span><br><span class="line"><span class="keyword">const</span> WORDS: <span class="type">u64</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="title function_ invoke__">while</span> (i &lt; WORDS) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a1</span> = <span class="title function_ invoke__">get</span>(&amp;a, i);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b1</span> = <span class="title function_ invoke__">get</span>(&amp;b, i);</span><br><span class="line"></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>展开这个函数再跑一次，Move Prover会打印出成功信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUCCESS proving 1 modules from package `u256` in 9.685s</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Result&quot;: &quot;Success&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了确保<strong>交换律</strong>(<code>a+(b+c) = (a+b)+c</code>)
成立，改变加数的分组不改变加法结果。为了验证该项，我们首先写一个模拟该属性的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun add_assoc_property(a: U256, b: U256, c: U256): bool &#123;</span><br><span class="line">    let result_1 = add(b, c); </span><br><span class="line">    let result_11 = add(a, result_1); </span><br><span class="line">    let result_2 = add(a, b); </span><br><span class="line">    let result_22 = add(c, result_2); </span><br><span class="line"></span><br><span class="line">    let cmp = compare(&amp;result_11, &amp;result_22); </span><br><span class="line">    if ( cmp == EQUAL ) true else false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再创建一个spec代码块来规范溢出话函数结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spec add_assoc_property &#123;</span><br><span class="line">    aborts_if (value_of_U256(a) + value_of_U256(b)) + value_of_U256(c) &gt;= P64 * P64 * P64 * P64;</span><br><span class="line">    ensures result == true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行Move Prover的新规范吗我们可以确认这里没有验证错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUCCESS proving 1 modules from package `u256` in 9.685s</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Result&quot;: &quot;Success&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果余姚进一步了解Move Prover语法，建议阅读Move仓库中的<a
href="https://github.com/move-language/move/blob/main/language/move-prover/doc/user/spec-lang.md">spec-lang.md</a>
完整文档。</p>
<h2 id="用例">用例</h2>
<p>形式化验证可以证明智能合约满足所有可能情况下的给定需求，甚至不需要运行该合约。困难的是制定规范。在这里，我们希望探索一些验证思想的实际例子。</p>
<h3 id="错误条件">错误条件</h3>
<p>以<code>std::fixed_point32</code>为例，显式定义函数何时可能中止通常是有用的。例如具有定点数的算术运算只有在溢出时才会出错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spec schema MultiplyAbortsIf &#123;</span><br><span class="line">    val: num;</span><br><span class="line">    multiplier: FixedPoint32;</span><br><span class="line">    aborts_if spec_multiply_u64(val, multiplier) &gt; MAX_U64 with EMULTIPLICATION;</span><br><span class="line">&#125;</span><br><span class="line">spec fun spec_multiply_u64(val: num, multiplier: FixedPoint32): num &#123;</span><br><span class="line">    (val * multiplier.value) &gt;&gt; 32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问控制策略">访问控制策略</h3>
<p>与错误条件类似，在规范中强制显式访问控制策略通常很有用。</p>
<p>例如，在<code>std::offer</code>
中，我们可以看到，当且仅当不存在offer时或者接收者不被允许时，函数应该abort。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spec redeem &#123;</span><br><span class="line">  /// Aborts if there is no offer under `offer_address` or if the account</span><br><span class="line">  /// cannot redeem the offer.</span><br><span class="line">  /// Ensures that the offered struct under `offer_address` is removed.</span><br><span class="line">  aborts_if !exists&lt;Offer&lt;Offered&gt;&gt;(offer_address);</span><br><span class="line">  aborts_if !is_allowed_recipient&lt;Offered&gt;(offer_address, signer::address_of(account));</span><br><span class="line">  ensures !exists&lt;Offer&lt;Offered&gt;&gt;(offer_address);</span><br><span class="line">  ensures result == old(global&lt;Offer&lt;Offered&gt;&gt;(offer_address).offered);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些访问控制规范使得以后不会意外删除关键访问控制策略。</p>
<h3 id="复杂的数学公式">复杂的数学公式</h3>
<p>无论是十进制实现还是更复杂的数据结构，验证"期望的输出"恒等于"输出"通常是有用的。</p>
<p>证明基本数据结构完全按照预期工作将使您对代码库的其余部分更有信心。</p>
<p>例如，在我们与<a href="https://laminar.markets/">Laminar
Markets</a>的合作中，我们提供了针对更简单的优先级队列数据结构验证其内部扩展树实现的建议。</p>
<h3 id="数据不变量">数据不变量</h3>
<p>形式化验证提供了验证某些“变量”或“资源”没有超出预期边界的最佳环境。让我们从下面考虑结构。我们可以使用<code>struct invariant</code>确保<code>index</code>永远不大于4。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    index: <span class="type">u64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spec Type &#123;</span><br><span class="line">    invariant index &lt; <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们最近对<a href="https://layerzero.network/">LayerZero</a>和<a
href="http://ariesmarkets.xyz/">Aries
Markets</a>的审计中验证更复杂的属性，细节留给读者练习。</p>
<h3 id="经济不变量">经济不变量</h3>
<p>设计恰当的经济不变量需要更高的创造力，但可以非常有效地保护您的协议。</p>
<p>举个例子，您不能通过增加和减少股权从池子里提走代币，在实践中，您可以将其作为工具帮助函数实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// #[test] // TODO: cannot specify the test-only functions</span><br><span class="line">fun no_free_money_theorem(coin1_in: u64, coin2_in: u64): (u64, u64) acquires Pool &#123;</span><br><span class="line">    let share = add_liquidity(coin1_in, coin2_in);</span><br><span class="line">    remove_liquidity(share)</span><br><span class="line">&#125;</span><br><span class="line">spec no_free_money_theorem &#123;</span><br><span class="line">    pragma verify=false;</span><br><span class="line">    ensures result_1 &lt;= coin1_in;</span><br><span class="line">    ensures result_2 &lt;= coin2_in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一些中心思想：</p>
<ol type="1">
<li>通过 AMM 进行 swap
操作永远不会在池的一边没减少的情况下令另一边增加。换句话说，no free
money。</li>
<li>在一系列的存贷取款指令之后，贷款协议应该始终是完全抵押的。</li>
<li>在下单后取消订单后，订单簿不应该赔钱。</li>
</ol>
<h2 id="结语">结语</h2>
<p>在这篇文章中，我们探讨了如何正确地利用Move验证器来验证代码库中的关键不变量。</p>
<p>在我们接下来的文章中，我们将探索如何通过学习问正确的问题，将Move验证器变成压制安全漏洞的利器，所以请继续关注!</p>
<p>我们热衷于形式化验证，并将Move安全的可能性推向极致。如果您有任何想法或者想深入了解审计，请随时联系我<a
href="https://twitter.com/notdeghost/"><span class="citation"
data-cites="notdeghost">@notdeghost</span></a>。</p>
<h2 id="原文链接">原文链接</h2>
<p>https://osec.io/blog/tutorials/2022-09-16-move-prover/</p>
]]></content>
      <categories>
        <category>Aptos</category>
      </categories>
      <tags>
        <tag>Move</tag>
        <tag>Aptos</tag>
      </tags>
  </entry>
  <entry>
    <title>无需合约，在Aptos上发布NFT</title>
    <url>/2022/07/31/aptos-first-nft/</url>
    <content><![CDATA[<p>从前有一个大网红Diana坐拥百万粉丝，她有一天突发奇想，想给每一个粉丝发放一个粉丝牌NFT，那么她应该怎么做呢？第一步，她需要部署一张NFT合约；第二步，铸造100万枚粉丝牌NFT；第三步，将粉丝牌NFT发送给粉丝。先不说天价gas费和Diana小姐会不会写合约，这一套下来等到粉丝全部收到粉丝牌保守估计得有四五天了，Diana很是头疼，怎么办呢。</p>
<p>直到直播间的穷哥们小A发现了Aptos，这条链有着很强的性能和很低的使用门槛，链上内置了原生的NFT合约，这就省去了第一步的麻烦，又由于其超高性能，第二第三步居然可以在几个小时内解决！小A立刻来了精神，要是把这件事拿下，Diana小姐岂不是会尊敬我崇拜我爱上我对我欲罢不能？</p>
<p>这就开干：</p>
<p>由于下面会复用aptos官方example中的部分代码，可以先阅读该篇文章：http://alvan.coffee/2022/07/30/aptos-tutorial</p>
<p>Aptos官网有铸造nft的example，python版本和typescript版本，rust版本还没有添加，那我们就用rust写了补全一下吧。</p>
<p>第一步，构造一个Client用于和Aptos节点和水龙头交互：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NftClient</span> &#123;</span><br><span class="line">    url: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> rest_client: RestClient,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">NftClient</span> &#123;</span><br><span class="line">    <span class="comment">/// Represents an account as well as the private, public key-pair for the Aptos blockchain.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(url: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            url: url.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            rest_client: RestClient::<span class="title function_ invoke__">new</span>(url.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">submit_transaction_helper</span>(&amp;<span class="keyword">self</span>, account: &amp;<span class="keyword">mut</span> Account, payload: Value) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rest_client</span><br><span class="line">            .<span class="title function_ invoke__">execution_transaction_with_payload</span>(account, payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里复用了上一篇文章的RestClient，官方样例很贴心地把构造，提交，验证交易相关的操作都写好了，我们只需要添加业务层面的逻辑，也就是写写REST请求体就可以了。</p>
<p>第二步，铸造NFT</p>
<p>Nft在所谓0x1合约也就是<code>aptos-framework</code>中，提供了数种创建collection和token的方法。</p>
<p>在aptos里我们可以创建有限或无限的Nft系列(collection)，根据业务需要，有些系列的NFT要强调稀缺性，有些系列则需要持续铸造，我们可以用选择不同的方法。这里我们使用<code>create_unlimited_collection_script</code>和<code>create_unlimited_token_script</code>，在<code>aptos-move/framework/aptos-framework/sources/token.move</code>中我们可以看到更详细的说明。</p>
<p>在创建好collection后我们就可以去铸造该collection下的token了，可以批量生产，supply参数就是产量。</p>
<p>我们只需要很简单的根据需求构造出对应name，description和url的collection/token，然后把它们塞进payload里，用自己的账户把交易发出去就ok了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create_collection</span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        account: &amp;<span class="keyword">mut</span> Account,</span><br><span class="line">        name: &amp;<span class="type">str</span>,</span><br><span class="line">        uri: &amp;<span class="type">str</span>,</span><br><span class="line">        description: &amp;<span class="type">str</span>,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">payload</span> = serde_json::json!(&#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;script_function_payload&quot;</span>,</span><br><span class="line">            <span class="string">&quot;function&quot;</span>: <span class="string">&quot;0x1::token::create_unlimited_collection_script&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type_arguments&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;arguments&quot;</span>: [</span><br><span class="line">                hex::<span class="title function_ invoke__">encode</span>(name.<span class="title function_ invoke__">as_bytes</span>()),</span><br><span class="line">                hex::<span class="title function_ invoke__">encode</span>(description.<span class="title function_ invoke__">as_bytes</span>()),</span><br><span class="line">                hex::<span class="title function_ invoke__">encode</span>(uri.<span class="title function_ invoke__">as_bytes</span>()),</span><br><span class="line">            ]</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">submit_transaction_helper</span>(account, payload)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create_token</span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        account: &amp;<span class="keyword">mut</span> Account,</span><br><span class="line">        collection_name: &amp;<span class="type">str</span>,</span><br><span class="line">        name: &amp;<span class="type">str</span>,</span><br><span class="line">        description: &amp;<span class="type">str</span>,</span><br><span class="line">        supply: <span class="type">i32</span>,</span><br><span class="line">        uri: &amp;<span class="type">str</span>,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">payload</span> = serde_json::json!(&#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;script_function_payload&quot;</span>,</span><br><span class="line">            <span class="string">&quot;function&quot;</span>: <span class="string">&quot;0x1::token::create_unlimited_token_script&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type_arguments&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;arguments&quot;</span>: [</span><br><span class="line">                hex::<span class="title function_ invoke__">encode</span>(collection_name.<span class="title function_ invoke__">as_bytes</span>()),</span><br><span class="line">                hex::<span class="title function_ invoke__">encode</span>(name.<span class="title function_ invoke__">as_bytes</span>()),</span><br><span class="line">                hex::<span class="title function_ invoke__">encode</span>(description.<span class="title function_ invoke__">as_bytes</span>()),</span><br><span class="line">                <span class="literal">true</span>,</span><br><span class="line">                supply.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_str</span>(),</span><br><span class="line">                hex::<span class="title function_ invoke__">encode</span>(uri.<span class="title function_ invoke__">as_bytes</span>()),</span><br><span class="line">                <span class="string">&quot;0&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">submit_transaction_helper</span>(account, payload)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第三步，交易NFT</p>
<p>由于aptos独特的所有权机制，转移nft其实并不是合约记一下账这么简单，需要分为两步走，发送方发送<code>(offer_token</code>)之后，接收方还要声明接收一下(<code>claim_token</code>)，这两个方法都在<code>0x1::token_transfers</code>合约里，文件在<code>aptos-move/framework/aptos-framework/sources/token_transfers.move</code></p>
<p>值得注意的是，想要转移nft，需要知道创建者地址，collection名和name名。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">offer_token</span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        account: &amp;<span class="keyword">mut</span> Account,</span><br><span class="line">        receiver: &amp;<span class="type">str</span>,</span><br><span class="line">        creator: &amp;<span class="type">str</span>,</span><br><span class="line">        collection_name: &amp;<span class="type">str</span>,</span><br><span class="line">        token_name: &amp;<span class="type">str</span>,</span><br><span class="line">        amount: <span class="type">i32</span>,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">payload</span> = serde_json::json!(&#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;script_function_payload&quot;</span>,</span><br><span class="line">            <span class="string">&quot;function&quot;</span>: <span class="string">&quot;0x1::token_transfers::offer_script&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type_arguments&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;arguments&quot;</span>: [</span><br><span class="line">                receiver,</span><br><span class="line">                creator,</span><br><span class="line">                hex::<span class="title function_ invoke__">encode</span>(collection_name.<span class="title function_ invoke__">as_bytes</span>()),</span><br><span class="line">                hex::<span class="title function_ invoke__">encode</span>(token_name.<span class="title function_ invoke__">as_bytes</span>()),</span><br><span class="line">                amount.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_str</span>()</span><br><span class="line">            ]</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">submit_transaction_helper</span>(account, payload)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">claim_token</span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        account: &amp;<span class="keyword">mut</span> Account,</span><br><span class="line">        sender: &amp;<span class="type">str</span>,</span><br><span class="line">        creator: &amp;<span class="type">str</span>,</span><br><span class="line">        collection_name: &amp;<span class="type">str</span>,</span><br><span class="line">        token_name: &amp;<span class="type">str</span>,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">payload</span> = serde_json::json!(&#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;script_function_payload&quot;</span>,</span><br><span class="line">            <span class="string">&quot;function&quot;</span>: <span class="string">&quot;0x1::token_transfers::claim_script&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type_arguments&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;arguments&quot;</span>: [</span><br><span class="line">                sender,</span><br><span class="line">                creator,</span><br><span class="line">                hex::<span class="title function_ invoke__">encode</span>(collection_name.<span class="title function_ invoke__">as_bytes</span>()),</span><br><span class="line">                hex::<span class="title function_ invoke__">encode</span>(token_name.<span class="title function_ invoke__">as_bytes</span>())</span><br><span class="line">            ]</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">submit_transaction_helper</span>(account, payload)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第四步，查询NFT</p>
<p>现在交易写完了，我们查询一下NFT的持有量和数据，这就复用到了上一篇文章里的<code>account_resource</code>，无论什么资源，原生代币还是项目代币，抑或是NFT，他们都是我们账户的资源(resource)，所以使用这个就可以查到我们持有的nft了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_collection</span>(&amp;<span class="keyword">self</span>, creator: &amp;<span class="type">str</span>, collection_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Value &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">collection</span> = &amp;<span class="keyword">self</span></span><br><span class="line">        .rest_client</span><br><span class="line">        .<span class="title function_ invoke__">account_resource</span>(creator, <span class="string">&quot;0x1::token::Collections&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;collections&quot;</span>][<span class="string">&quot;handle&quot;</span>];</span><br><span class="line">    <span class="keyword">match</span> collection &#123;</span><br><span class="line">        Value::<span class="title function_ invoke__">String</span>(s) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">get_table_item</span>(</span><br><span class="line">            s.<span class="title function_ invoke__">as_str</span>(),</span><br><span class="line">            <span class="string">&quot;0x1::string::String&quot;</span>,</span><br><span class="line">            <span class="string">&quot;0x1::token::Collection&quot;</span>,</span><br><span class="line">            Value::<span class="title function_ invoke__">String</span>(collection_name.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        ),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;get_collection:error&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_token_balance</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    owner: &amp;<span class="type">str</span>,</span><br><span class="line">    creator: &amp;<span class="type">str</span>,</span><br><span class="line">    collection_name: &amp;<span class="type">str</span>,</span><br><span class="line">    token_name: &amp;<span class="type">str</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> Value &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">token_store</span> = &amp;<span class="keyword">self</span></span><br><span class="line">        .rest_client</span><br><span class="line">        .<span class="title function_ invoke__">account_resource</span>(owner, <span class="string">&quot;0x1::token::TokenStore&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;tokens&quot;</span>][<span class="string">&quot;handle&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">token_id</span> = serde_json::json!(&#123;</span><br><span class="line">        <span class="string">&quot;creator&quot;</span>: creator,</span><br><span class="line">        <span class="string">&quot;collection&quot;</span>: collection_name,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: token_name,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">match</span> token_store &#123;</span><br><span class="line">        Value::<span class="title function_ invoke__">String</span>(s) =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">get_table_item</span>(s, <span class="string">&quot;0x1::token::TokenId&quot;</span>, <span class="string">&quot;0x1::token::Token&quot;</span>, token_id)</span><br><span class="line">                [<span class="string">&quot;value&quot;</span>]</span><br><span class="line">                .<span class="title function_ invoke__">clone</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;get_token_balance:error&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_token_data</span>(&amp;<span class="keyword">self</span>, creator: &amp;<span class="type">str</span>, collection_name: &amp;<span class="type">str</span>, token_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Value &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">token_data</span> = &amp;<span class="keyword">self</span></span><br><span class="line">        .rest_client</span><br><span class="line">        .<span class="title function_ invoke__">account_resource</span>(creator, <span class="string">&quot;0x1::token::Collections&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;token_data&quot;</span>][<span class="string">&quot;handle&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">token_id</span> = serde_json::json!(&#123;</span><br><span class="line">        <span class="string">&quot;creator&quot;</span>: creator,</span><br><span class="line">        <span class="string">&quot;collection&quot;</span>: collection_name,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: token_name,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">match</span> token_data &#123;</span><br><span class="line">        Value::<span class="title function_ invoke__">String</span>(s) =&gt; <span class="keyword">self</span></span><br><span class="line">            .<span class="title function_ invoke__">get_table_item</span>(s, <span class="string">&quot;0x1::token::TokenId&quot;</span>, <span class="string">&quot;0x1::token::TokenData&quot;</span>, token_id)</span><br><span class="line">            .<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;get_token_data:error&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完之后，小A把代码放在这里：https://github.com/passer-byzhang/aptos-core/tree/main/developer-docs-site/static/examples/rust/first_nft</p>
<p>随着测试代码绿油油的passed，小A开心地私信了Diana小姐，但是不知道为什么弹出了：由于对方隐私设置，无法发送私信。呵呵，一定是平台针对我，等进入了Web3时代，就不会有这样的事了吧，小A这样想着，合上电脑去睡觉了。</p>
]]></content>
      <categories>
        <category>Aptos</category>
      </categories>
      <tags>
        <tag>Aptos</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>defi-compound经济模型</title>
    <url>/2022/06/09/test-blog/</url>
    <content><![CDATA[<p><u>注：本篇文章适合初步了解区块链以及去中心化知识的Defi初学者/合约开发者，仅供学习参考，作者不推荐中国大陆居民购买任何加密货币与其理财产品</u></p>
<h2 id="前言">前言</h2>
<p>作者在fork一份compound的项目之后，觉得其中有不少值得一说的思想，比如激励comp的分配模式，利率模型等等。这篇文章会主要从业务逻辑和合约代码来讲解其经济模型，其治理模式，预言机与其他组件不做讲解，争取做到Defi初学者看完可以理解模型，开发者看完可以直接复现(不是，compound的代码本身也出现过一些漏洞，copy需谨慎)。</p>
<h2 id="项目简介">项目简介</h2>
<h3 id="背景介绍">背景介绍</h3>
<p>compound是一个借贷合约，想想通常情况下在中心化的机构例如银行里进行质押
- 借贷的程序是：</p>
<p>小张 存入 100元 到 某银行的资金池</p>
<p>小李 抵押 价值150元的资产 从 某银行的资金池 借出 100元</p>
<p>一个月后</p>
<p>小李 还账 100元本金+1元(借款利息) 给 某银行</p>
<p>小张 取钱时 某银行按照利率 返还 100元本金和0.02元(存款利息)</p>
<p>如果小李资不抵债，银行清算小李的抵押资产，小张的借款利息不变</p>
<p>看到什么问题了吗，借款利息和存款利息受银行调控，放贷的利息远比存款利息要高。随之出现的就是P2P借贷，P2P借贷的模式繁杂，大致是以下程序：</p>
<p>小李 发布 100元借款的需求(自定义利率) 到 P2P平台</p>
<p>P2P平台 对 小李 资质审查 判断风险与是否上架</p>
<p>小张 选择 小李的借款单子 出借 100元 给 小李</p>
<p>小李 按照单子约定 还款 100元(本金) + 10元(借款利息)</p>
<p>P2P平台 中间收取 一定比例的手续费与管理费1元</p>
<p>小张 拿走其余9元利息和100元本金</p>
<p>如果小李逾期未还，看P2P平台的心情平账</p>
<p>P2P的问题依然明显，用户为了取得更高的收益承担了更多的风险，P2P平台的诚信和公正也无法保证。去中心化想要解决的就是大平台的高抽成和垄断问题和小平台的信任问题，把分账，风险评估，清算全部交给不可更改的程序，这就是co
mpound与其他Defi项目所做的事情。</p>
<h3 id="基本结构">基本结构</h3>
<p>compound提供了借款，还款，存款，取款，清算等功能，它的质押资产和借出资产都是虚拟货币。</p>
<p>其中每一种虚拟货币的资金池称为一个market，所有质押A货币的用户共同构成一个A
market。同理，所有借出A货币的用户都从这个market借款，还款。他们共同使用A
market的借款利率和抵押利率。这让风险和收益平分到了每个使用者的身上，一个人不用因为借出某个坏人而坏账，因为他们共用这个market。</p>
<p>-------这就是CToken合约做的事情</p>
<p>我们这样做的前提是可以判断质押物和借出的价值和数量。例如小李想要借走1个eth，那么他的质押物总值应该大于等于value(1
eth) / factor
，此处的factor为质押率，我们需要一个中间系统来整合每个market的情况和用户在每个market里的存款和借款。我们把CToken和用户信息登记到这个comptroller合约内，这样可以整合每个用户的资/债情况，
再由comptroller合约来对接预言机，获得虚拟货币的单价。这样通过使用每个虚拟货币的单价和用户在每个market里的质押/借出值，算出用户目前的财务状态，帮助CToken判断是否同意用户的借款/取款操作</p>
<p>-------这就是comptroller合约做的事情</p>
<p>我们在上边两个合约里解决了信任问题，使用固定利率明显不符合大开大合的加密货币市场，我们要添加一个市场调节的利率模型和利息计算模式，这也是compound的核心经济模型。我将在下一节
业务逻辑 详细介绍。</p>
<p>-------这就是InterestModel合约做的事情</p>
<p>作为一个Defi项目自然要自己发行一个新币啦，它会给每个market的用户的几乎每次财产操作发放激励，它也作为compound项目的治理代币，可以参与修改预言机或者市场的利率模型等，其激励机制我也会在下一节
业务逻辑 详细介绍。</p>
<p>-------这就是Comp合约做的事情</p>
<h2 id="业务逻辑">业务逻辑</h2>
<h3 id="业务流程">业务流程</h3>
<p>首先，我们需要一个标记用户质押资产和借款的方法，而质押资产的价值和借款的数目与价值会随着利息改变，这时引入一个概念
cToken。cToken是CToken合约发行的货币，在用户存入底层资产时，发给用户作为资产凭证。</p>
<p>比如小张存入100A币，则A market对应的CToken合约会给用户发放
100/exchangeRate 个
cA币。exchange的初始值由管理员设定，之后的公式为：</p>
<p><span class="math inline">\(exchangeRate =
\frac{totalCash+totalBorrow-totalReserves}{totalSupply}\)</span></p>
<p>其中totalSupply为发行的所有cA
币总量，totalCash为存入该market且没被借走的A币总值，totalBorrow为从market里借走的A币总量，totalReserves为CToken自己收取的中介费。</p>
<p>小李想借出一些A币，那么他向market发起借款申请：借100个A币。comptroller查询了他在所有market里的资/债情况，也就是借款记录和cB,cC,cD.......等等的持有量，判断该次操作是否会造成资不抵债，如果不会，则给小李的账户发送100A币，并在A
market里更新小李的A 借款额。</p>
<p>在小李借走100A的时间里，每一个用户的每次资产操作都会 “刷新利息/利率”
，会更新一些系数，控制exchangeRate和每个人的借款额。</p>
<p>如果小李借走100A的期间里，A币价格暴跌，套利机器人将把小李的其他资产贱卖进行平账。</p>
<p>因为一个用户的资产凭证只有cA，相同的cA在不同的时间可以兑换不同数量的A币，这就是该项目产生收益和亏损的直接原因。</p>
<h3 id="利率模型">利率模型</h3>
<h4 id="利息的产生">利息的产生</h4>
<p>每一个资产操作前都要进行的刷新利率/利息，合约内的数据变动是这样的：</p>
<p>$interestAccmulated = totalBorrow borrowRate deltaBlock $</p>
<p><span class="math inline">\(totalBorrowNew = totalBorrow +
interestAccmulated\)</span></p>
<p>$totalReservesNew = totalReserves + reservesFactor interestAccmulated
$</p>
<p><span class="math inline">\(borrowIndexNew = borrowIndex +
borrowIndex \times borrowRate \times deltaBlock\)</span></p>
<p>borrowRate是借款利率(后面细说来源)，reservesFactor是market设置的中介费系数，通常比较低。</p>
<p>borrowIndex是用来调节借款者利息的标记位，初始值为1。</p>
<p>我们可以看到如果不动任何资产，</p>
<p>对于cA持有者，也就是A的存款者来说，每一次刷新之后totalBorrow -
totalReserves 就会变大，exchangeRate就会变大，那么每一个A兑换的cA
变少了，持有cA 的人在取款时可以收到比存取时更加多的A币。</p>
<p>对于A的借款者来说，他的利息通过borrowIndex控制，每次还款和借款都会更新，具体如下：</p>
<p><span class="math inline">\(borrowAmount = \frac {principal \times
borrowIndexA} {borrowIndexB}\)</span></p>
<p>其中，principal为该账户借款的目前更新前记账数值数值，borowIndexA为整个A
market现在的borrowIndex，borrowIndexB是上一次借款时的borrowIndexA，他的借款额也就更新到账户上了。需要还掉的借款变多了。</p>
<h4 id="利率的计算">利率的计算</h4>
<p>compound的利率模型其实就是一个核心观念：市场使用率(utilizationRate)</p>
<p><span class="math inline">\(utilizationRate =
\frac{borrows}{cash+borrows-reserves}\)</span></p>
<p>使用率越高，我们的意愿是引入更多的存款者，限制更多的借款者，也就是利息越高，这时我们看借款利率：</p>
<p><span class="math inline">\(borrowRatePerBlock = baseRatePerBlock +
utilizationRate \times multiplierPerBlock\)</span></p>
<p>baseRatePerBlock和multiplierPerBlock，都由模型自己指定，作为配合市场利用率的参数。</p>
<p>实际上compound并不需要一个计算存款利率的函数，只是通过记录exchangeRate来获利，但是我们依然可以算出来</p>
<p><span class="math inline">\(supplyRatePerBlock = borrowRatePerBlock
\times utilizationRate \times (1 - reserversFactor)\)</span></p>
<h3 id="激励模型">激励模型</h3>
<p>compound的激励代币称为Comp，激励发生在每次资产交易中，分为两种，一种发放给存款人，一种发放给借款人，量的大小由该用户的持有量/借款和总量的比例决定，每一个market在一个区块里发放的激励comp是固定的，存款激励和借款激励的比例也是固定的，分别称为supplySpeed和borrowSpeed，先从这两个式子讲起</p>
<p><span class="math inline">\(SupplyIndexNew = SupplyIndex +
\frac{deltaBlocks \times SupplySpeed} {totalSupply}\)</span></p>
<p><span class="math inline">\(BorrowIndexNew = BorrowIndex +
\frac{deltablock \times
BorrowSpeed}{\frac{totalBorrows}{borrowIndex}}\)</span></p>
<p><small>在此模块里，BorrowIndex和BorrowIndex指在激励系统中标记借款激励的参数，而borrowIndex是指前文提到的利息参数。</small></p>
<p>这是每个market共用的激励记录公式，每一次激励都会刷新的两个参数，分别是SupplyIndex和BorrowIndex，每一组绑定一个market，表示该market的整体激励状态。看起来有点抽象是吧，我们再看下边两个给用户分配激励的公式：</p>
<p><span class="math inline">\(SupplierAccruedNew = SupplierAccrued +
cToken.balanceOf(user) \times (SupplyIndex - SupplierIndex)\)</span></p>
<p><span class="math inline">\(BorrowerAccruedNew = BorrowerAccruced +
\frac{cToken.borrowBalance(user) } {borrowIndex} \times (BorrowIndex -
BorrowerIndex)\)</span></p>
<p>SupplierIndex和BorrowerIndex是上次user做出对应交易时，该market的SupplyIndex和BorrowIndex。</p>
<p>SupplyIndex -
SupplierIndex则代表着这次操作中，每持有一个cToken，获得的激励量。</p>
<p>举个例子在某区块totalSuppy =
10000，小张操作资产得到激励，此时距离上次刷新的x区块又产生了100个区块，speed
= v，小张持有量为100，现在开始刷新SupplyIndex，</p>
<p><span class="math inline">\(SupplyIndex1 = SupplyIndex +
\frac{100v}{10000}\)</span></p>
<p>又过了100个区块，小张操作资产再次获得激励，其余均不变，这时的</p>
<p><span class="math inline">\(SupplyIndex2 = SupplyIndex1 +
\frac{100v}{10000}\)</span></p>
<p><span class="math inline">\(SupplierIndex = SupplyIndex1\)</span></p>
<p><span class="math inline">\(SupplierAccruedNew = SupplierAccrued +
100 \times \frac{100v}{10000}\)</span></p>
<p>这次获得的新激励是<span
class="math inline">\(\frac{balance}{totalSupply} \times speed \times
deltaBlock\)</span>，确实和我们预想的一样。</p>
<p>就是这样，完成了激励的分配，不多不少，刚好分完。</p>
<h2 id="结语">结语</h2>
<p>compound的经济模型大概就是这样了，新人初稿，大家海涵，如有错漏请多指教小弟。下一篇可能是compound源码解析或者是AMM模型，最后祝大家财运昌隆！</p>
]]></content>
      <categories>
        <category>DeFi</category>
      </categories>
  </entry>
  <entry>
    <title>在抽奖系统中生成lucky code</title>
    <url>/2022/09/13/screct-generate/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>最近项目中需要做一个抽奖的功能，在这个功能里，随机数种子必须是公开的，方便用户查询的，计算过程方便公示的。本来的想法是使用声明抽奖后的第x个区块的区块哈希，这样用户也很容易验证，代码写起来也很简单。但是不幸的是aptos链并没有通过高度获取哈希这种东西，这很令我头秃。组长提议从链下引入，但是公平公正和中心化的稳定性又成了问题，最后我选用了这种方法：</p>
<h2 id="原理">原理</h2>
<p>该方法分为三步：</p>
<p>1.创建随机数</p>
<p>在创建某个抽奖项目时，项目方可以自主选用一些密钥 <span
class="math inline">\(x_1,x_2,x_3...x_n\)</span></p>
<p>同时定义并公开一个陷门函数<span class="math inline">\(f\)</span></p>
<p>在执行交易时，把<span
class="math inline">\(f(x_1,x_2,x_3...x_n)\)</span>
传入合约存储，并触发事件以供用户查验</p>
<p>2.构造随机数(可省略)</p>
<p>每一个用户参与抽奖时，可以添加一个随机数，最后生成一个随机数组<span
class="math inline">\(a_0,a_1...a_m\)</span></p>
<p>3.揭示中奖密码</p>
<p>管理员传入密钥 <span
class="math inline">\(y_1,y_2,y_3...y_n\)</span>，合约验证<span
class="math inline">\(f(x_1,x_2,x_3...x_n)==f(y_1,y_2,y_3...y_n)\)</span></p>
<p>若不成功，则说明管理员徇私，不予通过。</p>
<p>若成功，则中奖号码为<span class="math inline">\((\sum_{i=0}^ma_i +
\sum_{i=1}^n y_i)\%m\)</span></p>
<h2 id="后记">后记</h2>
<p>本来想做一个mpc的过程，但是aptos的生态实在太缺了，不太好做，就决定用这个单陷门函数控制的方法了。</p>
]]></content>
      <categories>
        <category>Aptos</category>
      </categories>
      <tags>
        <tag>Move</tag>
        <tag>Aptos</tag>
      </tags>
  </entry>
  <entry>
    <title>Aptos中实现merkle树验证</title>
    <url>/2022/10/11/aptos-merkle/</url>
    <content><![CDATA[<h2 id="原理讲解">原理讲解：</h2>
<p>由于区块链在存储/检索大量数据上成本过高，在一些情况下会采用用链下存储，链上验证的方法。例如如果要管理一个数万地址的白名单，使用merkle树不失为一种好方案。</p>
<p><img
src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Hash_Tree.svg/310px-Hash_Tree.svg.png"
alt="img" />
merkle树本质是一个满二叉树，它的叶子结点保存着原数据的hash值，非叶子结点存储的数据是左儿子节点和右儿子节点数据的拼接后求hash(排序后)。
如上图所示，<span class="math inline">\(Hash0 = hash(Hash0\_0 +
Hash0\_1)，Top Hash = hash( Hash0 + Hash1 )\)</span>。</p>
<p>详细介绍可见：https://mirror.xyz/qiwihui.eth/HRifb9gziR1UvVmRcMjDfDvQ9mq7o7FA6BNuCJMFT00</p>
<h2 id="用法">用法：</h2>
<p>如果我们需要存储1W个地址作为白名单用户，那么全部存储和操作都在区块链上的成本明显有点太高了，我们可以利用merkle树的特性解决。步骤如下：
1.在链下使用1W个地址生成merkle树并存储。 2.并将根结点<span
class="math inline">\(TopHash\)</span>存入合约。 3.如果需要查询 L4
地址是否在白名单内，需要提供A地址本身和验证路径上的节点信息。例如需要验证L4在该树中，则需要提供
<span class="math inline">\(Hash 1\_0\)</span> 与 <span
class="math inline">\(Hash 0\)</span>. 4.在合约内验证 <span
class="math inline">\(hash( Hash 0 + hash(Hash 1\_ 0 + hash( L4 ))) ==
TopHash\)</span> ，即可判断 L4 是否在merkle树内了。</p>
<h2 id="实现">实现：</h2>
<h3 id="链下部分">链下部分：</h3>
<p>链下部分负责生成 merkle 树，存储 merkle
树，获取<code>proof</code>验证路径数据。</p>
<p>我们可以直接使用现成的 <code>keccak256</code> 与
<code>merkletreejs</code>
库来管理merkle树，无论是存储，构建，生成验证路径，获取树根都有直接可用的方法供我们使用：
需要注意的只是要将数据结构匹配成aptos可以接受的形式</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keccak256 <span class="keyword">from</span> <span class="string">&quot;keccak256&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MerkleTree</span> <span class="keyword">from</span> <span class="string">&quot;merkletreejs&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">NODE_URL</span> = <span class="string">&quot;https://fullnode.devnet.aptoslabs.com/v1&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">FAUCET_URL</span> = <span class="string">&quot;https://faucet.devnet.aptoslabs.com&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> privateKey = <span class="string">&#x27;0x.............&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> whitelistAddresses = [</span><br><span class="line">    <span class="string">&quot;0x36346bbcda6f9f74cf36cff31e00ac83c9d8a512a6564c9f93b00d249e3b2b45&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0x09d4ee382de0fa20f889ac6158273f29c81a1fec7385e8e26801db2e9e0c2f32&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0x09d4ee382de0fa20f889ac6158273f29c81a1fec7385e8e26801db2e9e0c2f32&quot;</span>,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> leafNodes = whitelistAddresses.<span class="title function_">map</span>(<span class="function">(<span class="params">address</span>) =&gt;</span> <span class="title function_">keccak256</span>(address));</span><br><span class="line">  <span class="keyword">let</span> tree = <span class="keyword">new</span> <span class="title class_">MerkleTree</span>(leafNodes, keccak256, &#123; <span class="attr">sortPairs</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> root = tree.<span class="title function_">getRoot</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">convert_to_bytes</span>(<span class="params">v:<span class="built_in">string</span>[]</span>):<span class="title class_">Uint8Array</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = v.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">32</span>*len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        result.<span class="title function_">set</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(v[i].<span class="title function_">slice</span>(<span class="number">2</span>),<span class="string">&#x27;hex&#x27;</span>),i*<span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">get_proof</span>(<span class="params">account:<span class="built_in">string</span></span>):<span class="title class_">Uint8Array</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proof = tree.<span class="title function_">getHexProof</span>((<span class="title function_">keccak256</span>(account)));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">convert_to_bytes</span>(proof)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="链上部分">链上部分：</h3>
<p>负责存储树根和验证计算，代码是参考 <code>openzeppelin</code> 写的
：</p>
<p>Aptos 上使用
vector&lt;u8&gt;存储树根以及接收代验证数据和验证路径的原数据，</p>
<p>下图函数是使用
待验证的叶子结点<code>leaf</code>和验证路径数据<code>proof</code>计算<code>tophash</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_ invoke__">processProof</span>(proof:vector&lt;<span class="type">u8</span>&gt;,leaf:vector&lt;<span class="type">u8</span>&gt;):vector&lt;<span class="type">u8</span>&gt;&#123;</span><br><span class="line">    <span class="built_in">assert!</span>(vector::<span class="title function_ invoke__">length</span>(&amp;proof)%<span class="number">32</span>==<span class="number">0</span>,error::<span class="title function_ invoke__">invalid_argument</span>(LENGTH_INVALID));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">deep</span> = vector::<span class="title function_ invoke__">length</span>(&amp;proof)/<span class="number">32</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(vector::<span class="title function_ invoke__">length</span>(&amp;leaf)==<span class="number">32</span>,error::<span class="title function_ invoke__">invalid_argument</span>(LENGTH_INVALID));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">node</span> = leaf;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_ invoke__">while</span>(index &lt; deep)&#123;</span><br><span class="line">        node = <span class="title function_ invoke__">hashPair</span>(node,<span class="title function_ invoke__">extract_vector</span>(proof,index*<span class="number">32</span>,index*<span class="number">32</span>+<span class="number">32</span>));</span><br><span class="line">        index = index +<span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于aptos不能像 evm 一样可以直接传 <code>byte32</code> 和
<code>byte32[]</code>, 我们需要对验证路径信息即 <code>proof</code>
做简单的序列化。<code>leaf</code>和拆解出来的每一个vector&lt;u8&gt;挨个拼接并取hash
，以下为拼接函数: <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_ invoke__">hashPair</span>(a:vector&lt;<span class="type">u8</span>&gt;,b:vector&lt;<span class="type">u8</span>&gt;):vector&lt;<span class="type">u8</span>&gt;&#123;</span><br><span class="line">        <span class="title function_ invoke__">if</span>(<span class="title function_ invoke__">compare_vector</span>(&amp;a,&amp;b)==SMALLER)&#123;</span><br><span class="line">            vector::<span class="title function_ invoke__">append</span>(&amp;<span class="keyword">mut</span> a,b);</span><br><span class="line">            aptos_hash::<span class="title function_ invoke__">keccak256</span>(a)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vector::<span class="title function_ invoke__">append</span>(&amp;<span class="keyword">mut</span> b,a);</span><br><span class="line">            aptos_hash::<span class="title function_ invoke__">keccak256</span>(b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里读者可以看到有一个拼接顺序的判断，因为我们并不知道当前位置的节点是左节点还是右节点，更不知道它的父节点、爷爷节点、太爷爷节点是左节点还是右节点，所以我们无法判断拼接的顺序。
这样就需要我们在链下和链上规定同一种排序方法，使得任意给两个兄弟节点，我们都可以知道他们的左右。
在这里我们使用比大小的方式，实际上如何排序都可以，只要链上链下的规则统一就不会出问题。</p>
<p>最后 判断
<code>processProof</code>计算得出的数据与合约中存储的树根是否相等，确定该
<code>leaf</code> 是否存在于该树中。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">public entry fun <span class="title function_ invoke__">verify</span>(proof:vector&lt;<span class="type">u8</span>&gt;,leaf:vector&lt;<span class="type">u8</span>&gt;)acquires Root &#123;</span><br><span class="line">       <span class="built_in">assert!</span>(exists&lt;Root&gt;(Admin),error::<span class="title function_ invoke__">not_found</span>(ROOT_UNEXISTED));</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">root</span> = borrow_global&lt;Root&gt;(Admin);</span><br><span class="line">       <span class="built_in">assert!</span>(com</span><br></pre></td></tr></table></figure>
<p>再贴一下设置树根的方法： <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Root</span> has key &#123;</span><br><span class="line">   hash : vector&lt;<span class="type">u8</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public entry fun <span class="title function_ invoke__">set_root</span>(signer:&amp;signer,new_root:vector&lt;<span class="type">u8</span>&gt;)acquires Root&#123;</span><br><span class="line">        <span class="built_in">assert!</span>(<span class="title function_ invoke__">address_of</span>(signer)==Admin,error::<span class="title function_ invoke__">permission_denied</span>(NO_AUTHORIZATION));</span><br><span class="line">        <span class="title function_ invoke__">if</span>(!exists&lt;Root&gt;(Admin))&#123;</span><br><span class="line">            <span class="title function_ invoke__">move_to</span>(</span><br><span class="line">                signer,</span><br><span class="line">                Root&#123;</span><br><span class="line">                    hash:new_root</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">root</span> = borrow_global_mut&lt;Root&gt;(Admin);</span><br><span class="line">            root.hash = new_root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="交互部分">交互部分：</h3>
<p>只需要完成执行 <code>set_root</code> 和 <code>verify</code>
两个交易的方法，使用aptos官方sdk，做好序列化就好：</p>
<p>设置树根：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">set_root</span>(<span class="params">hash:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set merkle root: <span class="subst">$&#123;hash&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> entryFunctionPayload = <span class="keyword">new</span> <span class="title class_">TransactionPayloadEntryFunction</span>(</span><br><span class="line">        <span class="title class_">EntryFunction</span>.<span class="title function_">natural</span>(          </span><br><span class="line">          <span class="string">&quot;0xe463a68bb1dd0d9b9864ed030a8cd357f2a38b6b3fea92c0af07694db203a6e0::merkle&quot;</span>,         </span><br><span class="line">          <span class="string">&quot;set_root&quot;</span>,</span><br><span class="line">          [],</span><br><span class="line">          [<span class="variable constant_">BCS</span>.<span class="title function_">bcsSerializeBytes</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(hash.<span class="title function_">slice</span>(<span class="number">2</span>),<span class="string">&#x27;hex&#x27;</span>)),],</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> [&#123; <span class="attr">sequence_number</span>: sequenceNumber &#125;, chainId] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">        client.<span class="title function_">getAccount</span>(admin.<span class="title function_">address</span>()),</span><br><span class="line">        client.<span class="title function_">getChainId</span>(),</span><br><span class="line">      ]);</span><br><span class="line">      <span class="keyword">const</span> rawTxn = <span class="keyword">new</span> <span class="title class_">RawTransaction</span>(</span><br><span class="line">        <span class="title class_">AccountAddress</span>.<span class="title function_">fromHex</span>(admin.<span class="title function_">address</span>()),</span><br><span class="line">        <span class="title class_">BigInt</span>(sequenceNumber),</span><br><span class="line">        entryFunctionPayload,</span><br><span class="line">        <span class="title class_">BigInt</span>(<span class="number">2000</span>),</span><br><span class="line">        <span class="title class_">BigInt</span>(<span class="number">100</span>),</span><br><span class="line">        <span class="title class_">BigInt</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() / <span class="number">1000</span>) + <span class="number">10</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ChainId</span>(chainId),</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> bcsTxn = <span class="title class_">AptosClient</span>.<span class="title function_">generateBCSTransaction</span>(admin, rawTxn);</span><br><span class="line">      <span class="keyword">const</span> transactionRes = <span class="keyword">await</span> client.<span class="title function_">submitSignedBCSTransaction</span>(bcsTxn);</span><br><span class="line">      <span class="keyword">await</span> client.<span class="title function_">waitForTransaction</span>(transactionRes.<span class="property">hash</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(transactionRes.<span class="property">hash</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证： <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">verify</span>(<span class="params">proof:<span class="built_in">Uint8Array</span>,hash:Buffer</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set merkle root: <span class="subst">$&#123;hash&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> entryFunctionPayload = <span class="keyword">new</span> <span class="title class_">TransactionPayloadEntryFunction</span>(</span><br><span class="line">        <span class="title class_">EntryFunction</span>.<span class="title function_">natural</span>(          </span><br><span class="line">          <span class="string">&quot;0xe463a68bb1dd0d9b9864ed030a8cd357f2a38b6b3fea92c0af07694db203a6e0::merkle&quot;</span>,          </span><br><span class="line">          <span class="string">&quot;verify&quot;</span>,          </span><br><span class="line">          [],</span><br><span class="line">          [<span class="variable constant_">BCS</span>.<span class="title function_">bcsSerializeBytes</span>(proof),<span class="variable constant_">BCS</span>.<span class="title function_">bcsSerializeBytes</span>(hash)],</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">BCS</span>.<span class="title function_">bcsSerializeBytes</span>(proof));</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">BCS</span>.<span class="title function_">bcsSerializeBytes</span>(hash));</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">const</span> [&#123; <span class="attr">sequence_number</span>: sequenceNumber &#125;, chainId] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">        client.<span class="title function_">getAccount</span>(admin.<span class="title function_">address</span>()),</span><br><span class="line">        client.<span class="title function_">getChainId</span>(),</span><br><span class="line">      ]);</span><br><span class="line">      <span class="keyword">const</span> rawTxn = <span class="keyword">new</span> <span class="title class_">RawTransaction</span>(</span><br><span class="line">        <span class="title class_">AccountAddress</span>.<span class="title function_">fromHex</span>(admin.<span class="title function_">address</span>()),</span><br><span class="line">        <span class="title class_">BigInt</span>(sequenceNumber),</span><br><span class="line">        entryFunctionPayload,</span><br><span class="line">        <span class="title class_">BigInt</span>(<span class="number">2000</span>),</span><br><span class="line">        <span class="title class_">BigInt</span>(<span class="number">100</span>),</span><br><span class="line">        <span class="title class_">BigInt</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() / <span class="number">1000</span>) + <span class="number">10</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ChainId</span>(chainId),</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> bcsTxn = <span class="title class_">AptosClient</span>.<span class="title function_">generateBCSTransaction</span>(admin, rawTxn);  </span><br><span class="line">      <span class="keyword">const</span> transactionRes = <span class="keyword">await</span> client.<span class="title function_">submitSignedBCSTransaction</span>(bcsTxn);</span><br><span class="line">      <span class="keyword">await</span> client.<span class="title function_">waitForTransaction</span>(transactionRes.<span class="property">hash</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(transactionRes.<span class="property">hash</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> account = <span class="string">&#x27;0x09d4ee382de0fa20f889ac6158273f29c81a1fec7385e8e26801db2e9e0c2f32&#x27;</span></span><br><span class="line"><span class="comment">//console.log(&#x27;0x254a8d20f95c8a0ac2cb39041ba3375f6742dea2accf4361028e43ea669b8a91&#x27;);</span></span><br><span class="line"><span class="title function_">verify</span>(<span class="title function_">get_proof</span>(account),<span class="title function_">keccak256</span>(account));</span><br></pre></td></tr></table></figure></p>
<p>源码仓库地址：https://github.com/passer-byzhang/aptos-merkle
作者地址：alvan.coffee</p>
]]></content>
      <categories>
        <category>Aptos</category>
      </categories>
      <tags>
        <tag>Move</tag>
        <tag>Aptos</tag>
      </tags>
  </entry>
  <entry>
    <title>使用vscode中运行rust单元测试找不到cargo的解决方法</title>
    <url>/2022/07/02/vscode-rust-extension-bug/</url>
    <content><![CDATA[<p>最近在vscode上写rust代码时，插件自带的运行和调试用不了了，说是读不到cargo:</p>
<p><img src="vscode-runtest.png" /></p>
<p>一点就会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executing task: cargo test -- --nocapture test_add</span><br><span class="line">&lt; zsh:1: command not found: cargo</span><br></pre></td></tr></table></figure>
<p>我们找到这个插件的位置，再修改一下这个文件，路径里的版本号换成当前使用的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.vscode/extensions/rust-lang.rust-0.7.8/out/src/tasks.js</span><br></pre></td></tr></table></figure>
<p>找到掌管shell初始化的createShellExecution函数：</p>
<p>把这句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cmdLine = <span class="string">`<span class="subst">$&#123;command || binary&#125;</span> <span class="subst">$&#123;args.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>加上加载cargo环境变量，变成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cmdLine = <span class="string">`source $HOME/.cargo/env; <span class="subst">$&#123;command || binary&#125;</span> <span class="subst">$&#123;args.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>就ok了，重启一下就好。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
</search>
